
<!DOCTYPE html>
<html lang="en" dir="ltr" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Object RTC (ORTC) API for WebRTC</title>
    <meta charset='utf-8'>
  
  <script src="http://www.w3.org/Tools/respec/respec-w3c-common"
          async class="remove"></script>
  <script class="remove">
var respecConfig = {
    "title": "Object RTC (ORTC) API for WebRTC",
    "specStatus": "CG-DRAFT",
    "shortName":  "orca-api",
    "publishDate": "2014-02-13",
    "editors": [
        {   "name":       "Robin Raymond",
            "url":        "http://about.me/robinraymond",
            "company":    "Hookflash",
            "companyURL": "http://www.hookflash.com/" }
    ],
    "authors": [
        {   "name":       "Inaki Baz Castillo",
            "url":        "",
            "company":    "Versatica",
            "companyURL": "http://versatica.com/" },
        {   "name":       "Jose Luis Millan",
            "url":        "",
            "company":    "Versatica",
            "companyURL": "http://versatica.com/" },
        {   "name":       "Christoph Dorn",
            "url":        "http://christophdorn.com/",
            "company":    "Hookflash",
            "companyURL": "http://www.hookflash.com/" },
        {   "name":       "Roman Shpount",
            "url":        "", 
            "company":    "TurboBridge",
            "companyURL": "http://turbobridge.com/" },
        {   "name":       "Erik Lagerway",
            "url":        "http://about.me/elagerway",
            "company":    "Hookflash",
            "companyURL": "http://www.hookflash.com/" }
    ],
    "previousMaturity": "",
    "previousPublishDate":  "",
    "wg":           "Object-RTC API Community Group",
    "wgURI":        "http://www.w3.org/community/orca/",
    "wgPublicList": "public-orca",
    "wgPatentURI":  "",
    "localBiblio":  {
    "RFC4585": {
        title:    "Extended RTP Profile for RTCP-Based Feedback (RTP/AVPF)"
    ,   href:     "http://tools.ietf.org/html/rfc4585"
    ,   authors:  [
            "J. Ott"
        ,   "S. Wenger"
        ,   "N. Sato"
        ,   "C. Burmeister"
        ,   "J. Rey"
        ]
    ,   status:   "RFC 4585, July 2006"
    ,   publisher:  "IETF"
    },
    "RFC5285": {
        title:    "A General Mechanism for RTP Header Extensions"
    ,   href:     "http://tools.ietf.org/html/rfc5285"
    ,   authors:  [
            "D. Singer"
        ,   "H. Desineni"
        ]
    ,   status:   "RFC 5285, July 2008"
    ,   publisher:  "IETF"
    },
    "RFC5761": {
        title:    "Multiplexing RTP Data and Control Packets on a Single Port"
    ,   href:     "http://tools.ietf.org/html/rfc5761"
    ,   authors:  [
            "C. Perkins"
        ,   "M. Westerlund"
        ]
    ,   status:   "RFC 5761, April 2010"
    ,   publisher:  "IETF"
    },
    "RFC6904": {
        title:    "Encryption of Header Extensions in the SRTP"
    ,   href:     "http://tools.ietf.org/html/rfc6904"
    ,   authors:  [
            "J. Lennox"
        ]
    ,   status:   "RFC 6904, April 2013"
    ,   publisher:  "IETF"
    },
    "STUN-URI": {
        title:    "URI Scheme for Session Traversal Utilities for NAT (STUN) Protocol"
    ,   href:     "http://tools.ietf.org/html/draft-nandakumar-rtcweb-stun-uri"
    ,   authors:  [
            "S. Nandakumar",
            "G. Salgueiro",
            "P. Jones",
            "M. Petit-Huguenin"
        ]
    ,   status:   "12 March 2012. Internet Draft (work in progress)"
    ,   publisher:  "IETF"
    },
    "TURN-URI": {
        title:    "Traversal Using Relays around NAT (TURN) Uniform Resource Identifiers"
    ,   href:     "http://tools.ietf.org/html/draft-petithuguenin-behave-turn-uris"
    ,   authors:  [
            "M. Petit-Huguenin",
            "S. Nandakumar",
            "G. Salgueiro",
            "P. Jones"
        ]
    ,   status:   "12 March 2012. Internet Draft (work in progress)"
    ,   publisher:  "IETF"
    }
}
};
  </script>  
</head>
<body>

<section id="abstract">
<p>
This document defines a set of ECMAScript APIs in WebIDL to allow media to be sent and received
from another browser or device implementing the appropriate set of real-time protocols.  However,
unlike the current WebRTC 1.0 APIs, ORTC does not mandate a media signaling protocol or
format.  As a result, ORTC does not utilize Session Description Protocol (SDP) within its APIs, nor does it mandate support for
the Offer/Answer state machine. Instead, ORTC focuses on "connections" and "tracks" being
carried over those connections.
</p>
</section>

<section id='sotd'>
</section>

<section id="overview*">

  <h2><span class="secno"> </span>Overview</h2>

<p>Object RealTime Communications (ORTC) provides a powerful API for the development of WebRTC based applications. 
ORTC does not mandate a media signaling protocol or format (as the current WebRTC 1.0 does by mandating SDP Offer/Answer). 
Instead, ORTC focuses on "sender", "receiver" and "transport" objects, which have 
"capabilities" describing what they are capable of doing, 
as well as "parameters" which define what they are configured to do. 
"Tracks" and "data channels" are sent over the transports, between senders and receivers.</p>
<p>This specification defines several objects: RTCDtlsTransport (Section 2), RTCIceTransport (Section 3), 
RTCIceListener (Section 4), RTCRtpSender (Section 5), RTCRtpReceiver (Section 6), 
RTCDTMFTrack (Section 8), RTCDataChannel
(Section 9), and RTCSctpTransport (Section 10); RTP dictionaries are described in Section 7.</p>
<p>  
In a Javascript application utilizing the ORTC API,  
the relationship between the application and the objects, as well 
as between the objects themselves is shown below:</p>

<img alt="The non-normative ORTC Big Picture Diagram" src="ortc-big-picture.png" style="width:80%" />

  <section>
    <h3>Terminology</h3>

    <p>The <code><a href=
    "http://dev.w3.org/html5/spec/webappapis.html#eventhandler">EventHandler</a></code>
    interface represents a callback used for event handlers as defined in
    [[!HTML5]].</p>

    <p>The concepts <dfn><a href=
    "http://dev.w3.org/html5/spec/webappapis.html#queue-a-task">queue a
    task</a></dfn> and <dfn><a href=
    "http://dev.w3.org/html5/spec/webappapis.html#fire-a-simple-event">fires a
    simple event</a></dfn> are defined in [[!HTML5]].</p>

    <p>The terms <dfn>event</dfn>, <dfn><a href=
    "http://dev.w3.org/html5/spec/webappapis.html#event-handlers">event
    handlers</a></dfn> and <dfn><a href=
    "http://dev.w3.org/html5/spec/webappapis.html#event-handler-event-type">event
    handler event types</a></dfn> are defined in [[!HTML5]].</p>

    <p>The terms <dfn>MediaStream</dfn>, <dfn>MediaStreamTrack</dfn>,
    <dfn>Constraints</dfn>, and <dfn>Consumer</dfn> are defined in
    [[!GETUSERMEDIA]].</p>
  </section>
</section>
<section id="rtcdtlstransport*">
  <h2>The RTCDtlsTransport Object</h2>

    <p>
The <dfn>RTCDtlsTransport</dfn> includes information relating to Datagram Transport Layer Security (DTLS) transport. 
    </p>

  <section id="rtcdtlstransport-overview*">
    <h3>Overview</h3>

    <p>An <a>RTCDtlsTransport</a> instance is associated to an <a>RTCRtpSender</a> or an <a>RTCRtpReceiver</a>.</p>
  </section>

  <section id="rtcdtlstransport-operation*">
    <h3>Operation</h3>

    <p>A <a>RTCDtlsTransport</a> instance is optionally constructed from an <a>RTCIceTransport</a> 
       object or an <a>RTCIceTransport</a> is automatically constructed.</p>
  </section>

  <section id="rtcdtlstransport-interface-definition*">
    <h3>Interface Definition</h3>

    <dl class="idl" title="[Constructor(optional RTCIceTransport transport)] interface RTCDtlsTransport">
      <dt>readonly attribute RTCIceTransport transport</dt>
      <dd>The associated <a>RTCIceTransport</a> instance.</dd>

      <dt>readonly attribute RTCDtlsTransportState state</dt>
      <dd>The current state of the DTLS transport.</dd>

      <dt>RTCDtlsParameters getLocalParameters()</dt>
      <dd>Obtain the DTLS parameters of the local <a>RTCDtlsTransport</a>.</dd>

      <dt>RTCDtlsParameters? getRemoteParameters()</dt>
      <dd>Obtain the current DTLS parameters of the remote <a>RTCDtlsTransport</a>.</dd>

      <dt>void start(RTCDtlsParameters remoteParameters)</dt>
      <dd>Start DTLS transport negotiation with the parameters of the remote DTLS transport.</dd>

      <dt>void stop()</dt>
      <dd>Stops and closes the DTLS transport object.</dd>

      <dt>attribute EventHandler? onstatechange</dt>
      <dd>Set this handler to receive events when the state of the DTLS transport changes.</dd>

    </dl>
  </section>

  <section id="rtcdtlstransport-example*">
    <h3>Example</h3>

    <pre class="example"><code class="javascript">
    </code></pre>
  </section>

  <section id="rtcdtlstransportstate*">
    <h3>enum RTCDtlsTransportState</h3>

    <dl class="idl" title="enum RTCDtlsTransportState">
      <dt>new</dt>
      <dd>new state</dd>

      <dt>connecting</dt>
      <dd>connecting state</dd>

      <dt>connected</dt>
      <dd>connected state</dd>

      <dt>closed</dt>
      <dd>closed state</dd>
    </dl>
  </section>

</section>

<section id="rtcicetransport*">
  <h2>The RTCIceTransport Object</h2>

    <p>
      The <dfn>RTCIceTransport</dfn> includes information relating to Interactive Connectivity Establishment (ICE).
    </p>

  <section id="rtcicetransport-overview*">
    <h3>Overview</h3>

    <p>An <a>RTCIceTransport</a> instance is associated to a transport object (such as RTCDtlsTransport), 
       and provides RTC related methods to it.</p>
  </section>

  <section id="rtcicetransport-operation*">
    <h3>Operation</h3>

    <p>An <a>RTCIceTransport</a> instance is constructed from an <a>RTCIceRole</a>  
       and either an <a>RTCIceListener</a>  
       or an <a>RTCIceOptions</a> object.</p>
  </section>

  <section id="rtcicetransport-interface-definition*">
    <h3>Interface Definition</h3>

    <dl class="idl" title="[Constructor(RTCIceRole role, optional RTCIceListener iceListener), 
     Constructor(RTCIceRole role, RTCIceOptions options)] interface RTCIceTransport">
      <dt>readonly attribute RTCIceRole role</dt>
      <dd>The current role of the ICE transport.</dd>
      <dt>readonly attribute RTCIceTransportState state</dt>
      <dd>The current state of the ICE transport.</dd>

      <dt>readonly attribute sequence&lt;RTCIceCandidate>  localCandidates</dt>
      <dd>Sequence of the candidates associated with local <a>RTCIceTransport</a>.</dd>

      <dt>readonly attribute sequence&lt;RTCIceCandidate> remoteCandidates</dt>
      <dd>Sequence of the candidates associated with remote <a>RTCIceTransport</a>.</dd>

      <dt>void gather()</dt>
      <dd>Start gathering <a>RTCIceCandidate</a> objects.</dd>

      <dt>void start(optional RTCIceParameters remoteParameters)</dt>
      <dd>Starts candidates connectivity checks and attempts to connect to the remote <a>RTCIceTransport</a>.</dd>

      <dt>void stop()</dt>
      <dd>Stops and closes the current object.</dd>

      <dt>RTCIceParameters getLocalParameters()</dt>
      <dd>Obtain the ICE parameters of the local <a>RTCIceTransport</a>.</dd>

      <dt>RTCIceParameters? getRemoteParameters()</dt>
      <dd>Obtain the current ICE parameters of the remote <a>RTCIceTransport</a>.</dd>

      <dt>void setRemoteParameters(RTCIceParameters remoteParameters)</dt>
      <dd>Set the remote parameters associated with the remote <a>RTCIceTransport</a>.</dd>

      <dt>void addRemoteCandidate(RTCIceCandidate remoteCandidate)</dt>
      <dd>Add remote candidate associated with remote <a>RTCIceTransport</a>.</dd>

      <dt>attribute EventHandler? onlocalcandidate</dt>
      <dd>Set this handler to receive events when a new local candidate is available.</dd>

      <dt>attribute EventHandler? onstatechange</dt>
      <dd>Set this handler to receive events when the state of the <a>RTCIceTransport</a> has changed.</dd>

    </dl>
  </section>

  <section id="rtcicetransport-example1*">
    <h3>Examples</h3>

    <pre class="example"><code class="javascript">

// Assume we already have a way to signal. This is an example
// of  how to offer ICE and DTLS parameters and ICE candidates and
// get back ICE and DTLS parameters and ICE candidates, and start
// both ICE and DTLS.

function initiate(signaller) {
 var iceOptions = ...;
 var ice = new RTCIceTransport(RTCIceRole.controlling, iceOptions);
 var dtls = new RTCDtlsTransport(ice);
 // ... get tracks and RTP objects from other example

 signaller.sendInitiate({
   "ice": ice.
getLocalParameters(),
   "dtls": dtls.
getLocalParameters(),
   // ... include RTP info from other example
 }, function(remote) {
   ice.setRemoteParameters(remote.ice);
   dtls.start(remote.dtls);
   // ... start RTP senders and receivers from other example
 });

 ice.oncandidate = function(candidate) {
   signaller.sendLocalCandidate(candidate);
 }

 signaller.onRemoteCandidate = function(candidate) {
   ice.addRemoteCandidate(candidate);
 }

 ice.start();
}

    </code></pre>

    <pre class="example"><code class="javascript">

// Assume we already have a way to signal and remote info is 
// signalled to us.  This is an example of how to answer with ICE and DTLS
// and DTLS parameters and ICE candidates and start both ICE and DTLS.
//
function accept(signaller, remote) {
 var iceOptions = ...;
 var ice = new RTCIceTransport(iceOptions);
 var dtls = new RTCDtlsTransport(ice);
 // ... get tracks and RTP objects from other example
 ice.oncandidate = function(candidate) {
   signaller.sendLocalCandidate(candidate);
 }

 signaller.onRemoteCandidate = function(candidate) {
   ice.addRemoteCandidate(candidate);
 }

 signaller.sendAccept({
   "ice": ice.
getLocalParameters(),
   "dtls": ice.
getLocalParameters()
   // ... include RTP info from other example
 });

 ice.start(remote.ice);
 dtls.start(remote.dtls);

 // ... start RTP senders and receivers from other example
}

    </code></pre>
  </section>

  <section id="rtcicerole*">
    <h3>enum RTCIceRole</h3>

    <dl class="idl" title="enum RTCIceRole">
      <dt>controlling</dt>
      <dd>controlling state</dd>

      <dt>controlled</dt>
      <dd>controlled state</dd>
    </dl>
  </section>

  <section id="rtcicetransportstate*">
    <h3>enum RTCIceTransportState</h3>

    <dl class="idl" title="enum RTCIceTransportState">
      <dt>new</dt>
      <dd>new state</dd>

      <dt>checking</dt>
      <dd>checking state</dd>

      <dt>connected</dt>
      <dd>connected state</dd>

      <dt>completed</dt>
      <dd>completed state</dd>

      <dt>disconnected</dt>
      <dd>disconnected state</dd>

      <dt>closed</dt>
      <dd>closed state</dd>
    </dl>

<p>The non-normative ICE state transitions are:</p>

<img alt="The non-normative ICE State Transition Diagram" src="icestates.png" style="width:50%" />
</section>

  <section id="rtciceoptions*">
   <h3>The RTCIceOptions Object</h3>

   <p>
     The <dfn>RTCIceOptions</dfn> object includes information relating to ICE configuration.
   </p>

    <dl class="idl" title="dictionary RTCIceOptions">
      <dt>sequence&lt;RTCIceServer>? iceServers</dt>
      <dd>An array containing STUN and TURN servers available to be used by ICE.</dd>
    </dl>

  </section>

  <section id="rtciceserver*">
   <h3>The RTCIceServer Object</h3>

   <p>
    The <dfn>RTCIceServer</dfn> is used to provide STUN or TURN server configuration. In network topologies with multiple layers of NATs, it is desirable to have a STUN server between every layer of NATs in addition to the TURN servers to minimize the peer to peer network latency.
   <p>

   </p>
     An example of an array of RTCIceServer objects:
   </p>

    <pre class="example"><code class="javascript">
      [ { urls: "stun:stun1.example.net } , { urls:"turn:turn.example.org", username: "user", credential:"myPassword"} ]
    </code></pre>

    <dl class="idl" title="dictionary RTCIceServer">
      <dt>(DOMString or sequence&lt;DOMString>) urls</dt>
      <dd>STUN or TURN URI(s) as defined in [[!STUN-URI]] and [[!TURN-URI]]</dd>
      <dt>DOMString? username</dt>
      <dd>If this RTCIceServer object represents a TURN server, then this attribute specifies the username to use with that TURN server.</dd>
      <dt>DOMString? credential</dt>
      <dd>If the uri element is a TURN-URI, then this is the credential to use with that TURN server.</dd>
    </dl>

  </section>


  <section id="rtcicecandidate*">
    <h3>The RTCIceCandidate Object</h3>

    <p>
      The <dfn>RTCIceCandidate</dfn> object includes information relating to an ICE candidate.
    </p>

    <pre class="example"><code class="javascript">{
  foundation: "abcd1234",
  priority: 1694498815,
  connectionAddress: "192.0.2.33",
  connectionPort: 10000,
  type: "host"
};
    </code></pre>

    <dl class="idl" title="dictionary RTCIceCandidate">
      <dt>DOMString foundation</dt>
      <dd>
        A unique identifier that allows ICE to correlate candidates that appear on multiple <a>RTCIceTransport</a>s.
      </dd>
      <dt>unsigned long priority</dt>
      <dd>The assigned priority of the candidate.  This is automatically populated by the browser.</dd>
      <dt>DOMString ip</dt>
      <dd>The IP address of the candidate.</dd>
      <dt>unsigned short port</dt>
      <dd>The UDP port for the candidate.</dd>
      <dt>RTCIceCandidateType type</dt>
      <dd>The type of candidate.</dd>
      <dt>DOMString? relatedAddress</dt>
      <dd>
        For candidates that are derived from others, such as relay or reflexive candidates, this
        refers to the host candidate that these are derived from.  This value is not present on
        host candidates.
      </dd>
      <dt>unsigned short? relatedPort</dt>
      <dd>
        For candidates that are derived from others, such as relay or reflexive candidates, this
        refers to the host candidate that these are derived from.  This value is not present on
        host candidates.
      </dd>
    </dl>

    <section>
      <h4>The RTCIceCandidateType</h4>
      <p>
        The <dfn>RTCIceCandidateType</dfn> includes the type of ICE candidate.
      </p>
      <dl class="idl" title="enum RTCIceCandidateType">
        <dt>host</dt>
        <dd>A host candidate.</dd>
        <dt>srflx</dt>
        <dd>A server reflexive candidate.</dd>
        <dt>prflx</dt>
        <dd>A peer reflexive candidate.</dd>
        <dt>relay</dt>
        <dd>A relay candidate.</dd>
      </dl>
    </section>
  </section>
</section>

<section id="rtcicelistener*">
  <h2>The RTCIceListener Object</h2>

    <p>
      The <dfn>RTCIceListener</dfn> enables an endpoint to construct multiple RTCIceTransport 
      objects from a set of local ICE parameters, 
      enabling usage scenarios such as parallel forking.
    </p>

  <section id="rtcicelistener-overview*">
    <h3>Overview</h3>

    <p>An <a>RTCIceListener</a> instance is associated to an <a>RTCIceTransport</a>.</p>
  </section>

  <section id="rtcicelistener-operation*">
    <h3>Operation</h3>

    <p>An <a>RTCIceListener</a> instance is optionally constructed from an <a>RTCIceOptions</a> object,
       or an <a>RTCIceListener</a> is automatically constructed.</p>
  </section>

  <section id="rtcicelistener-interface-definition*">
    <h3>Interface Definition</h3>

    <dl class="idl" title="[Constructor(optional RTCIceOptions options)] interface RTCIceListener">
      <dt>readonly attribute <a>RTCIceOptions</a>                    options</dt>
      <dd>
        <p>The <a>RTCIceOptions</a> instance.</p>
      </dd>
      <dt><a>RTCIceParameters</a>                  getLocalParameters()</dt>
      <dd></dd>
      <dt>readonly attribute sequence&lt;RTCIceCandidate>  localCandidates</dt>
      <dd></dd>
      <dt>void start()</dt>
      <dd></dd>
      <dt>void stop()</dt>
      <dd></dd>
      <dt>attribute EventHandler?   onlocalcandidate</dt>
      <dd></dd>
      <dt>attribute EventHandler?   ongatherfailure</dt>
      <dd></dd>
    </dl>
  </section>

  <section id="rtcicelistener-example*">
    <h3>Example</h3>
    <pre class="example"><code class="javascript">

var iceOptions = ...;
var iceListener = new RTCIceListener(iceOptions);
sendInitiate(iceListener.getLocalParameters(), function(response) {
  // We may get N responses
  var ice = new RTCIceTransport(RTCIceRole.controlling, iceListener);
  var ice.setRemoteParameters(response.iceParameters);
  ice.start();
  // ... setup DTLS, RTP, SCTP, etc.
});

iceListener.oncandidate = sendLocalCandidate;
iceListener.start();

    </code></pre>

  </section>
</section>

<section id="rtcrtpsender*">
  <h2>The RTCRtpSender Object</h2>

    <p>
      The <dfn>RTCRtpSender</dfn> includes information relating to the RTP sender.
    </p>

  <section id="rtcrtpsender-overview*">
    <h3>Overview</h3>

    <p>An <a>RTCRtpSender</a> instance is associated to a sending <a>MediaStreamTrack</a> and provides RTC related methods to it.</p>
  </section>

  <section id="rtcrtpsender-operation*">
    <h3>Operation</h3>

    <p>A <a>RTCRtpSender</a> instance is constructed from an <a>MediaStreamTrack</a> object and associated to an <a>RTCDtlsTransport</a>.</p>
  </section>

  <section id="rtcrtpsender-interface-definition*">
    <h3>Interface Definition</h3>

    <dl class="idl" title="[Constructor(MediaStreamTrack track, RTCDtlsTransport transport)] interface RTCRtpSender">
      <dt>attribute <a>MediaStreamTrack</a>                    track</dt>
      <dd>
        <p>The associated <a>MediaStreamTrack</a> instance.</p>
      </dd>
      
      <dt>attribute <a>RTCDtlsTransport</a>                    transport</dt>
      <dd>
        <p>The associated <a>RTCDtlsTransport</a> instance.</p>
      </dd>

      <dt>static <a>RTCRtpCapabilities</a> getCapabilities()</dt>
      <dd><p>Obtain the capabilities of the <a>RTCRtpSender</a>.</p></dd>

      <dt>static <a>RTCRtpParameters</a> createParameters(<a>MediaStreamTrack</a> parameters, optional <a>RTCRtpCapabilities</a> capabilities)</dt>
      <dd><p>Create parameters based on the <a>MediaStreamTrack</a> and the capabilities specified in <a>RTCRtpCapabilities</a>.</p></dd>

      <dt>static <a>RTCRtpParameters</a> filterParameters(<a>RTCRtpParameters</a> parameters, optional <a>RTCRtpCapabilities</a> capabilities)</dt>
      <dd><p>Filter parameters based on the <a>RTCRtpCapabilities</a>.</p></dd>

      <dt>void send(<a>RTCRtpParameters</a> parameters)</dt>
      <dd><p>Media is controlled by the given "parameters".  The sender starts sending when the send() is called and stopped when the stop() is called.</p></dd>

      <dt>void stop()</dt>
      <dd><p>Stops sending the track on the wire.  Stop is final like <a>MediaStreamTrack</a></p></dd>

    </dl>
  </section>

  <section id="rtcrtpsender-example*">
    <h3>Example</h3>

    <pre class="example"><code class="javascript">
    </code></pre>
  </section>

</section>

<section id="rtcrtpreceiver*">
  <h2>The RTCRtpReceiver Object</h2>

    <p>
      The <dfn>RTCRtpReceiver</dfn> includes information relating to the RTP receiver. 
    </p>

  <section id="rtcrtpreceiver-overview*">
    <h3>Overview</h3>

    <p>An <a>RTCRtpReceiver</a> instance is associated to a sending <a>MediaStreamTrack</a> and provides RTC related methods to it.</p>
  </section>

  <section id="rtcrtpreceiver-operation*">
    <h3>Operation</h3>

    <p>A <a>RTCRtpReceiver</a> instance is constructed from an <a>MediaStreamTrack</a> object and associated to an <a>RTCDtlsTransport</a>.</p>
  </section>

  <section id="rtcrtpreceiver-interface-definition*">
    <h3>Interface Definition</h3>

    <dl class="idl" title="[Constructor(MediaStreamTrack track, RTCDtlsTransport transport)] interface RTCRtpReceiver">
      <dt>attribute <a>MediaStreamTrack</a>? track</dt>
      <dd>
        <p>The associated <a>MediaStreamTrack</a> instance.</p>
      </dd>
      
      <dt>attribute <a>RTCDtlsTransport</a> transport</dt>
      <dd>
        <p>The associated <a>RTCDtlsTransport</a> instance.</p>
      </dd>

      <dt>static <a>RTCRtpCapabilities</a> getCapabilities()</dt>
      <dd><p>Obtain the capabilities of the <a>RTCRtpReceiver</a>.</p></dd>

      <dt>static <a>RTCRtpParameters</a> createParameters (DOMString kind, optional RTCRtpCapabilities capabilities)</dt>
      <dd>
        Create parameters based on the kind and the capabilities specified in <a>RTCRtpCapabilities</a>.
        <dl class='parameters'>
            <dt>DOMString kind</dt>
            <dd>
              Specifies kind, either "audio" or "video".
            </dd>
            <dt>optional RTCRtpCapabilities capabilities</dt>
            <dd></dd>
          </dl>
      </dd>

      <dt>static <a>RTCRtpParameters</a> filterParameters(<a>RTCRtpParameters</a> parameters, optional <a>RTCRtpCapabilities</a> capabilities)</dt>
      <dd><p>Filter parameters based on the <a>RTCRtpCapabilities</a>.</p></dd>

      <dt>void receive(<a>RTCRtpParameters</a> parameters)</dt>
      <dd><p>Media is controlled by the given "parameters". The receiver starts receiving when the receive() is called and stopped when the stop() is called.</p></dd>

      <dt>void stop()</dt>
      <dd><p>Stops receiving the track on the wire. Stop is final like <a>MediaStreamTrack</a></p></dd>

    </dl>
  </section>

  <section id="rtcrtpreceiver-example*">
    <h3>Examples</h3>

    <pre class="example"><code class="javascript">
// Assume we already have a way to signal, a transport 
// (RTCDtlsTransport), and audio and video tracks. This is an example 
// of  how to offer them  and get back an answer with audio and 
// video tracks, and begin sending and receiving them.
function initiate(signaller, transport, audioTrack, videoTrack) {
  var audioSender = new RTCRtpSender(audioTrack, transport);
  var videoSender = new RTCRtpSender(videoTrack, transport);
  var audioReceiver = new RTCRtpReceiver(transport);
  var videoReceiver = new RTCRtpReceiver(transport);

  var sendAudioParams = RTCRtpSender.createParameters(audioTrack);
  var sendVideoParams = RTCRtpSender.createParameters(videoTrack);
  signaller.offerTracks({
    // The initiator offers parameters it wants to send with, 
    // and the capabilities it has for receiving. 
    "rtpCaps": RTCRtpReceiver.getCapabilities(),
    "audio": sendAudioParams,
    "video": sendVideoParams
  }, function(answer) {
    // The responder answers with parameters it wants to send with
    // and the capabilities it has for receiving. 
    audioSendParams = RTCRtpSender.filterParameters(
       sendAudioParams, answer.rtpCaps);
    videoSendParams = RTCRtpSender.filterParameters(
       sendVideoParams, answer.rtpCaps
    var audioRecvParams = RTCRtpSender.filterParameters(
       answer.audio);
    var videoRecvParams = RTCRtpSender.filterParameters(
       answer.video);
      
    audioSender.send(audioSendParams);
    videoSender.send(videoSendParams)
    audioReceiver.receive(audioRecvParams);
    videoReceiver.receive(videoRecvParams);

    // Now we can render/play 
    // audioReceiver.track and videoReceiver.track.
  });
}
    </code></pre>
    <pre class="example"><code class="javascript">

// Assume we already have a way to signal, a transport 
// (RTCDtlsTransport), and audio and video tracks. This is an example 
// of how to answer an offer with audio and video tracks, and begin 
// sending and receiving them.
function accept(
  signaller, remote, transport, audioTrack, videoTrack) {
  var audioSender = new RTCRtpSender(audioTrack, transport);
  var videoSender = new RTCRtpSender(videoTrack, transport);
  var audioReceiver = new RTCRtpReceiver(transport);
  var videoReceiver = new RTCRtpReceiver(transport);

  var audioSendParams = RTCRtpSender.createParameters(
    audioTrack, remote.rtpCaps);
  var videoSendParams = RTCRtpSender.createParameters(
    videoTrack, remote.rtpCaps);
  var audioRecvParams = RTCRtpSender.filterParameters(
     remote.audio);
  var videoRecvParams = RTCRtpSender.filterParameters(
     remote.video);
  
  audioSender.send(audioSendParams);
  videoSender.send(videoSendParams)
  audioReceiver.receive(audioRecvParams);
  videoReceiver.receive(videoRecvParams);
 
  signaller.answerTracks({
    "rtpCaps": RTCRtpReceiver.getCapabilities(),
    "audio": audioSender.parameters(),
    "video": videoSender.parameters()
  });

  // Now we can render/play 
  // audioReceiver.track and videoReceiver.track.
}
    </code></pre>
  </section>

</section>

<section id="rtcrtpdictionaries*">
  <h2>Dictionaries related to Rtp</h2>

  <section id="rtcrtpcapabilities*">
    <h3>dictionary RTCRtpCapabilities</h3>
    <dl title='dictionary RTCRtpCapabilities' class='idl'>
      <dt>sequence&lt;RTCRtpCodec> audioCodecs</dt>
      <dd>Supported audio codecs.</dd>
      <dt>sequence&lt;RTCRtpCodec> videoCodecs</dt>
      <dd>Supported video codecs.</dd>
      <dt>sequence&lt;DOMString> headerExtensions</dt>
      <dd>URIs of supported RTP header extensions.</dd>
      <dt>sequence&lt;RTCRtpFeatures> features</dt>
      <dd>Supported features.</dd>
    </dl>
  </section>

  <section id="rtcrtpcodec*">
    <h3>dictionary RTCRtpCodec</h3>
    <dl class="idl" title="dictionary RTCRtpCodec">
      <dt>DOMString name</dt>
        <dd>MIME media type</dd>
      <dt>unsigned byte? payload-id</dt>
        <dd>Payload Type</dd>
      <dt>unsigned int? clockRate</dt>
        <dd>Codec clockrate</dd>
      <dt>unsigned int? numChannels</dt>
        <dd></dd>
      <dt>sequence&lt;RTCRtpCodecParameter> formatParameters</dt>
        <dd>Codec-specific format parameters.</dd>
    </dl>
  </section>

  <section id="rtcrtpcodecparameter*">
    <h3>dictionary RTCRtpCodecParameter</h3>
    <dl class="idl" title="dictionary RTCRtpCodecParameter">
      <dt>DOMString           name</dt>
         <dd>Name of the codec-specific parameter.</dd>
      <dt>DOMString?          value</dt>
         <dd>Value of the codec-specific parameter.</dd>
    </dl>
  </section>

  <section id="rtcrtpfeatures*">
    <h3>enum RTCRtpFeatures</h3>
    <dl class="idl" title="enum RTCRtpFeatures">
      <dt>nack</dt>
      <dd>From [[!RFC4585]]</dd>
    </dl>
  </section>

  <section id="rtcrtpparameters*">
    <h3>dictionary RTCRtpParameters</h3>
    <dl title='dictionary RTCRtpParameters' class='idl'>
      <dt>sequence&lt;RTCRtpCodec> codecs</dt>
      <dd></dd>
      <dt>sequence&lt;RTCRtpEncodingParameters> encodings</dt>
      <dd>Can specify multiple layers or "encodings" to be used for things like simulcast, RTC, FEC, etc.</dd>
      <dt>sequence&lt;RTCRtpHeaderExtensionParameters> headerExtensions</dt>
      <dd>Can specify RTP header extensions.</dd>
    </dl>
  </section>

  <section id="rtcrtpencodingparameters*">
    <h3>dictionary RTCRtpEncodingParameters</h3>
    <dl title='dictionary RTCRtpEncodingParameters' class='idl'>
      <dt>unsigned int ssrc</dt>
      <dd></dd>
      <dt>int TODO</dt>
      <dd>Temporary placeholder for things to control various layers, simulcast, rtc, etc.</dd>
    </dl>
  </section>

  <section id="rtcrtpheaderextensionparameters*">
    <h3>dictionary RTCRtpHeaderExtensionParameters</h3>
    <dl class="idl" title="dictionary RTCRtpHeaderExtensionParameters">
      <dt>DOMString           uri</dt>
         <dd>The URI of the RTP header extension, as defined in [[!RFC5285]].</dd>
      <dt>unsigned short      id</dt>
         <dd>The value that goes in the packet.</dd>
      <dt>boolean           encrypt</dt>
          <dd>If true, encrypt the value in the header, as per [[!RFC6904]].</dd>
    </dl>

  </section>
</section>

<section id="rtcdtmfsender*">
  <h2>The RTCDtmfSender Object</h2>

  <section id="rtcdtmfsender-overview*">
    <h3>Overview</h3>

    <p>An <dfn>RTCDtmfSender</dfn> instance allows sending DTMF tones to/from the remote peer.</p>
  </section>

  <section id="rtcdtmfsender-operation*">
    <h3>Operation</h3>

    <p>An <a>RTCDtmfSender</a> object is constructed from an <a>RTCRtpSender</a> object.</p>
  </section>

  <section id="rtcdtmfsender-interface-definition*">
    <h3>Interface Definition</h3>

    <dl class="idl" title="[Constructor(RTCRtpSender)] interface RTCDtmfSender">
      <dt>readonly attribute boolean <a>canInsertDTMF</a></dt>
      <dd
        <p>Whether the <a>RTCDtmfSender</a> is capable of sending DTMF.</p>
      </dd>

        <dt>void insertDTMF(in DOMString tones, optional long duration, long
        interToneGap)</dt>
      <dd></dd>

      <dt>readonly attribute <a>RTCRtpSender</a> sender</dt>
      <dd><p>The <a>RTCRtpSender</a> instance</p></dd>

      <dt>attribute EventHandler ontonechange</dt>
        <dd>
          <p>The <dfn>ontonechange</dfn> event handler uses the
          <a>RTCDTMFToneChangeEvent</a> interface to return the
          character for each tone as it is played out. 
          </p>
        </dd>

      <dt>readonly attribute DOMString toneBuffer</dt>
         <dd>
          <p>The <dfn>toneBuffer</dfn> attribute returns a list of the 
          tones remaining to be played out.</p>
        </dd> 

        <dt>readonly attribute long duration</dt>

        <dd>
          <p>The <dfn>duration</dfn> attribute returns the current tone duration
          value in milliseconds.  This value will be the value last set via the 
          <a>insertDTMF()</a> method, or the default value of 70 ms if
          <a>insertDTMF()</a> was called without specifying the duration.</p>
        </dd>

        <dt>readonly attribute long interToneGap</dt>

        <dd>
          <p>The <dfn>interToneGap</dfn> attribute returns the current value of
          the between-tone gap.  This value will be the value last set via the
          <a>insertDTMF()</a> method, or the default value of 70
          ms if <a>insertDTMF()</a> was called without specifying
          the interToneGap.</p>
        </dd>

    </dl>

    </section>

    <section>
      <h3>RTCDTMFToneChangeEvent</h3>

      <p>The tonechange event uses the
      <a>RTCDTMFToneChangeEvent</a> interface.</p>

      <p> Firing an tonechange event named
      <var>e</var> with a DOMString <var>tone</var> means
      that an event with the name <var>e</var>, which does not bubble (except
      where otherwise stated) and is not cancelable (except where otherwise
      stated), and which uses the <a>RTCDTMFToneChangeEvent</a>
      interface with the <a>tone</a>
      attribute set to
      <var>tone</var>, MUST be created and dispatched at the given target.</p>

      <dl class="idl" data-merge="RTCDTMFToneChangeEventInit" title=
      "interface RTCDTMFToneChangeEvent : Event">
        <dt>Constructor(DOMString type, RTCDTMFToneChangeEventInit
        eventInitDict)</dt>
        <dd></dd>
        <dt>readonly attribute DOMString tone</dt>
        <dd>
          <p>The <dfn>tone</dfn>
          attribute contains the character for the tone that has just begun
          playout (see <a>insertDTMF()</a>).  If the value is the
          empty string, it indicates that the previous tone has completed
          playback.</p>
        </dd>
      </dl>
      <dl class="idl" title=
      "dictionary RTCDTMFToneChangeEventInit : EventInit">
        <dt>DOMString tone</dt>
        <dd>
          <p>The <a>tone</a> parameter is treated as a series of characters. 
          The characters 0 through 9, A through D, #, and * generate the associated DTMF tones. 
          The characters a to d are equivalent to A to D. 
          The character ',' indicates a delay of 2 seconds before processing the next character in the tones parameter. 
          Unrecognized characters are ignored.</p>
        </dd>
      </dl>
    </section>
</section>

<section id="rtcdatachannel*">
  <h2>The RTCDataChannel Object</h2>

  <section id="rtcdatachannel-overview*">
    <h3>Overview</h3>

    <p>
      This section needs reworking. An <dfn>RTCDataChannel</dfn> class instance allows sending data messages to/from the remote peer.
    </p>
  </section>

  <section id="rtcdatachannel-interface-definition*">
    <h3>Interface Definition</h3>

    <dl class="idl" title="[Constructor(RTCDtlsTransport transport, DOMString id, optional DOMString dataChannelType)] interface RTCDataChannel : EventTarget">
      <dt>readonly attribute RTCDtlsTransport           transport</dt>
      <dd>The readonly value referring to the related transport object.</dd>
      <dt>readonly attribute DOMString     id</dt>
      <dd>An identifier for the data channel.</dd>
      <dt>readonly attribute DOMString     type</dt>
      <dd>The type of data channel being used.</dd>

      <dt>void send(Object data)</dt>
      <dd>
        <p>Method used for sending data to the remote peer.</p>

        <table border="1">
          <tr>
            <td><em>Parameter</em></td>
            <td><em>Type</em></td>
            <td><em>Nullable</em></td>
            <td><em>Optional</em></td>
            <td><em>Description</em></td>
          </tr>
          <tr>
            <td>data</td>
            <td><a>Object</a></td>
            <td>no</td>
            <td>no</td>
            <td></td>
          </tr>
        </table>
      </dd>

      <dt>attribute EventHandler          ondata</dt>
      <dd>
        <p>This event handler, of event handler event type <a>data</a>, must be fired to allow a developer's JavaScript to receive data from a remote peer.</p>

        <table border="1">
          <tr>
            <td><em>Event Argument</em></td>
            <td><em>Description</em></td>
          </tr>
          <tr>
            <td>Object data</td>
            <td>The received remote data.</td>
          </tr>
        </table>
      </dd>
    </dl>

  </section> 
</section>

</section>

<section id="sctp-transport*">
  <h2>The RTCSctpTransport Object</h2>

    <p>
      The <dfn>RTCSctpTransport</dfn> includes information relating to Stream Control Transmission Protocol (SCTP) transport. 
    </p>

  <section id="sctp-transport-overview*">
    <h3>Overview</h3>

    <p>An <a>RTCSctpTransport</a> is associated to a <a>RTCDataChannel</a>.</p>
  </section>

  <section id="sctptransport-operation*">
    <h3>Operation</h3>

    <p>An <a>RTCSctpTransport</a> instance is constructed from an <a>RTCDtlsTransport</a> object.</p>
  </section>

  <section id="sctptransport-interface-definition*">
    <h3>Interface Definition</h3>

    <dl class="idl" title="[Constructor(RTCDtlsTransport)] interface RTCSctpTransport">
      <dt>attribute <a>RTCDtlsTransport</a>                    transport</dt>
      <dd>The RTCDtlsTransport instance the RTCSctpTransport object is sending over.</dd>
      <dt>static <a>RTCSctpCapabilities</a> getCapabilities()</dt>
      <dd>Retrieves the RTCSctpCapabilities of the RTCSctpTransport instance.</dd>

      <dt>void start(<a>RTCSctpCapabilities</a> remoteCaps)</dt>
      <dd></dd>

      <dt>void stop()</dt>
      <dd>Stops the RTCSctpTransport instance.</dd>

      <dt><a>DataChannel</a> createDataChannel(<a>RTCDataChannelParameters</a> parameters)</dt>
      <dd>Creates a data channel running over SCTP transport.</dd>

    <dt>attribute EventHandler       ondatachannel</dt><dd></dd>

    </dl>

<section id="rtcdatachannelparameters*">
    <h3>dictionary RTCDataChannelParameters</h3>
    <dl class="idl" title="dictionary RTCDataChannelParameters">
      <dt>boolean                 outOfOrderAllowed</dt>
         <dd></dd>
      <dt>unsigned short          maxRetransmitTime</dt>
         <dd></dd>
      <dt>unsigned short          maxRetransmitNum</dt>
         <dd></dd>
      <dt>DOMString               protocol</dt>
          <dd></dd>
      <dt>boolean                 preset</dt>
          <dd></dd>
      <dt>unsigned short          stream</dt>
          <dd></dd>
    </dl>
</section>

  <section id="rtcsctpcapabilities*">
    <h3>dictionary RTCSctpCapabilities</h3>
    <dl class="idl" title="dictionary RTCSctpCapabilities">
      <dt>unsigned int                 maxMessageSize</dt><dd></dd>
    </dl>
</section>
</section>

  <section id=rtcsctpexample*">
    <h2>Example</h2>

<pre class="example"><code>
function initiate(signaller) {
  var dtls = ...;  // See ICE/DTLS example.
  var sctp = new RTCSctpTransport(dtls);

  signaller.sendInitiate({
    // ... include ICE/DTLS info from other example.
  sctpCapabilities: RTCSctpTransport.getCapabilities()
  }, function(remote) {
    sctp.start(remote.sctpCapabilities);
  });

  var channel = sctp.createDataChannel({...});
  channel.send("foo");
}

function accept(signaller, remote) {
  var dtls = ...;  // See ICE/DTLS example.
  signaller.sendAccept({
    // ... include ICE/DTLS info from other example.
    "sctpCapabilities": RTCSctpTransport.getCapabilities()
  });

  var sctp = new RTCSctpTransport(dtls);
  sctp.start(remote.sctpCapabilties);

  // Assume in-band signalling.  We could also easily add
  // RTCDataChannelParameters into the out-of-band signalling
  // And call .createDataChannel here with negotiated: true.

  sctp.ondatachannel = function(channel) {
    channel.onmessage = function(message) {
    if (message == "foo") {
      channel.send("bar");
    }
  }
}
</code></pre>

</section>
</section>
<section id="rtcp-protocol*">
  <h2>RTCP Protocol</h2>

  <p>This specification determines that RTCP packets must be multiplexed with the RTP packets as defined by [[!RFC5761]].</p>
</section>

<section id="examples*">
  <h2>Examples</h2>

  <section id="simple-peer-to-peer-example*">
    <h3>Simple Peer-to-peer Example</h3>

    <p>This example code provides a basic audio and video session between two browsers.</p>

<pre class="example"><code>
</code></pre>

  </section>
</section>

  <section id="change-log*">
    <h2>Change Log</h2>

    <p>This section will be removed before publication.</p>
    <!-- Why do the first two headings automatically convert to <h2>? -->

  <section id="since-07-November-2013*">
    <h3>Changes since 07 November 2013</h3>

    <ol>

      <li> RTCTrack split into RTCRtpSender and RTCRtpReceiver objects, as proposed on 
           <a href="http://lists.w3.org/Archives/Public/public-orca/2014Jan/0000.html"> 06 January 2014.</a></li>
      <li> RTCConnection split into RTCIceTransport and RTCDtlsTransport objects, as proposed on 
           <a href="http://lists.w3.org/Archives/Public/public-orca/2014Jan/0005.html"> 09 January 2014. </a></li>
      <li> RTCSctpTransport object added, as described in 
           <a href="https://github.com/openpeer/ortc/issues/25">Issue 25</a></li>
      <li> RTCRtpHeaderExtensionParameters added, as described in 
           <a href="https://github.com/openpeer/ortc/issues/28">Issue 28</a></li>
      <li> RTCIceListener added, in order to support parallel forking, as described in
           <a href="https://github.com/openpeer/ortc/issues/29">Issue 29</a></li>
      <li> DTMF support added, as described in
           <a href="https://github.com/openpeer/ortc/issues/30">Issue 30</a></li>
    </ol>
   </section>
  </section>
</body>
</html>
