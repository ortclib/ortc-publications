<!DOCTYPE html>
<html lang="en" dir="ltr" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Object RTC (ORTC) API for WebRTC</title>
    <meta charset='utf-8'>
  
  <script src="http://www.w3.org/Tools/respec/respec-w3c-common"
          async class="remove"></script>
  <script class="remove">
var respecConfig = {
    "specStatus": "CG-DRAFT",
    "shortName":  "ortc-api",
    "publishDate": "2014-04-29",
    "editors": [
        {   "name":       "Robin Raymond",
            "url":        "http://about.me/robinraymond",
            "company":    "Hookflash",
            "companyURL": "http://www.hookflash.com/" }
    ],
    "authors": [
        {   "name":       "Inaki Baz Castillo",
            "url":        "",
            "company":    "Versatica",
            "companyURL": "http://versatica.com/" },
        {   "name":       "Jose Luis Millan",
            "url":        "",
            "company":    "Versatica",
            "companyURL": "http://versatica.com/" },
        {   "name":       "Christoph Dorn",
            "url":        "http://christophdorn.com/",
            "company":    "Hookflash",
            "companyURL": "http://www.hookflash.com/" },
        {   "name":       "Roman Shpount",
            "url":        "", 
            "company":    "TurboBridge",
            "companyURL": "http://turbobridge.com/" },
        {   "name":       "Erik Lagerway",
            "url":        "http://about.me/elagerway",
            "company":    "Hookflash",
            "companyURL": "http://www.hookflash.com/" }
    ],
    "wg":           "Object-RTC API Community Group",
    "wgURI":        "http://www.w3.org/community/ortc/",
    "wgPublicList": "public-ortc",
    "wgPatentURI":  "",
    "localBiblio":  {
    "RFC4585": {
        title:    "Extended RTP Profile for RTCP-Based Feedback (RTP/AVPF)"
    ,   href:     "http://tools.ietf.org/html/rfc4585"
    ,   authors:  [
            "J. Ott"
        ,   "S. Wenger"
        ,   "N. Sato"
        ,   "C. Burmeister"
        ,   "J. Rey"
        ]
    ,   status:   "July 2006. RFC"
    ,   publisher:  "IETF"
    },
    "RFC4733": {
        title:    "RTP Payload for DTMF Digits, Telephony Tones, and Telephony Signals"
    ,   href:     "http://tools.ietf.org/html/rfc4733"
    ,   authors:  [
            "H. Schulzrinne"
        ,   "T. Taylor"
        ]
    ,   status:   "December 2006. RFC"
    ,   publisher:  "IETF"
    },
    "RFC5285": {
        title:    "A General Mechanism for RTP Header Extensions"
    ,   href:     "http://tools.ietf.org/html/rfc5285"
    ,   authors:  [
            "D. Singer"
        ,   "H. Desineni"
        ]
    ,   status:   "July 2008. RFC"
    ,   publisher:  "IETF"
    },
    "RFC5583": {
        title:    "Signaling Media Decoding Dependency in the SDP"
    ,   href:     "http://tools.ietf.org/html/rfc5583"
    ,   authors:  [
            "T. Schierl"
        ,   "S. Wenger"
        ]
    ,   status:   "July 2009. RFC"
    ,   publisher:  "IETF"
    },
    "RFC5761": {
        title:    "Multiplexing RTP Data and Control Packets on a Single Port"
    ,   href:     "http://tools.ietf.org/html/rfc5761"
    ,   authors:  [
            "C. Perkins"
        ,   "M. Westerlund"
        ]
    ,   status:   "April 2010. RFC"
    ,   publisher:  "IETF"
    },
    "RFC6190": {
        title:    "RTP Payload Format for Scalable Video Coding"
    ,   href:     "http://tools.ietf.org/html/rfc6190"
    ,   authors:  [
            "S. Wenger"
        ,   "Y.-K. Wang"
        ,   "T. Schierl"
        ,   "A. Eleftheriadis"
        ]
    ,   status:   "May 2011. RFC"
    ,   publisher:  "IETF"
    },
    "RFC6465": {
        title:    "A RTP Header Extension for Mixer-to-Client Audio Level Indication"
    ,   href:     "http://tools.ietf.org/html/rfc6465"
    ,   authors:  [
            "E. Ivov"
        ,   "E. Marocco"
        ,   "J. Lennox"
        ]
    ,   status:   "December 2011. RFC"
    ,   publisher:  "IETF"
    },
    "RFC6455": {
        title:    "The WebSocket Protocol"
    ,   href:     "http://tools.ietf.org/html/rfc6455"
    ,   authors:  [
            "I. Fette"
        ,   "A. Melnikov"
        ]
    ,   status:   "December 2011. RFC"
    ,   publisher:  "IETF"
    },
    "RFC6544": {
        title:    "TCP Candidates with Interactive Connectivity Establishment (ICE)"
    ,   href:     "http://tools.ietf.org/html/rfc6544"
    ,   authors:  [
            "J. Rosenberg"
        ,   "A. Keranen"
        ,   "B. B. Lowekamp"
        ,   "A. B. Roach"
        ]
    ,   status:   "March 2012. RFC"
    ,   publisher:  "IETF"
    },
    "RFC6716": {
        title:    "Definition of the Opus Audio Codec"
    ,   href:     "http://tools.ietf.org/html/rfc6716"
    ,   authors:  [
            "JM. Valin",
            "K. Vos",
            "T. Terriberry"
        ]
    ,   status:   "September 2012. RFC"
    ,   publisher:  "IETF"
    },
    "RFC6904": {
        title:    "Encryption of Header Extensions in the SRTP"
    ,   href:     "http://tools.ietf.org/html/rfc6904"
    ,   authors:  [
            "J. Lennox"
        ]
    ,   status:   "April 2013. RFC"
    ,   publisher:  "IETF"
    },
    "STUN-URI": {
        title:    "URI Scheme for Session Traversal Utilities for NAT (STUN) Protocol"
    ,   href:     "http://tools.ietf.org/html/draft-nandakumar-rtcweb-stun-uri"
    ,   authors:  [
            "S. Nandakumar",
            "G. Salgueiro",
            "P. Jones",
            "M. Petit-Huguenin"
        ]
    ,   status:   "12 March 2012. Internet Draft (work in progress)"
    ,   publisher:  "IETF"
    },
    "TURN-URI": {
        title:    "Traversal Using Relays around NAT (TURN) Uniform Resource Identifiers"
    ,   href:     "http://tools.ietf.org/html/draft-petithuguenin-behave-turn-uris"
    ,   authors:  [
            "M. Petit-Huguenin",
            "S. Nandakumar",
            "G. Salgueiro",
            "P. Jones"
        ]
    ,   status:   "12 March 2012. Internet Draft (work in progress)"
    ,   publisher:  "IETF"
    },
    "APPID": {
        title:    "The Session Description Protocol (SDP) Application Token Attribute"
    ,   href:     "http://tools.ietf.org/html/draft-even-mmusic-application-token" 
    ,   authors:  [
            "R. Even",
            "J. Lennox",
            "Q. Wu"
        ]
    ,   status:   "03 January 2014. Internet Draft (work in progress)"
    ,   publisher:  "IETF"
    },
    "DATA": {
        title:    "WebRTC Data Channels"
    ,   href:     "http://tools.ietf.org/html/draft-ietf-rtcweb-data-channel"
    ,   authors:  [
            "R. Jesup",
            "S. Loreto",
            "M. Tuexen"
        ]
    ,   status:   "09 April 2014. Internet Draft (work in progress)"
    ,   publisher:  "IETF"
    },
    "DATA-PROT": {
        title:    "WebRTC Data Channel Establishment Protocol"
    ,   href:     "http://tools.ietf.org/html/draft-ietf-rtcweb-data-protocol"
    ,   authors:  [
            "R. Jesup",
            "S. Loreto",
            "M. Tuexen"
        ]
    ,   status:   "09 April 2014. Internet Draft (work in progress)"
    ,   publisher:  "IETF"
    }
}
};
  </script>  
</head>
<body>

<section id="abstract">
<p>
This document defines a set of ECMAScript APIs in WebIDL to allow media to be sent and received
from another browser or device implementing the appropriate set of real-time protocols.  However,
unlike the current WebRTC 1.0 APIs, ORTC does not mandate a media signaling protocol or
format.  As a result, ORTC does not utilize Session Description Protocol (SDP) within its APIs, nor does it mandate support for
the Offer/Answer state machine. Instead, ORTC focuses on "connections" and "tracks" being
carried over those connections.
</p>
</section>

<section id='sotd'>
</section>

<section id="overview*">

  <h2><span class="secno"> </span>Overview</h2>

<p>Object RealTime Communications (ORTC) provides a powerful API for the development of WebRTC based applications. 
ORTC does not mandate a media signaling protocol or format (as the current WebRTC 1.0 does by mandating SDP Offer/Answer). 
Instead, ORTC focuses on "sender", "receiver" and "transport" objects, which have 
"capabilities" describing what they are capable of doing, 
as well as "parameters" which define what they are configured to do. 
"Tracks" and "data channels" are sent over the transports, between senders and receivers.</p>
<p>This specification defines several objects: RTCDtlsTransport (Section 2), RTCIceTransport (Section 3), 
RTCIceListener (Section 4), RTCRtpSender (Section 5), RTCRtpReceiver (Section 6), RTCRtpListener (Section 7),  
RTCDtmfSender (Section 9), RTCDataChannel
(Section 10), and RTCSctpTransport (Section 11). 
RTP dictionaries are described in Section 8,
and the Statistics API is described in Section 12.</p>
<p>  
In a Javascript application utilizing the ORTC API,  
the relationship between the application and the objects, as well 
as between the objects themselves is shown below. 
Horizontal or slanted arrows denote the flow of media or data, 
whereas vertical arrows denote interactions via methods and events. 
</p>

<img alt="The non-normative ORTC Big Picture Diagram" src="ortc-big-picture.png" style="width:80%" />

  <section>
    <h3>Terminology</h3>

    <p>The <code><a href=
    "http://dev.w3.org/html5/spec/webappapis.html#eventhandler">EventHandler</a></code>
    interface represents a callback used for event handlers as defined in
    [[!HTML5]].</p>

    <p>The concepts <dfn><a href=
    "http://dev.w3.org/html5/spec/webappapis.html#queue-a-task">queue a
    task</a></dfn> and <dfn><a href=
    "http://dev.w3.org/html5/spec/webappapis.html#fire-a-simple-event">fires a
    simple event</a></dfn> are defined in [[!HTML5]].</p>

    <p>The terms <dfn>event</dfn>, <dfn><a href=
    "http://dev.w3.org/html5/spec/webappapis.html#event-handlers">event
    handlers</a></dfn> and <dfn><a href=
    "http://dev.w3.org/html5/spec/webappapis.html#event-handler-event-type">event
    handler event types</a></dfn> are defined in [[!HTML5]].</p>

    <p>The terms <dfn>MediaStream</dfn>, <dfn>MediaStreamTrack</dfn>,
    <dfn>Constraints</dfn>, and <dfn>Consumer</dfn> are defined in
    [[!GETUSERMEDIA]].</p>

    <p>The terms single-session transmission (<dfn>SST</dfn>) and multi-session transmission (<dfn>MST</dfn>)
    are defined in [[!RFC6190]].  While this specification supports <a>SST</a> but not <a>MST</a>, 
    multiple streams may be utilized
    within a single RTP session.</p>

  </section>
  </section>
<section id="rtcdtlstransport*">
  <h2>The RTCDtlsTransport Object</h2>

    <p>
The <dfn>RTCDtlsTransport</dfn> includes information relating to Datagram Transport Layer Security (DTLS) transport. 
    </p>

  <section id="rtcdtlstransport-overview*">
    <h3>Overview</h3>

    <p>An <a>RTCDtlsTransport</a> instance is associated to an <a>RTCRtpSender</a> or an <a>RTCRtpReceiver</a>.</p>
  </section>

  <section id="rtcdtlstransport-operation*">
    <h3>Operation</h3>

    <p>A <a>RTCDtlsTransport</a> instance is optionally constructed from an <a>RTCIceTransport</a> 
       object or an <a>RTCDtlsTransport</a> is automatically constructed.</p>
  </section>

  <section id="rtcdtlstransport-interface-definition*">
    <h3>Interface Definition</h3>

    <dl class="idl" title="[Constructor(optional RTCIceTransport transport)] interface RTCDtlsTransport">
      <dt>attribute RTCIceTransport transport</dt>
      <dd><p>The associated <a>RTCIceTransport</a> instance.</p></dd>

      <dt>readonly attribute RTCDtlsTransportState state</dt>
      <dd><p>The current state of the DTLS transport.</p></dd>

      <dt>RTCDtlsParameters getLocalParameters()</dt>
      <dd><p>Obtain the DTLS parameters of the local <a>RTCDtlsTransport</a>.</p></dd>

      <dt>RTCDtlsParameters? getRemoteParameters()</dt>
      <dd><p>Obtain the current DTLS parameters of the remote <a>RTCDtlsTransport</a>.</p></dd>

      <dt>sequence&lt;ArrayBuffer> getRemoteCertificates()</dt>
      <dd><p>Obtain the certificates used by the remote peer.</p></dd>

      <dt>void start(RTCDtlsParameters remoteParameters)</dt>
      <dd><p>Start DTLS transport negotiation with the parameters of the remote DTLS transport.</p></dd>

      <dt>void stop()</dt>
      <dd><p>Stops and closes the DTLS transport object.</p></dd>

      <dt>attribute EventHandler? onstatechange</dt>
      <dd><p>Set this handler to receive events when the state of the DTLS transport changes.</p></dd>

      <dt>attribute EventHandler? onerror</dt>
      <dd><p>Set this handler to receive error events.</p></dd>
    </dl>
  </section>

  <section id="ondtlstransporterror-interface-definition*">
      <h3>Interface Definition</h3>

      <dl class="idl" title="interface onerror : Event">
        <dt>readonly attribute DOMError e</dt>
        <dd>
          <p>The <a>DOMError</a> object whose <a>name</a> attribute has the value TODO.</p>
        </dd>
      </dl>
  </section>

  <section id="ondtlstransportstatechangeevent-interface-definition*">
      <h3>Interface Definition</h3>

      <dl class="idl" title="interface onstatechange : Event">
        <dt>readonly attribute RTCDtlsTransportState  state</dt>
        <dd>
          <p>The <a>state</a> attribute contains the new <a>RTCDtlsTransportState</a> that caused the event.</p>
        </dd>
      </dl>
  </section>

  <section id="rtcdtlsparameters*">
   <h3>The RTCDtlsParameters Object</h3>

   <p>
     The <dfn>RTCDtlsParameters</dfn> object includes information relating to DTLS configuration.
   </p>

    <dl class="idl" title="dictionary RTCDtlsParameters">
      <dt>RTCDtlsRole role="auto"</dt>
      <dd><p>The DTLS role, with a default of auto.</p></dd>
      <dt>sequence&lt;RTCDtlsFingerprint> fingerprint</dt>
      <dd><p>Sequence of fingerprints.</p></dd>
    </dl>

  <section id=rtcdtlsfingerprint*">
   <h3>The RTCDtlsFingerprint Object</h3>

   <p>
     The <dfn>RTCDtlsFingerprint</dfn> object includes the hash function algorithm and certificate fingerprint as described in [[!RFC4572]].
   </p>

    <dl class="idl" title="dictionary RTCDtlsFingerprint">
      <dt>DOMString algorithm</dt>
      <dd><p>One of the the hash function algorithms defined in the 'Hash function Textual Names' registry, initially specified in [[!RFC4572]] Section 8.</p></dd>
      <dt>DOMString value</dt>
      <dd><p>The value of the certificate fingerprint in lowercase hex string as expressed utilizing the syntax of 'fingerprint' in [[!RFC4572]] Section 5.</p></dd>
    </dl>
  </section>
 </section>

  <section id="rtcdtlsrole*">
    <h3>enum RTCDtlsRole</h3>

    <dl class="idl" title="enum RTCDtlsRole">
      <dt>auto</dt>
      <dd><p>The DTLS role is be determined based on the resolved ICE role: the 
      'Controlled' role acts as the DTLS client, 
      the 'Controlling' role acts as the DTLS server.
      </p></dd>

      <dt>client</dt>
      <dd><p>The DTLS client role.</p></dd>

      <dt>server</dt>
      <dd><p>The DTLS server role.</p></dd>
    </dl>
  </section>

  <section id="rtcdtlstransport-example*">
    <h3>Example</h3>

    <pre class="example"><code class="javascript">
    </code></pre>
  </section>

  <section id="rtcdtlstransportstate*">
    <h3>enum RTCDtlsTransportState</h3>
    <p><dfn>RTCDtlsTransportState</dfn> provides information about the state of the DTLS transport. 
    </p>
    <dl class="idl" title="enum RTCDtlsTransportState">
      <dt>new</dt>
      <dd><p>new state</p></dd>

      <dt>connecting</dt>
      <dd><p>connecting state</p></dd>

      <dt>connected</dt>
      <dd><p>connected state.  Implies that all DTLS processing needed by upper layers (including DTLS/SRTP) has finished.
</p></dd>

      <dt>closed</dt>
      <dd><p>closed state</p></dd>
    </dl>
  </section>

</section>

<section id="rtcicetransport*">
  <h2>The RTCIceTransport Object</h2>

    <p>
      The <dfn>RTCIceTransport</dfn> includes information relating to Interactive Connectivity Establishment (ICE).
    </p>

  <section id="rtcicetransport-overview*">
    <h3>Overview</h3>

    <p>An <a>RTCIceTransport</a> instance is associated to a transport object (such as <a>RTCDtlsTransport</a>), 
       and provides RTC related methods to it.</p>
  </section>

  <section id="rtcicetransport-operation*">
    <h3>Operation</h3>

    <p>An <a>RTCIceTransport</a> instance is constructed from an <a>RTCIceRole</a>  
       and either an <a>RTCIceListener</a>  
       or an <a>RTCIceOptions</a> object.</p>
  </section>

  <section id="rtcicetransport-interface-definition*">
    <h3>Interface Definition</h3>

    <dl class="idl" title="[Constructor(optional RTCIceListener iceListener), 
     Constructor(RTCIceOptions options)] interface RTCIceTransport">
      <dt>readonly attribute RTCIceListener iceListener</dt>
      <dd><p>
     The <a>RTCIceListener</a> specified in the <a>RTCIceTransport</a> constructor. 
     If none was specified, the system will create an <a>RTCIceListener</a> automatically using the <a>RTCIceOptions</a> specified.  
      </p></dd>
      <dt>readonly attribute RTCIceRole role</dt>
      <dd><p><dfn>RTCIceRole</dfn> contains the current role of the ICE transport.</p></dd>
      <dt>readonly attribute RTCIceTransportState state</dt>
      <dd><p>The current state of the ICE transport.</p></dd>
      <dt>readonly attribute RTCIceGatheringState iceGatheringState</dt>
      <dd><p>The current state of ICE candidate gathering.</p></dd> 
      <dt>sequence&lt;RTCIceCandidate>  getLocalCandidates()</dt>
      <dd><p>Retrieve the sequence of valid candidates associated with the local <a>RTCIceTransport</a>.
      This retrieves all candidates currently known, even if an onlocalcandidate event hasn't been processed yet.</p></dd>

      <dt>sequence&lt;RTCIceCandidate> getRemoteCandidates()</dt>
      <dd><p>Retrieve the sequence of candidates associated with the remote <a>RTCIceTransport</a>.</p></dd>

      <dt>void gather(RTCIceGatherPolicy gatherPolicy)</dt>
      <dd><p>Start gathering <a>RTCIceCandidate</a> objects, based on the gather policy 
      (set on the local system, not negotiated).</p></dd>

      <dt>void start(RTCIceParameters remoteParameters, optional RTCIceRole role)</dt>
      <dd><p>Starts candidate connectivity checks and attempts to connect to the remote <a>RTCIceTransport</a>.</p></dd>

      <dt>void stop()</dt>
      <dd><p>Stops and closes the current object.</p></dd>

      <dt>RTCIceParameters getLocalParameters()</dt>
      <dd><p>Obtain the ICE parameters of the local <a>RTCIceTransport</a>.</p></dd>

      <dt>RTCIceParameters? getRemoteParameters()</dt>
      <dd><p>Obtain the current ICE parameters of the remote <a>RTCIceTransport</a>.</p></dd>

      <dt>void addRemoteCandidate(RTCIceCandidate remoteCandidate)</dt>
      <dd><p>Add remote candidate associated with remote <a>RTCIceTransport</a>.</p></dd>

      <dt>void setRemoteCandidates(sequence&lt;RTCIceCandidate> remoteCandidates)</dt>
      <dd><p>Set the sequence of candidates associated with the remote <a>RTCIceTransport</a>.</p></dd>

      <dt>attribute EventHandler? onlocalcandidate</dt>
      <dd><p>Set this handler to receive events when a new local candidate is available.</p></dd>

      <dt>attribute EventHandler? onstatechange</dt>
      <dd><p>Set this handler to receive events when the state of the <a>RTCIceTransport</a> has changed.</p></dd>

      <dt>attribute EventHandler? ongatheringstatechange</dt>
      <dd><p>Set this handler to receive an event when ICE gather state changes.</p></dd>

      <dt>attribute EventHandler? onerror</dt>
      <dd><p>Set this handler to receive error events (such as failure of ICE candidate gathering).</p></dd>

    </dl>
  </section>

  <section id="rtcicegatheringstate*">
    <h3>enum RTCIceGatheringState</h3>

    <dl class="idl" title="enum RTCIceGatheringState">
      <dt>new</dt>
      <dd><p>No networking has occurred yet.</p></dd>

      <dt>gathering</dt>
      <dd><p>The ICE engine is in the process of gathering candidates.</p></dd>

      <dt>complete</dt>
      <dd><p>The ICE engine has completed gathering and is currently idle. 
      Events such as adding a new interface or a new TURN server will cause the state to go back to gathering.</p></dd>
    </dl>
  </section>

  <section id="onlocalcandidateevent-interface-definition*">
      <h3>Interface Definition</h3>

      <dl class="idl" title="interface onlocalcandidate : Event">
        <dt>readonly attribute RTCIceCandidate? candidate</dt>
        <dd>
          <p>The <a>candidate</a> attribute is the <a>RTCIceCandidate</a> object with the 
             new local ICE candidate that caused the event.  If <a>candidate</a> is null,  
             there are no additional candidates for now.</p>
        </dd>
      </dl>
  </section>

  <section id="onicetransportstatechangeevent-interface-definition*">
      <h3>Interface Definition</h3>

      <dl class="idl" title="interface onstatechange : Event">
        <dt>readonly attribute RTCIceTransportState state</dt>
        <dd>
          <p>The <a>state</a> attribute contains the new <a>RTCIceTransportState</a> causing the event.</p>
        </dd>
      </dl>
  </section>

  <section id="ongatheringstatechangeevent-interface-definition*">
      <h3>Interface Definition</h3>

      <dl class="idl" title="interface ongatheringstatechange : Event">
        <dt>readonly attribute RTCIceGatherState state</dt>
        <dd>
          <p>The state attribute contains the new RTCIceGatheringState that caused the event.</p>
        </dd>
      </dl>
  </section>

  <section id="onerroriceevent-interface-definition*">
      <h3>Interface Definition</h3>

      <dl class="idl" title="interface onerror : Event">
        <dt>readonly attribute DOMError e</dt>
        <dd>
          <p>The <a>DOMError</a> object whose <a>name</a> attribute has the value TODO.</p>
        </dd>
      </dl>
  </section>

  <section id="rtciceparameters*">
   <h3>The RTCIceParameters Object</h3>

   <p>
     The <dfn>RTCIceParameters</dfn> object includes the ICE username and password.
   </p>

    <dl class="idl" title="dictionary RTCIceParameters">
      <dt>DOMString usernameFragment</dt>
      <dd><p>ICE username.</p></dd>
      <dt>DOMString password</dt>
      <dd><p>ICE password.</p></dd>
    </dl>
  </section>

  <section id="rtcicetransport-example1*">
    <h3>Examples</h3>

    <pre class="example"><code class="javascript">

// Assume we already have a way to signal. This is an example
// of  how to offer ICE and DTLS parameters and ICE candidates and
// get back ICE and DTLS parameters and ICE candidates, and start
// both ICE and DTLS.

function initiate(signaller) {
 var iceOptions = ...;
 var ice = new RTCIceTransport(RTCIceRole.controlling, iceOptions);
 var dtls = new RTCDtlsTransport(ice);
 // ... get tracks and RTP objects from other example

 signaller.sendInitiate({
   "ice": ice.
getLocalParameters(),
   "dtls": dtls.
getLocalParameters(),
   // ... include RTP info from other example
 }, function(remote) {
   ice.setRemoteParameters(remote.ice);
   dtls.start(remote.dtls);
   // ... start RTP senders and receivers from other example
 });

 ice.oncandidate = function(candidate) {
   signaller.sendLocalCandidate(candidate);
 }

 signaller.onRemoteCandidate = function(candidate) {
   ice.addRemoteCandidate(candidate);
 }

 ice.start();
}

    </code></pre>

    <pre class="example"><code class="javascript">

// Assume we already have a way to signal and remote info is 
// signalled to us.  This is an example of how to answer with ICE and DTLS
// and DTLS parameters and ICE candidates and start both ICE and DTLS.
//
function accept(signaller, remote) {
 var iceOptions = ...;
 var ice = new RTCIceTransport(RTCIceRole.controlled,iceOptions);
 var dtls = new RTCDtlsTransport(ice);
 // ... get tracks and RTP objects from other example
 ice.onlocalcandidate = function(candidate) {
   signaller.sendLocalCandidate(candidate);
 }

 signaller.onRemoteCandidate = function(candidate) {
   ice.addRemoteCandidate(candidate);
 }

 signaller.sendAccept({
   "ice": ice.
getLocalParameters(),
   "dtls": ice.
getLocalParameters()
   // ... include RTP info from other example
 });

 ice.start(remote.ice);
 dtls.start(remote.dtls);

 // ... start RTP senders and receivers from other example
}

    </code></pre>
  </section>

  <section id="rtcicerole*">
    <h3>enum RTCIceRole</h3>

    <dl class="idl" title="enum RTCIceRole">
      <dt>controlling</dt>
      <dd><p>controlling state</p></dd>

      <dt>controlled</dt>
      <dd><p>controlled state</p></dd>
    </dl>
  </section>

  <section id="rtcicegatherpolicy*">
    <h3>enum RTCIceGatherPolicy</h3>

    <dl class="idl" title="enum RTCIceGatherPolicy">
      <dt>all</dt>
      <dd><p>Gather all ICE candidate types.</p></dd>
      <dt>nohost</dt>
      <dd><p>Gather all ICE candidate types except for host candidates.</p></dd>
      <dt>relayonly</dt>
      <dd><p>Only gather media relay candidates such as candidates passing through a TURN server.  
      This can be used to reduce leakage of IP addresses in certain use cases.</p></dd>
    </dl>
  </section>

  <section id="rtcicetransportstate*">
    <h3>enum RTCIceTransportState</h3>

    <dl class="idl" title="enum RTCIceTransportState">
      <dt>new</dt>
      <dd><p>new state</p></dd>

      <dt>checking</dt>
      <dd><p>checking state</p></dd>

      <dt>connected</dt>
      <dd><p>connected state</p></dd>

      <dt>completed</dt>
      <dd><p>completed state</p></dd>

      <dt>disconnected</dt>
      <dd><p>disconnected state</p></dd>

      <dt>closed</dt>
      <dd><p>closed state</p></dd>
    </dl>

<p>The non-normative ICE state transitions are:</p>

<img alt="The non-normative ICE State Transition Diagram" src="icestates.png" style="width:50%" />
</section>

  <section id="rtciceoptions*">
   <h3>The RTCIceOptions Object</h3>

   <p>
     The <dfn>RTCIceOptions</dfn> object includes information relating to ICE configuration.
   </p>

    <dl class="idl" title="dictionary RTCIceOptions">
      <dt>sequence&lt;RTCIceServer>? iceServers</dt>
      <dd><p>An array containing STUN and TURN servers available to be used by ICE.</p></dd>
    </dl>

  </section>

  <section id="rtciceserver*">
   <h3>The RTCIceServer Object</h3>

   <p>
    The <dfn>RTCIceServer</dfn> is used to provide STUN or TURN server configuration. 
    In network topologies with multiple layers of NATs, it is desirable to have a STUN server 
    between every layer of NATs in addition to the TURN servers to minimize the peer to peer network latency.
   <p>

   </p>
     An example of an array of RTCIceServer objects:
   </p>

    <pre class="example"><code class="javascript">
      [ { urls: "stun:stun1.example.net } , { urls:"turn:turn.example.org", username: "user", credential:"myPassword"} ]
    </code></pre>

    <dl class="idl" title="dictionary RTCIceServer">
      <dt>(DOMString or sequence&lt;DOMString>) urls</dt>
      <dd><p>STUN or TURN URI(s) as defined in [[!STUN-URI]] and [[!TURN-URI]]</p></dd>
      <dt>DOMString? username</dt>
      <dd><p>If this RTCIceServer object represents a TURN server, then this attribute specifies 
          the username to use with that TURN server.</p></dd>
      <dt>DOMString? credential</dt>
      <dd><p>If the uri element is a TURN URI, then this is the credential to use with that TURN server.</p></dd>
    </dl>

  </section>


  <section id="rtcicecandidate*">
    <h3>The RTCIceCandidate Object</h3>

    <p>
      The <dfn>RTCIceCandidate</dfn> object includes information relating to an ICE candidate.
    </p>

    <pre class="example"><code class="javascript">{
  foundation: "abcd1234",
  priority: 1694498815,
  ip: "192.0.2.33",
  protocol: "udp",
  port: 10000,
  type: "host"
};
    </code></pre>

    <dl class="idl" title="dictionary RTCIceCandidate">
      <dt>DOMString foundation</dt>
      <dd>
        <p>A unique identifier that allows ICE to correlate candidates that appear on multiple <a>RTCIceTransport</a>s.</p>
      </dd>
      <dt>unsigned long priority</dt>
      <dd><p>The assigned priority of the candidate.  This is automatically populated by the browser.</p></dd>
      <dt>DOMString ip</dt>
      <dd><p>The IP address of the candidate.</p></dd>
      <dt>RTCIceProtocol protocol</dt>
      <dd><p>The protocol of the candidate (UDP/TCP).</p></dd>
      <dt>unsigned short port</dt>
      <dd><p>The port for the candidate.</p></dd>
      <dt>RTCIceCandidateType type</dt>
      <dd><p>The type of candidate.</p></dd>
      <dt>RTCIceTcpCandidateType? tcpType=null</dt>
      <dd><p>The type of TCP candidate.</p></dd>
      <dt>DOMString? relatedAddress=""</dt>
      <dd>
        <p>For candidates that are derived from others, such as relay or reflexive candidates, the <dfn>relatedAddress</dfn>
        refers to the host candidate that these are derived from.  For host candidates, the <a>relatedAddress</a>
        is set to the empty string.</p>
      </dd>
      <dt>unsigned short? relatedPort=null</dt>
      <dd>
        <p>For candidates that are derived from others, such as relay or reflexive candidates, the <dfn>relatedPort</dfn>
        refers to the host candidate that these are derived from.  For host candidates, the <a>relatedPort</a>
        is null.</p> 
      </dd>
    </dl>

    <section>
      <h4>The RTCIceProtocol</h4>
      <p>
        The <dfn>RTCIceProtocol</dfn> includes the protocol of the ICE candidate.
      </p>
      <dl class="idl" title="enum RTCIceProtocol">
        <dt>udp</dt>
        <dd><p>A UDP candidate, as described in [[!RFC5245]].</p></dd> 
        <dt>tcp</dt>
        <dd><p>A TCP candidate, as described in [[!RFC6544]].</p></dd>
      </dl>
    </section>

    <section>
      <h4>The RTCIceTcpCandidateType</h4>
      <p>
        The <dfn>RTCIceTcpCandidateType</dfn> includes the type of the ICE TCP candidate, as described in [[!RFC6544]].
      </p>
      <dl class="idl" title="enum RTCIceTcpCandidateType">
        <dt>active</dt>
        <dd><p>An active TCP candidate is one for which the agent will
   attempt to open an outbound connection but will not receive incoming
   connection requests.</p></dd>
        <dt>passive</dt>
        <dd><p>A passive TCP candidate is one for which the agent
   will receive incoming connection attempts but not attempt a
   connection.</p></dd>
        <dt>so</dt>
        <dd><p>An so candidate is one for which the agent will attempt
   to open a connection simultaneously with its peer.</p></dd>
      </dl>
    </section>

    <section>
      <h4>The RTCIceCandidateType</h4>
      <p>
        The <dfn>RTCIceCandidateType</dfn> includes the type of the ICE candidate.
      </p>
      <dl class="idl" title="enum RTCIceCandidateType">
        <dt>host</dt>
        <dd><p>A host candidate.</p></dd>
        <dt>srflx</dt>
        <dd><p>A server reflexive candidate.</p></dd>
        <dt>prflx</dt>
        <dd><p>A peer reflexive candidate.</p></dd>
        <dt>relay</dt>
        <dd><p>A relay candidate.</p></dd>
      </dl>
    </section>
  </section>
</section>

<section id="rtcicelistener*">
  <h2>The RTCIceListener Object</h2>

    <p>
      The <dfn>RTCIceListener</dfn> enables an endpoint to construct multiple <a>RTCIceTransport</a> 
      objects from a set of local ICE parameters, 
      enabling usage scenarios such as parallel forking.
    </p>

  <section id="rtcicelistener-overview*">
    <h3>Overview</h3>

    <p>An <a>RTCIceListener</a> instance is associated to an <a>RTCIceTransport</a>.</p>
  </section>

  <section id="rtcicelistener-operation*">
    <h3>Operation</h3>

    <p>An <a>RTCIceListener</a> instance is optionally constructed from an <a>RTCIceOptions</a> object,
       or an <a>RTCIceListener</a> is automatically constructed.</p>
  </section>

  <section id="rtcicelistener-interface-definition*">
    <h3>Interface Definition</h3>

    <dl class="idl" title="[Constructor(optional RTCIceOptions options)] interface RTCIceListener">
      <dt>attribute <a>RTCIceOptions</a>                    options</dt>
      <dd>
        <p>The <a>RTCIceOptions</a> instance.</p>
      </dd>
    </dl>
  </section>

  <section id="rtcicelistener-example*">
    <h3>Example</h3>
    <pre class="example"><code class="javascript">

var iceOptions = ...;
var iceListener = new RTCIceListener(iceOptions);
var iceBase = new RTCIceTransport(RTCIceRole.controlling,iceOptions);
sendInitiate(iceBase.getLocalParameters(), function(response) {
  // We may get N responses
  var ice = new RTCIceTransport(RTCIceRole.controlling, iceListener);
  var ice.setRemoteParameters(response.iceParameters);
  ice.start();
  // ... setup DTLS, RTP, SCTP, etc.
});

iceBase.onlocalcandidate = sendLocalCandidate;
iceListener.start();

    </code></pre>

  </section>
</section>

<section id="rtcrtpsender*">
  <h2>The RTCRtpSender Object</h2>

    <p>
      The <dfn>RTCRtpSender</dfn> includes information relating to the RTP sender.
    </p>

  <section id="rtcrtpsender-overview*">
    <h3>Overview</h3>

    <p>An <a>RTCRtpSender</a> instance is associated to a sending <a>MediaStreamTrack</a> and provides RTC related methods to it.</p>
  </section>

  <section id="rtcrtpsender-operation*">
    <h3>Operation</h3>

    <p>A <a>RTCRtpSender</a> instance is constructed from an <a>MediaStreamTrack</a> object and associated to an <a>RTCDtlsTransport</a>.</p>
  </section>

  <section id="rtcrtpsender-interface-definition*">
    <h3>Interface Definition</h3>

    <dl class="idl" title="[Constructor(MediaStreamTrack track, RTCDtlsTransport transport)] interface RTCRtpSender">
      <dt>attribute <a>MediaStreamTrack</a>                    track</dt>
      <dd>
        <p>The associated <a>MediaStreamTrack</a> instance.</p>
      </dd>
      
      <dt>attribute <a>RTCDtlsTransport</a>                    transport</dt>
      <dd>
        <p>The associated <a>RTCDtlsTransport</a> instance.</p>
      </dd>

      <dt>static <a>RTCRtpCapabilities</a> getCapabilities()</dt>
      <dd><p>Obtain the capabilities of the <a>RTCRtpSender</a>.</p></dd>

      <dt>static <a>RTCRtpParameters</a> createParameters(<a>MediaStreamTrack</a> track, optional <a>RTCRtpCapabilities</a> capabilities)</dt>
      <dd><p>Create parameters based on the <a>MediaStreamTrack</a> and the capabilities specified in <a>RTCRtpCapabilities</a>.</p></dd>

      <dt>static <a>RTCRtpParameters</a> filterParameters(<a>RTCRtpParameters</a> parameters, optional <a>RTCRtpCapabilities</a> capabilities)</dt>
      <dd><p>Filter parameters based on the <a>RTCRtpCapabilities</a>.</p></dd>

      <dt>void send(<a>RTCRtpParameters</a> parameters)</dt>
      <dd><p>Media is controlled by the given "parameters".  The sender starts sending when send() 
is called and stops sending when stop() is called.</p></dd>

      <dt>void stop()</dt>
      <dd><p>Stops sending the track on the wire.  Stop is final like <a>MediaStreamTrack</a></p></dd>

    </dl>
  </section>

  <section id="rtcrtpsender-example*">
    <h3>Example</h3>

    <pre class="example"><code class="javascript">
    </code></pre>
  </section>

</section>

<section id="rtcrtpreceiver*">
  <h2>The RTCRtpReceiver Object</h2>

    <p>
      The <dfn>RTCRtpReceiver</dfn> includes information relating to the RTP receiver. 
    </p>

  <section id="rtcrtpreceiver-overview*">
    <h3>Overview</h3>

    <p>An <a>RTCRtpReceiver</a> instance is associated to a receiving <a>MediaStreamTrack</a> and provides RTC related methods to it.</p>
  </section>

  <section id="rtcrtpreceiver-operation*">
    <h3>Operation</h3>

    <p>A <a>RTCRtpReceiver</a> instance is constructed from an <a>RTCDtlsTransport</a> object.</p>
  </section>

  <section id="rtcrtpreceiver-interface-definition*">
    <h3>Interface Definition</h3>

    <dl class="idl" title="[Constructor(RTCDtlsTransport transport)] interface RTCRtpReceiver">
      <dt>readonly attribute <a>MediaStreamTrack</a>? track</dt>
      <dd>
        <p>The associated <a>MediaStreamTrack</a> instance.</p>
      </dd>
      
      <dt>attribute <a>RTCDtlsTransport</a> transport</dt>
      <dd>
        <p>The associated <a>RTCDtlsTransport</a> instance.</p>
      </dd>

      <dt>static <a>RTCRtpCapabilities</a> getCapabilities()</dt>
      <dd><p>Obtain the capabilities of the <a>RTCRtpReceiver</a>.</p></dd>

      <dt>static <a>RTCRtpParameters</a> createParameters (DOMString kind, optional RTCRtpCapabilities capabilities)</dt>
      <dd>
        Create parameters based on the kind and the capabilities specified in <a>RTCRtpCapabilities</a>.
        <dl class='parameters'>
            <dt>DOMString kind</dt>
            <dd>
              Specifies kind, either "audio" or "video".
            </dd>
            <dt>optional RTCRtpCapabilities capabilities</dt>
            <dd></dd>
          </dl>
      </dd>

      <dt>static <a>RTCRtpParameters</a> filterParameters(<a>RTCRtpParameters</a> parameters, optional <a>RTCRtpCapabilities</a> capabilities)</dt>
      <dd><p>Filter parameters based on the <a>RTCRtpCapabilities</a>.</p></dd>

      <dt>void receive(<a>RTCRtpParameters</a> parameters)</dt>
      <dd><p>Media is controlled by the given "parameters". The receiver starts receiving when the receive() is called and stopped when the stop() is called.</p></dd>

      <dt>void stop()</dt>
      <dd><p>Stops receiving the track on the wire. Stop is final like <a>MediaStreamTrack</a></p></dd>

    </dl>
  </section>

  <section id="rtcrtpreceiver-example*">
    <h3>Examples</h3>

    <pre class="example"><code class="javascript">
// Assume we already have a way to signal, a transport 
// (RTCDtlsTransport), and audio and video tracks. This is an example 
// of  how to offer them  and get back an answer with audio and 
// video tracks, and begin sending and receiving them.
function initiate(signaller, transport, audioTrack, videoTrack) {
  var audioSender = new RTCRtpSender(audioTrack, transport);
  var videoSender = new RTCRtpSender(videoTrack, transport);
  var audioReceiver = new RTCRtpReceiver(transport);
  var videoReceiver = new RTCRtpReceiver(transport);

  var sendAudioParams = RTCRtpSender.createParameters(audioTrack);
  var sendVideoParams = RTCRtpSender.createParameters(videoTrack);
  signaller.offerTracks({
    // The initiator offers parameters it wants to send with, 
    // and the capabilities it has for receiving. 
    "rtpCaps": RTCRtpReceiver.getCapabilities(),
    "audio": sendAudioParams,
    "video": sendVideoParams
  }, function(answer) {
    // The responder answers with parameters it wants to send with
    // and the capabilities it has for receiving. 
    var audioSendParams = RTCRtpSender.filterParameters(
       sendAudioParams, answer.rtpCaps);
    var videoSendParams = RTCRtpSender.filterParameters(
       sendVideoParams, answer.rtpCaps);
    var audioRecvParams = RTCRtpReceiver.filterParameters(
       answer.audio);
    var videoRecvParams = RTCRtpReceiver.filterParameters(
       answer.video);
      
    audioSender.send(audioSendParams);
    videoSender.send(videoSendParams)
    audioReceiver.receive(audioRecvParams);
    videoReceiver.receive(videoRecvParams);

    // Now we can render/play 
    // audioReceiver.track and videoReceiver.track.
  });
}
    </code></pre>
    <pre class="example"><code class="javascript">

// Assume we already have a way to signal, a transport 
// (RTCDtlsTransport), and audio and video tracks. This is an example 
// of how to answer an offer with audio and video tracks, and begin 
// sending and receiving them.
function accept(
  signaller, remote, transport, audioTrack, videoTrack) {
  var audioSender = new RTCRtpSender(audioTrack, transport);
  var videoSender = new RTCRtpSender(videoTrack, transport);
  var audioReceiver = new RTCRtpReceiver(transport);
  var videoReceiver = new RTCRtpReceiver(transport);

  var audioSendParams = RTCRtpSender.createParameters(
    audioTrack, remote.rtpCaps);
  var videoSendParams = RTCRtpSender.createParameters(
    videoTrack, remote.rtpCaps);
  var audioRecvParams = RTCRtpReceiver.filterParameters(
     remote.audio);
  var videoRecvParams = RTCRtpReceiver.filterParameters(
     remote.video);
  
  audioSender.send(audioSendParams);
  videoSender.send(videoSendParams)
  audioReceiver.receive(audioRecvParams);
  videoReceiver.receive(videoRecvParams);
 
  signaller.answerTracks({
    "rtpCaps": RTCRtpReceiver.getCapabilities(),
    "audio": audioSendParams,
    "video": videoSendParams
  });

  // Now we can render/play 
  // audioReceiver.track and videoReceiver.track.
}
    </code></pre>
  </section>

</section>

<section id="rtcrtplistener*">
  <h2>The RTCRtpListener Object</h2>

    <p>
      The <dfn>RTCRtpListener</dfn> listens to RTP packets received from the DTLS transport, and
      fires an event if it detects an RTP stream that is not configured to be processed by an
      existing <a>RTCRtpReceiver</a> object.  The amount of buffering to be provided for unhandled
      RTP streams is recommended to be strictly limited to protect against denial of service attacks.
    </p>

  <section id="rtcrtplistener-overview*">
    <h3>Overview</h3>

    <p>An <a>RTCRtpListener</a> instance is associated to an <a>RTCDtlsTransport</a>.</p>
  </section>

  <section id="rtcrtplistener-operation*">
    <h3>Operation</h3>

    <p>An <a>RTCRtpListener</a> instance is constructed from an <a>RTCDtlsTransport</a> object.</p>
   <p>To determine whether an RTP stream is configured to be processed by an existing <a>RTCRtpReceiver</a> object, 
   the <a>RTCRtpListener</a> attempts to match the values of an incoming RTP packet's
   Payload Type and SSRC fields as well as the value of its receiverId RTP extension (if present) against the 
   <code>RTCRtpReceiver.RTCRtpParameters.RTCRtpCodecParameters.payLoadType</code>, 
   <code>RTCRtpReceiver.RTCRtpParameters.RTCRtpEncodingParameters.ssrc</code>,
   and <code>RTCRtpReceiver.RTCRtpParameters.receiverId</code> attributes of configured <a>RTCRtpReceiver</a> objects. 
   </p>

   <p>TODO: provide details of matching behavior, along with examples.</p>
  </section>

  <section id="rtcrtplistener-interface-definition*">
    <h3>Interface Definition</h3>

    <dl class="idl" title="[Constructor(RTCDtlsTransport transport)] interface RTCRtpListener">
      <dt>readonly attribute <a>RTCDtlsTransport</a>                    transport</dt>
      <dd>
        <p>The <a>RTCDtlsTransport</a> instance.</p>
      </dd>
      <dt>attribute EventHandler?   onunhandledrtp</dt>
      <dd><p>The event handler which handles the <a>RTCRtpUnhandledRtpEvent</a>.</p></dd>
    </dl>
  </section>

  <section id="rtcrtpunhandledrtpevent-interface-definition*">
      <h3>Interface Definition</h3>

      <dl class="idl" title="interface RTCRtpUnhandledRtpEvent : Event">
        <dt>readonly attribute unsigned int  ssrc</dt>
        <dd>
          <p>The SSRC in the RTP packet triggering the event.</p>
        </dd>
        <dt>readonly attribute unsigned byte payloadType</dt>
        <dd>
          <p>The Payload Type value in the RTP packet triggering the event.</p>
        </dd>
        <dt>readonly attribute DOMString? receiverId</dt>
        <dd>
          <p>The value of the AppId header extension in the RTP packet triggering the event, if present.</p>
        </dd>
      </dl>

  </section>

  <section id="rtcrtplistener-example*">
    <h3>Example</h3>
    <pre class="example"><code class="javascript">

    </code></pre>

  </section>
</section>

<section id="rtcrtpdictionaries*">
  <h2>Dictionaries related to Rtp</h2>

  <section id="rtcrtpcapabilities*">
    <h3>dictionary RTCRtpCapabilities</h3>
    <dl title='dictionary RTCRtpCapabilities' class='idl'>
      <dt>sequence&lt;RTCRtpCodec> audioCodecs</dt>
      <dd><p>Supported audio codecs.</p></dd>
      <dt>sequence&lt;RTCRtpCodec> videoCodecs</dt>
      <dd><p>Supported video codecs.</p></dd>
      <dt>sequence&lt;DOMString> headerExtensions</dt>
      <dd><p>URIs of supported RTP header extensions.</p></dd>
      <dt>Capabilities features</dt>
      <dd><p>Features supported by the RTP engine.</p></dd>
      <dt>Capabilities rtcpFeedback</dt>
      <dd><p>Supported RTCP capabilities, such as "nack" from [[!RFC4585]].</p></dd>
    </dl>
  </section>

  <section id="rtcrtpcodec*">
    <h3>dictionary RTCRtpCodec</h3>
    <dl class="idl" title="dictionary RTCRtpCodec">
      <dt>DOMString name=""</dt>
        <dd><p>The MIME media type, if set, empty string otherwise.</p></dd>
      <dt>unsigned int? clockRate=null</dt>
        <dd><p>Codec clockrate, null if unset.</p></dd>
      <dt>unsigned int? numChannels=1</dt>
        <dd><p>The number of channels supported (e.g. stereo); one by default.</p></dd>
      <dt>Capabilities formats</dt>
        <dd><p>Codec-specific capabilities available for signaling.</p></dd>
    </dl>
  </section>

  <section id="rtcrtpparameters*">
    <h3>dictionary RTCRtpParameters</h3>
    <dl title='dictionary RTCRtpParameters' class='idl'>
      <dt>DOMString? receiverId=""</dt>
      <dd><p>The receiverId assigned to the RTP stream, if any, empty string otherwise.  
In an <a>RTCRtpReceiver</a> object, this corresponds to
recv-appId defined in [[!APPID]].  In an <a>RTCRtpSender</a> object, it corresponds to the appId.
This is a stable identifier that can be defined and assign to any RTP stream rather than relying on an SSRC.
An SSRC is randomly generated and can change arbitrarily due to conflicts with other SSRCs, whereas
the receiverId has a value 
whose meaning can be defined in advance between RTP
sender and receiver, assisting in RTP demultiplexing. 
</p></dd>
      <dt>sequence&lt;RTCRtpCodecParameters> codecs</dt>
      <dd><p>The codecs to send or receive (could include RTX and CN as well).</p></dd>
      <dt>sequence&lt;RTCRtpHeaderExtensionParameters> headerExtensions</dt>
      <dd><p>The RTP header extensions to send or receive.</p></dd>
      <dt>sequence&lt;RTCRtpEncodingParameters> encodings</dt>
      <dd><p>The "encodings" or "layers" to be used for things like simulcast, Scalable Video Coding, RTX, FEC, etc.</p></dd>
    </dl>
  </section>

  <section id="rtcrtpcodecparameters*">
    <h3>dictionary RTCRtpCodecParameters</h3>
    <dl title='dictionary RTCRtpCodecParameters' class='idl'>
      <dt>unsigned byte        payloadType=null</dt>
      <dd><p>The value that goes in the RTP Payload Type Field [[!RFC3550]], null if unset.</p></dd>
      <dt>RTCRtpCodec   codec</dt>
      <dd><p>The codec to be used for sending or receiving.</p></dd>
      <dt>Settings formats</dt>
      <dd><p>Codec settings that control what is sent or received.  For example, with Opus [[!RFC6716]], stereo=1.</p></dd>
      <dt>Settings  rtcpFeedback</dt>
      <dd><p>RTCP feedback settings, separated out because they are so different.</p></dd>
    </dl>
  </section>

  <section id="rtcrtpencodingparameters*">
    <h3>dictionary RTCRtpEncodingParameters</h3>
    <dl class="idl" title="dictionary RTCRtpEncodingParameters">
      <dt>unsigned int? ssrc=null</dt>
      <dd><p>The SSRC for this layering/encoding, null if unset.</p></dd>
      <dt>DOMString?  codecName=""</dt>
      <dd><p>For per-encoding codec specifications, give the codec name here.  If the empty string, the browser will choose.</p></dd>
      <dt>RTCRtpFecParameters? fec</dt>
      <dd><p>Specifies the FEC mechanism if used.</p></dd>
      <dt>RTCRtpRtxParameters? rtx</dt>
      <dd><p>Specifies the RTX mechanism if used.</p></dd>
      <dt>double priority=1.0</dt>
      <dd><p>The higher the value, the more the bits will be given to each as available bandwidth goes up.  Default is 1.0.</p></dd>
      <dt>double maxBitrate=null</dt>
      <dd><p>Ramp up resolution/quality/framerate until this bitrate, null if unset.  Summed when using dependent layers.</p></dd>
      <dt>double minQuality=null</dt>
      <dd><p>Never send less than this quality, null if unset.  1.0 = maximum attainable quality.</p></dd>
      <dt>double frameratebias=0.5</dt>
      <dd><p>What to give more bits to, if available, null if unset.  0.0 = strongly favor resolution or 1.0 = strongly favor 
             framerate. 0.5 = neither (default).</p></dd>
      <dt>double scale=null</dt>
      <dd><p>Do this scale of the input resolution, or die trying.  1.0 = full resolution.  Default is unconstrained (null).</p></dd>
      <dt>boolean active=true</dt>
      <dd><p>Whether the sender or receiver is active.  If false, don't send any media right now.
      Disable is different than omitting the encoding;  it can keep resources
      available to re-enable more quickly than re-adding.  Plus, it still sends RTCP.  Default is active.</p></dd>
      <dt>DOMString? encodingId</dt>
      <dd><p>
An identifier for the encoding object.  This identifier should be unique within the scope of the
localized sequence of <a>RTCRtpEncodingParameters</a> for any given <a>RTCRtpParameters</a> object.
If encodings contained within sequences of other <a>RTCRtpParameters</a> objects are dependent
upon this encoding identifier, the identifier should be globally unique (unless two or more
encodings are intentionally referencing the same dependency <a>RTCRtpEncodingParameters</a> such
as described in [[!RFC5583]] Section 6.5a).
      </p>
      </dd>
      <dt>sequence&lt;DOMString> dependencyEncodingIds</dt>
      <dd><p>Just the IDs (resolve to <a>encodingIds</a> within the same sequence first, then search globally for matches).</p></dd>
    </dl>
</section>

<section id="rtcrtpencodingparameters-example*">
    <h3>Examples</h3>

<pre class="example"><code>
//Send a thumbnail along with regular size
var encodings1 = [  ssrc: 1,  priority: 1.0 }] 

// Control the resolution and framerate with a different track and RtpSender. 
var encodings2 = [{ ssrc: 2,  
// Prioritize the thumbnail over the main video.  
priority: 10.0 }];

// Sign Language (need high framerate, but don't get too bad quality)
var encodings = [{ minQuality: 0.2,  framerateBias: 1.0 }]; 

// Screencast (High quality, framerate can be low)
var encodings = [{ framerateBias: 0.0 }]; 

//Remote Desktop (High framerate, must not dowscale) 
var encodings = [{ framerateBias: 1.0 }];

// Audio more important than video
var audioEncodings = [{ priority: 10.0 }]; 
var videoEncodings = [{ priority: 0.1 }]; 

//Video more important than audio
var audioEncodings = [{ priority: 0.1 }]; 
var videoEncodings = [{ priority: 10.0 }];

//Crank up the quality
var encodings = [{ maxBitrate: 10000000 }]; 

//Keep the bandwidth low
var encodings = [{ maxBitrate: 100000 }]; 
</code></pre>

<pre class="example"><code>
Example of 3-layer encoding with spatial scalability
var encodings =[{
  layerId: "0",
  scale: 0.25
}, {
  layerId: "1",
  layerDependencies: ["0"]
  scale: 0.5
}, {
  layerId: "2",
  layerDependencies: ["0", "1"]
  scale: 1.0
}]

Example of 3-layer encoding with spatial scalability and all but bottom layer disabled
var encodings1 =[{
  layerId: "0",
  scale: 0.25
}, {
  layerId: "1",
  layerDependencies: ["0"],
  scale: 0.5,
  active: false
}, {
  layerId: "2",
  layerDependencies: ["0", "1"],
  scale: 1.0,
  active: false
}];

Example of 3-layer spatial simulcast
var encodings =[{
  layerId: "0",
  scale: 0.25
}, {
  layerId: "1",
  scale: 0.5
}, {
  layerId: "2",
  scale: 1.0
}]

Example of 3-layer spatial simulcast with all but bottom layer disabled
var encodings1 =[{
  layerId: "0",
  scale: 0.25
}, {
  layerId: "1",
  scale: 0.5,
  active: false
}, {
  layerId: "2",
  scale: 1.0,
  active: false
}];
</code></pre>
  </section>

  <section id="rtcrtpfecparameters*">
    <h3>dictionary RTCRtpFecParameters</h3>
    <dl title='dictionary RTCRtpFecParameters' class='idl'>
      <dt>unsigned int ssrc=null</dt>
      <dd><p>The SSRC to use for FEC, null if unset.</p></dd>
      <dt>DOMString mechanism=""</dt>
      <dd><p>The Forward Error Correction (FEC) mechanism to use, if any, empty string otherwise.</p></dd>
    </dl>
  </section>

  <section id="rtcrtprtxparameters*">
    <h3>dictionary RTCRtpRtxParameters</h3>
    <dl title='dictionary RTCRtpRtxParameters' class='idl'>
      <dt>unsigned int ssrc=null</dt>
      <dd><p>The SSRC to use for RTX, null if unset.</p></dd>
    </dl>
  </section>

  <section id="rtcrtpheaderextensionparameters*">
    <h3>dictionary RTCRtpHeaderExtensionParameters</h3>
    <dl class="idl" title="dictionary RTCRtpHeaderExtensionParameters">
      <dt>DOMString           uri=""</dt>
         <dd><p>The URI of the RTP header extension, if any, as defined in [[!RFC5285]], empty string otherwise.</p></dd>
      <dt>unsigned short      id=null</dt>
         <dd><p>The value that goes in the packet, null if unset.</p></dd>
      <dt>boolean           encrypt=false</dt>
          <dd><p>If true, the value in the header is encrypted as per [[!RFC6904]].  Default is unencrypted.</p></dd>
    </dl>
  </section>

  <section id="propertyvalues*">
    <h3>Properties</h3>

  <section id="propertyvalueset*">
    <h3>PropertyValueSet</h3>
    <dl title='typedef PropertyValueSet DOMString[]' class='idl'>
    </dl>
  </section>
  <section id="multipropertyvalueset*">
    <h3>MultiPropertyValueSet</h3>
    <dl title='typedef MultiPropertyValueSet DOMString[]' class='idl'>
    </dl>
  </section>
    <section id="propertyvaluedoublerange*">
    <h3>PropertyValueDoubleRange</h3>
    <dl title='dictionary PropertyValueDoubleRange' class='idl'>
    <dt>double max</dt>
    <dd><p>The maximum legal value of this property.</p></dd>
    <dt>double min</dt>
    <dd><p>The minimum legal value of this property.</p></dd>
    </dl>
  </section>
    <section id="propertyvaluelongrange*">
    <h3>PropertyValueLongRange</h3>
    <dl title='dictionary PropertyValueLongRange' class='idl'>
    <dt>long max</dt>
    <dd><p>The maximum legal value of this property.</p></dd>
    <dt>long min</dt>
    <dd><p>The minimum legal value of this property.</p></dd>
    </dl>
  </section>
  <section id="constraintvalue*">
    <h3>ConstraintValue</h3>
    <dl title='typedef (DOMString or long or double or boolean) ConstraintValue' class='idl'>
    </dl>
  </section>
  <section id="constraintvalues*">
    <h3>ConstraintValues</h3>
     <dl class="idl" title=
  "typedef (ConstraintValue or MultiPropertyValueSet or PropertyValueSet or PropertyValueLongRange or PropertyValueDoubleRange) ConstraintValues">
        </dl>
   </section>
  </section>
  <section id="capabilities*">
    <h3>Capabilities</h3>
    <p>Capabilities are a dictionary containing one or more key-value pairs, 
    where each key must be a property defined in the registry, and each value 
    must be a subset of the set of values defined for that property in the registry. 
    The exact syntax of the value expression depends on the type of the property but 
    is of type <code>ConstraintValues</code>. The Capabilities dictionary specifies the subset 
    of the properties and values from the registry that the UA supports. 
    Note that a UA may support only a subset of the properties that are defined in 
    the registry, and may support a subset of the set values for those properties 
    that it does support.  Note that Capabilities are returned from the UA to the 
    application, and cannot be specified by the application.  However, the application 
    can set the Parameters.

    An example of a Capabilities dictionary is shown below. This example is not 
    very realistic in that a browser would actually be required to support more 
    settings that just these.</p>
 
  <section id="capabilityexamples*">
  <h3>Examples</h3>
<pre class="example"><code>
</code></pre>
  </section>

  </section>
  <section id="settings*">
    <h3>Settings</h3>
    <p>A Settings is a dictionary containing one or more key-value pairs. 
    It must contain each key returned in Capabilities.  There must be 
    a single value for each key and the value must a member of the set 
    defined for that property by Capabilities. The exact syntax of the 
    value expression depends on the type of the property. It will be a 
    DOMString[] for properties of type <code>MultiPropertyValueSet</code>.  It will
    be a DOMString[] for properties of type <code>PropertyValueSet</code>, it will be a long 
    for properties of type <code>PropertyValueLongRange</code> , it will be a double 
    for properties of type <code>PropertyValueDoubleRange</code>. Thus the Settings 
    dictionary contains the actual values that the UA has chosen for the 
    object's Capabilities.

    An example of a Settings dictionary is shown below. This example is not 
    very realistic in that a browser would actually be required to support 
    more settings that just these.</p>

  <section id="settingexamples*">
  <h3>Examples</h3>
<pre class="example"><code>
</code></pre>
  </section>

  </section>
  </section>
</section>

<section id="rtcdtmfsender*">
  <h2>The RTCDtmfSender Object</h2>

  <section id="rtcdtmfsender-overview*">
    <h3>Overview</h3>
    <p>An <dfn>RTCDtmfSender</dfn> instance allows sending DTMF tones to/from the remote peer, as per [[!RFC4733]].</p>
  </section>

  <section id="rtcdtmfsender-operation*">
    <h3>Operation</h3>

    <p>An <a>RTCDtmfSender</a> object is constructed from an <a>RTCRtpSender</a> object.</p>
  </section>

  <section id="rtcdtmfsender-interface-definition*">
    <h3>Interface Definition</h3>

    <dl class="idl" title="[Constructor(RTCRtpSender)] interface RTCDtmfSender">
      <dt>readonly attribute boolean <a>canInsertDTMF</a></dt>
      <dd>
        <p>Whether the <a>RTCDtmfSender</a> is capable of sending DTMF.</p>
      </dd>

        <dt>void insertDTMF(in DOMString tones, optional long duration, long
        interToneGap)</dt>
      <dd></dd>

      <dt>readonly attribute <a>RTCRtpSender</a> sender</dt>
      <dd><p>The <a>RTCRtpSender</a> instance</p></dd>

      <dt>attribute EventHandler ontonechange</dt>
        <dd>
          <p>The <dfn>ontonechange</dfn> event handler uses the
          <a>RTCDTMFToneChangeEvent</a> interface to return the
          character for each tone as it is played out. 
          </p>
        </dd>

      <dt>readonly attribute DOMString toneBuffer</dt>
         <dd>
          <p>The <dfn>toneBuffer</dfn> attribute returns a list of the 
          tones remaining to be played out.</p>
        </dd> 

        <dt>readonly attribute long duration</dt>

        <dd>
          <p>The <dfn>duration</dfn> attribute returns the current tone duration
          value in milliseconds.  This value will be the value last set via the 
          <code>insertDTMF()</code> method, or the default value of 70 ms if
          <code>insertDTMF()</code> was called without specifying the duration.</p>
        </dd>

        <dt>readonly attribute long interToneGap</dt>

        <dd>
          <p>The <dfn>interToneGap</dfn> attribute returns the current value of
          the between-tone gap.  This value will be the value last set via the
          <code>insertDTMF()</code> method, or the default value of 70
          ms if <code>insertDTMF()</code> was called without specifying
          the <code>interToneGap.</code></p>
        </dd>

    </dl>

    </section>

    <section>
      <h3>RTCDTMFToneChangeEvent</h3>

      <p>The tonechange event uses the
      <a>RTCDTMFToneChangeEvent</a> interface.</p>

      <p> Firing an tonechange event named
      <var>e</var> with a DOMString <var>tone</var> means
      that an event with the name <var>e</var>, which does not bubble (except
      where otherwise stated) and is not cancelable (except where otherwise
      stated), and which uses the <a>RTCDTMFToneChangeEvent</a>
      interface with the <a>tone</a>
      attribute set to
      <var>tone</var>, MUST be created and dispatched at the given target.</p>

      <dl class="idl" data-merge="RTCDTMFToneChangeEventInit" title=
      "interface RTCDTMFToneChangeEvent : Event">
        <dt>Constructor(DOMString type, RTCDTMFToneChangeEventInit
        eventInitDict)</dt>
        <dd></dd>
        <dt>readonly attribute DOMString tone</dt>
        <dd>
          <p>The <dfn>tone</dfn>
          attribute contains the character for the tone that has just begun
          playout (see <code>insertDTMF()</code>).  If the value is the
          empty string, it indicates that the previous tone has completed
          playback.</p>
        </dd>
      </dl>
      <dl class="idl" title=
      "dictionary RTCDTMFToneChangeEventInit : EventInit">
        <dt>DOMString tone=""</dt>
        <dd>
          <p>The <a>tone</a> parameter is treated as a series of characters. 
          The characters 0 through 9, A through D, #, and * generate the associated DTMF tones. 
          The characters a to d are equivalent to A to D. 
          The character ',' indicates a delay of 2 seconds before processing the next character in the tones parameter. 
          Unrecognized characters are ignored.</p>
        </dd>
      </dl>
    </section>
</section>

<section id="rtcdatachannel*">
  <h2>The RTCDataChannel Object</h2>

  <section id="rtcdatachannel-overview*">
    <h3>Overview</h3>

    <p>
      An <dfn>RTCDataChannel</dfn> class instance allows sending data messages to/from the remote peer.
    </p>
  </section>

  <section id="rtcdatachannel-operation*">
    <h3>Operation</h3>

    <p>An <a>RTCDataChannel</a> object is constructed from an <a>RTCDataTransport</a> object and
an <a>RTCDataChannelParameters</a> object.</p>
  </section>

  <section id="rtcdatachannel-interface-definition*">
    <h3>Interface Definition</h3>

    <p>The <a>RTCDataChannel</a> interface represents a bi-directional data channel between 
    two peers.  
    There are two ways to establish a connection with <a>RTCDataChannel</a>. 
    The first way is to construct an <a>RTCDataChannel</a> at one of the peers with the 
    <a>RTCDataChannelParameters</a>.<code>negotiated</code> attribute unset or set to its default value false. 
    This will announce the new channel in-band and trigger an <a>ondatachannel</a> event with the 
     corresponding <a>RTCDataChannel</a> object at the other peer. 
     The second way is to let the application negotiate the <a>RTCDataChannel</a>. 
      To do this, create an <a>RTCDataChannel</a> object with the <a>RTCDataChannelParameters</a>.<code>negotiated</code>
     dictionary member set to true, and signal out-of-band (e.g. via a web server) to the other 
     side that it should create a corresponding <a>RTCDataChannel</a> with the 
     <a>RTCDataChannelParameters</a>.<code>negotiated</code> dictionary member set to true and the same id. 
     This will connect the two separately created <a>RTCDataChannel</a> objects. 
     The second way makes it possible to create channels with asymmetric properties and to 
     create channels in a declarative way by specifying matching ids.

     Each <a>RTCDataChannel</a> has an associated underlying data transport that is used 
     to transport actual data to the other peer. 
     The transport properties of the underlying data transport, such as in order delivery 
     settings and reliability mode, are configured by the peer as the channel is created. 
     The properties of a channel cannot change after the channel has been created. 
</p>
    <dl class="idl" title="[Constructor(RTCDataTransport transport, RTCDataChannelParameters parameters)] interface RTCDataChannel : EventTarget">
      <dt>readonly attribute RTCDataTransport           transport</dt>
      <dd><p>The readonly attribute referring to the related transport object.</p></dd>
      <dt>readonly attribute RTCDataChannelParameters parameters</dt>
      <dd><p>The parameters applying to this data channel.</p></dd>
      <dt>readonly attribute RTCDataChannelState readyState</dt>
      <dd><p>The <dfn id="dom-datachannel-readystate"><code>readyState</code></dfn> attribute represents the state of the <a>RTCDataChannel</a> object. 
      It must return the value to which the user agent last set it (as defined by the processing model algorithms).
      </p></dd>
      <dt>readonly attribute unsigned long bufferedAmount</dt>
      <dd><p>The <dfn id="dom-datachannel-buffereamount"><code>bufferedAmount</code></dfn> attribute must return the number of bytes of application data 
      (UTF-8 text and binary data) that have been queued using send() but that, as of the last time 
      the event loop started executing a task, had not yet been transmitted to the network. 
      This includes any text sent during the execution of the current task, regardless of whether the 
      user agent is able to transmit text asynchronously with script execution. 
      This does not include framing overhead incurred by the protocol, or buffering done by the 
      operating system or network hardware. 
      If the channel is closed, this attribute's value will only increase with each call to the 
      send() method (the attribute does not reset to zero once the channel closes).
      </p></dd>
      <dt>attribute DOMString binaryType</dt>
      <dd><p>The <dfn id="dom-datachannel-binarytype"><code>binaryType</code></dfn> attribute must, on getting, return the value to which it was last set. 
      On setting, the user agent must set the IDL attribute to the new value. 
      When an <a>RTCDataChannel</a> object is constructed, the <code>binaryType</code> attribute must be initialized to the string 'blob'.
      This attribute controls how binary data is exposed to scripts. 
      See the [[!WEBSOCKETS-API]] for more information.
      </p></dd>
      <dt>void close()</dt>
      <dd><p>Closes the <a>RTCDataChannel</a>. 
      It may be called regardless of whether the <a>RTCDataChannel</a> object was created by this peer or the remote peer.
      When the <code>close()</code> method is called, the user agent must run the following steps:</p>
<p>1. Let channel be the <a>RTCDataChannel</a> object which is about to be closed.</p>
<p>2. If channel's <code>readyState</code> is closing or closed, then abort these steps.</p>
<p>3. Set channel's <code>readyState</code> attribute to closing.</p>
<p>4. If the closing procedure has not started yet, start it.</p>
      </dd>
      <dt>attribute EventHandler          onopen</dt>
      <dd><p>This event handler, of type <code>open</code>, must be supported by all objects implementing the RTCDataChannel interface.</p></dd>
      <dt>attribute EventHandler          onerror</dt>
      <dd><p>This event handler, of type <code>error</code>, must be supported by all objects implementing the RTCDataChannel interface.</p></dd>
      <dt>attribute EventHandler          onclose</dt>
      <dd><p>This event handler, of type <code>close</code>, must be supported by all objects implementing the RTCDataChannel interface.</p></dd>
      <dt>attribute EventHandler          onmessage</dt>
      <dd>
        <p>This event handler, of event handler event type <code>message</code>, must be fired to 
        allow a developer's JavaScript to receive data from a remote peer.</p>

        <table border="1">
          <tr>
            <td><em>Event Argument</em></td>
            <td><em>Description</em></td>
          </tr>
          <tr>
            <td>Object data</td>
            <td>The received remote data.</td>
          </tr>
        </table>
      </dd>
      <dt>Promise send (DOMString data)</dt>
      <dd><p>Run the steps described by the <code>send()</code> algorithm with argument type <code>string</code> object.</p></dd>
      <dt>Promise send (Blob data)</dt>
      <dd><p>Run the steps described by the <code>send()</code> algorithm with argument type <code>Blob</code> object.</p></dd>
      <dt>Promise send (ArrayBuffer data)</dt>
      <dd><p>Run the steps described by the <code>send()</code> algorithm with argument type <code>ArrayBuffer</code> object.</p></dd>
      <dt>Promise send (ArrayBufferView data)</dt>
      <dd><p>Run the steps described by the <code>send()</code> algorithm with argument type <code>ArrayBufferView</code> object.</p></dd>
    </dl>
  </section>

  <section id="rtcdatatransport-interface-definition*">
    <h3>Interface Definition</h3>

    <dl class="idl" title="interface RTCDataTransport">
    </dl>
  </section>

  <section id="rtcdatachannelstate*">
    <h3>enum RTCDataChannelState</h3>

      <dl class="idl" title="enum RTCDataChannelState">
        <dt>connecting</dt>
        <dd><p>The user agent is attempting to establish the underlying data transport.
        This is the initial state of an <a>RTCDataChannel</a> object.</p></dd>
        <dt>open</dt>
        <dd><p>The underlying data transport is established and communication is possible.
        This is the initial state of an <a>RTCDataChannel</a> object dispatched as a
        part of an RTCDataChannelEvent.</p></dd>
        <dt>closing</dt>
        <dd><p>The procedure to close down the underlying data transport has started.</p></dd>
        <dt>closed</dt>
        <dd><p>The underlying data transport has been closed or could not be established.</p></dd>
      </dl>
  </section>

<section id="rtcdatachannelparameters*">
    <h3>dictionary RTCDataChannelParameters</h3>
    <p>An <a>RTCDataChannel</a> can be configured to operate in different reliability modes. 
    A reliable channel ensures that the data is delivered at the other peer through retransmissions. 
    An unreliable channel is configured to either limit the number of retransmissions (maxRetransmits ) or set 
    a time during which transmissions (including retransmissions) are allowed (maxPacketLifeTime). 
    These properties can not be used simultaneously and an attempt to do so will result in an error. 
    Not setting any of these properties results in a reliable channel.</p>

    <dl class="idl" title="dictionary RTCDataChannelParameters">
      <dt>DOMString? label=""</dt>
      <dd><p>The <dfn>label</dfn> attribute represents a label that can be used to distinguish this <a>RTCDataChannel</a> object from other <a>RTCDataChannel</a> objects. 
      The attribute must return the value to which it was set when the <a>RTCDataChannel</a> object was constructed.
      For an SCTP data channel, the label is carried in the DATA_CHANNEL_OPEN message defined in 
      [[!DATA-PROT]] Section 5.1.</p></dd>
      <dt>boolean                  ordered=true</dt>
         <dd><p>The <dfn id="dom-datachannel-ordered"><code>ordered</code></dfn> 
         attribute returns true if the <a>RTCDataChannel</a> is ordered, and 
         false if out of order delivery is allowed.  Default is true.
         The attribute must return the value to which it was set when the
         <a>RTCDataChannel</a> was constructed.
      </p></dd>
      <dt>unsigned short?          maxPacketLifetime=null</dt>
         <dd><p>The <dfn id="dom-datachannel-maxpacketlifetime"><code>maxPacketLifetime</code></dfn> 
         attribute represents the length of the time window (in milliseconds) during which
         retransmissions may occur in unreliable mode, or null if unset.
         The attribute must return the value to which it was set when the
         <a>RTCDataChannel</a> was constructed.</p></dd>
      <dt>unsigned short?          maxRetransmits=null</dt>
         <dd><p>The <dfn id="dom-datachannel-maxretransmits"><code>maxRetransmits</code></dfn> 
         attribute returns the maximum number of 
         retransmissions that are attempted in unreliable mode, or null if unset. 
         The attribute must be initialized to null by default and must return the 
         value to which it was set when the <a>RTCDataChannel</a> was constructed.
      </p></dd>
      <dt>DOMString?               protocol=""</dt>
          <dd><p>The name of the sub-protocol used with this <a>RTCDataChannel</a> if any,
          or the empty string otherwise (in which case the protocol is unspecified).
          The attribute must return the value to which it was set when the
          <a>RTCDataChannel</a> was constucted.  Sub-protocols are registered in the 
          'Websocket Subprotocol Name Registry' created in [[!RFC6455]] Section 11.5.</p></dd>
      <dt>boolean                 negotiated=false</dt>
          <dd><p>The <dfn id="dom-datachannel-negotiated"><code>negotiated</code></dfn> 
          attribute returns true if this <a>RTCDataChannel</a> 
          was negotiated by the application, or false otherwise.  The attribute must 
          be initialized to false by default and must return the value to which it 
          was set when the <a>RTCDataChannel</a> was constructed.
          If set to true, the application developer must signal to the remote peer to 
          construct an <a>RTCDataChannel</a> object with the same id for the data channel 
          to be open. 
          If set to false, the remote party will receive an ondatachannel event with 
          a system constructed <a>RTCDataChannel</a> object.  
      </p></dd>
      <dt>unsigned short?        id=null</dt>
      <dd><p>The id attribute returns the id for this <a>RTCDataChannel</a>, or null if unset.  
      The id was either assigned by the user agent at channel creation time or was selected by the script.                             
      For SCTP, the id represents a stream identifier, as discussed in [[!DATA]] Section 6.5.  
      The attribute must return the value to which it was set when the 
      <a>RTCDataChannel</a> was constructed.</p></dd>
    </dl>
</section>
</section>

<section id="sctp-transport*">
  <h2>The RTCSctpTransport Object</h2>

    <p>
      The <dfn>RTCSctpTransport</dfn> includes information relating to Stream Control Transmission Protocol (SCTP) transport.
    </p>

  <section id="sctp-transport-overview*">
    <h3>Overview</h3>

    <p>An <a>RTCSctpTransport</a> inherits from an <a>RTCDataTransport</a> object, which is associated to an <a>RTCDataChannel</a> object.</p>
  </section>

  <section id="sctptransport-operation*">
    <h3>Operation</h3>

    <p>An <a>RTCSctpTransport</a> is constructed from an <a>RTCDtlsTransport</a> object.</p>
  </section>

  <section id="sctptransport-interface-definition*">
    <h3>Interface Definition</h3>

    <dl class="idl" title="[Constructor(RTCDtlsTransport)] interface RTCSctpTransport : RTCDataTransport">
      <dt>attribute <a>RTCDtlsTransport</a>                    transport</dt>
      <dd><p>The <a>RTCDtlsTransport</a> instance the <a>RTCSctpTransport</a> object is sending over.</p></dd>
      <dt>static <a>RTCSctpCapabilities</a> getCapabilities()</dt>
      <dd><p>Retrieves the <a>RTCSctpCapabilities</a> of the <a>RTCSctpTransport</a> instance.</p></dd>

      <dt>void start(<a>RTCSctpCapabilities</a> remoteCaps)</dt>
      <dd></dd>

      <dt>void stop()</dt>
      <dd><p>Stops the <a>RTCSctpTransport</a> instance.</p></dd>

    <dt>attribute EventHandler       ondatachannel</dt>
    <dd><p>
    If the remote peers sets <a>RTCDataChannelParameters</a>.<code>negotiated</code> to false, 
    then the <dfn>ondatachannel</dfn> event will fire indicating a new <a>RTCDataChannel</a> object has been 
    constructed to connect with the <a>RTCDataChannel</a> constructed by the remote peer.
    This event handler, of type datachannel, must be supported by all objects implementing the
    <a>RTCSctpTransport</a> interface.
    </p></dd>
    </dl>

  <section id="rtcsctpcapabilities*">
    <h3>dictionary RTCSctpCapabilities</h3>
    <dl class="idl" title="dictionary RTCSctpCapabilities">
      <dt>unsigned int                 maxMessageSize=null</dt>
      <dd><p>Maximum message size or null if unset.</p></dd>
    </dl>
</section>
</section>

  <section id=rtcsctpexample*">
    <h2>Example</h2>

<pre class="example"><code>
function initiate(signaller) {
  var dtls = ...;  // See ICE/DTLS example.
  var sctp = new RTCSctpTransport(dtls);

  signaller.sendInitiate({
    // ... include ICE/DTLS info from other example.
  sctpCapabilities: RTCSctpTransport.getCapabilities()
  }, function(remote) {
    sctp.start(remote.sctpCapabilities);
  });

  var channel = sctp.createDataChannel({...});
  channel.send("foo");
}

function accept(signaller, remote) {
  var dtls = ...;  // See ICE/DTLS example.
  signaller.sendAccept({
    // ... include ICE/DTLS info from other example.
    "sctpCapabilities": RTCSctpTransport.getCapabilities()
  });

  var sctp = new RTCSctpTransport(dtls);
  sctp.start(remote.sctpCapabilties);

  // Assume in-band signalling.  We could also easily add
  // RTCDataChannelParameters into the out-of-band signalling
  // And call .createDataChannel here with negotiated: true.

  sctp.ondatachannel = function(channel) {
    channel.onmessage = function(message) {
    if (message == "foo") {
      channel.send("bar");
    }
  }
}
</code></pre>

</section>
</section>

    <section>
      <h3>Interface Extensions</h3>

      <p>The Statistics API extends the RTCRtpSender, RTCRtpReceiver, RTCDtlsTransport, RTCIceTransport and RTCSctpTransport interfaces.</p>

      <dl class="idl" title="partial interface RTCRtpSender">
        <dt>void getStats(RTCStatsCallback
        successCallback, RTCErrorCallback failureCallback)</dt>

        <dd>
          <p>Gathers stats for the given <a>RTCRtpSender</a> object
          and reports the result asynchronously.</p>

          <p>When the
          <dfn>getStats()</dfn> method is
          invoked, the user agent MUST queue a task to run the following
          steps:</p>

          <ol>
            <li>
              <p>If the <code><a>RTCRtpSender</a></code> object's 
              <a>RTCRtpEncodingParameters.active</a> state is <code>false</code>, throw an
              <code>InvalidStateError</code> exception.</p>
            </li>


            <li>
              <p>Return, but continue the following steps in the
              background.</p>
            </li>

            <li>
              <p>Start gathering the stats.</p>
            </li>


            <li>
              <p>When the relevant stats have been gathered, queue a task to
              invoke the success callback (the method's second argument) with a
              new <code><a>RTCStatsReport</a></code> object, representing the
              gathered stats, as its argument.</p>
            </li>
          </ol>
        </dd>
      </dl>

    <section>
      <h4>RTCStatsCallback</h4>

      <dl title='callback RTCStatsCallback = void' class='idl'>
        <dt>RTCStatsReport report</dt>
        <dd>
          <p>A <code><a>RTCStatsReport</a></code> representing the gathered
          stats.</p>
        </dd>
      </dl>
    </section>

    <section>
      <h4>RTCStatsReport Object</h4>

      <p>The <code><a>getStats()</a></code>
      method delivers a successful result in the form of a
      <code><a>RTCStatsReport</a></code> object. A
      <code><a>RTCStatsReport</a></code> object represents a map between
      strings, identifying the inspected objects (<a href=
      "#dom-rtcstats-id">RTCStats.id</a>), and their corresponding
      <code><a>RTCStats</a></code> objects.</p>

      <p>An <code><a>RTCStatsReport</a></code> may be composed of several
      <code><a>RTCStats</a></code> objects, each reporting stats for one
      underlying object.
      One achieves the total for the object by summing over all stats of a 
      certain type; for instance, if an <a>RTCRtpSender</a> object is sending
      RTP streams involving multiple SSRCs over the network, the
      <code><a>RTCStatsReport</a></code> may contain one <code>RTCStats</code>
      object per SSRC (which can be distinguished by the value of the "ssrc"
      stats attribute).</p>

      <dl class="idl" title="interface RTCStatsReport">
        <dt>getter RTCStats (DOMString id)</dt>
        <dd>
          <p>Getter to retrieve the <code><a>RTCStats</a></code> objects that
          this stats report is composed of.</p>

          <p>The set of supported property names [[!WEBIDL]] is defined as the
          ids of all the <code><a>RTCStats</a></code> objects that has been
          generated for this stats report. The order of the property names is
          left to the user agent.</p>
        </dd>
      </dl>
    </section>

    <section>
      <h4>RTCStats Dictionary</h4>
      <p>An <code><a>RTCStats</a></code> dictionary represents the stats
      gathered by inspecting a specific object.
      The <code><a>RTCStats</a></code>
      dictionary is a base type that specifies as set of default attributes,
      such as <a href="#dom-rtcstats-timestamp">timestamp</a> and <a href=
      "#dom-rtcstats-type">type</a>. Specific stats are added by extending the
      <code><a>RTCStats</a></code> dictionary.</p>

      <p>Note that while stats names are standardized, any given implementation
      may be using experimental values or values not yet known to the Web
      application. Thus, applications MUST be prepared to deal with unknown
      stats.</p>

      <div class="note">
        OPEN ISSUE: Need to define an IANA registry for this and populate with
        pointers to existing things such as the RTCP statistics.
      </div>

      <p>Statistics need to be synchronized with each other in order to yield
      reasonable values in computation; for instance, if "bytesSent" and
      "packetsSent" are both reported, they both need to be reported over the
      same interval, so that "average packet size" can be computed as "bytes /
      packets" - if the intervals are different, this will yield errors. Thus
      implementations MUST return synchronized values for all stats in a
      <code><a>RTCStats</a></code> object.</p>

      <dl class="idl" title="dictionary RTCStats">
        <dt>DOMHiResTimeStamp timestamp</dt>

        <dd>
          <p>The <dfn id="dom-rtcstats-timestamp"><code>timestamp</code></dfn>,
          of type <code>DOMHiResTimeStamp</code> [[!HIGHRES-TIME]], associated
          with this object. The time is relative to the UNIX epoch (Jan 1,
          1970, UTC).</p>
        </dd>

        <dt>RTCStatsType type</dt>
        <dd>
          <p>The type of this object.</p>
          <p>The <dfn id="dom-rtcstats-type"><code>type</code></dfn> attribute
          MUST be initialized to the name of the most specific type this
          <code><a>RTCStats</a></code> dictionary represents.</p>
        </dd>
        <dt>DOMString id</dt>
        <dd>
          <p>A unique <dfn id="dom-rtcstats-id"><code>id</code></dfn> that is
          associated with the object that was inspected to produce this
          <code><a>RTCStats</a></code> object. Two <code><a>RTCStats</a></code>
          objects, extracted from two different
          <code><a>RTCStatsReport</a></code> objects, MUST have the same id if
          they were produced by inspecting the same underlying object. User
          agents are free to pick any format for the id as long as it meets the
          requirements above.</p>

          <div class="note">
            Consider naming id something that indicates that the id refers to
            the underlying object that was inspected to produce the stats,
            instead of being an id for the JavaScript object. Suggestions:
            statsObjectId, reporterId, srcId.
          </div>
        </dd>
      </dl>

      <dl class="idl" title="enum RTCStatsType">
        <dt>inbound-rtp</dt>
        <dd><p>Inbound RTP.  Relevant to <a>RTCRtpReceiver</a> objects.</p></dd>
        <dt>outbound-rtp</dt>
        <dd><p>Outbund RTP.  Relevant to <a>RTCRtpSender</a> objects.</p></dd>
      </dl>
    </section>

    <section>
      <h4>Derived Stats Dictionaries</h4>
      <dl class="idl" title="dictionary RTCRTPStreamStats : RTCStats">
        <dt>DOMString ssrc</dt>
        <dd>
          <p>...</p>
        </dd>

        <dt>DOMString remoteId</dt>
        <dd>
          <p>The <code>remoteId</code> can be used to look up the corresponding
          <code><a>RTCStats</a></code> object that represents stats reported by
          the other peer.</p>
        </dd>
      </dl>

      <dl class="idl" title=
      "dictionary RTCInboundRTPStreamStats : RTCRTPStreamStats">
        <dt>unsigned long packetsReceived</dt>
        <dd>
          <p>Relevant to <a>RTCRtpReceiver</a> objects.</p>
        </dd>
        <dt>unsigned long bytesReceived</dt>
        <dd>
          <p>Relevant to <a>RTCRtpReceiver</a> objects.</p>
        </dd>
      </dl>

      <dl class="idl" title=
      "dictionary RTCOutboundRTPStreamStats : RTCRTPStreamStats">
        <dt>unsigned long packetsSent</dt>
        <dd>
          <p>Relevant to <a>RTCRtpSender</a> objects.</p>
        </dd>

        <dt>unsigned long bytesSent</dt>
        <dd>
          <p>Relevant to <a>RTCRtpSender</a> objects.</p>
        </dd>
      </dl>
    </section>

    <section>
    <h3>Other interfaces</h3>

    <section>
    <h4>RTCRtpReceiver</h4>
        <dl class="idl" title="partial interface RTCRtpReceiver">
        <dt>void getStats(RTCStatsCallback
        successCallback, RTCErrorCallback failureCallback)</dt>
        </dl>
    </section>
    <section>
    <h4>RTCDtlsTransport</h4>
        <dl class="idl" title="partial interface RTCDtlsTransport">
        <dt>void getStats(RTCStatsCallback
        successCallback, RTCErrorCallback failureCallback)</dt>
        </dl>
    </section>
    <section>
    <h4>RTCIceTransport</h4>
        <dl class="idl" title="partial interface RTCIceTransport">
        <dt>void getStats(RTCStatsCallback
        successCallback, RTCErrorCallback failureCallback)</dt>
        </dl>
    </section>
    <section>
    <h4>RTCSctpTransport</h4>
        <dl class="idl" title="partial interface RTCSctpTransport">
        <dt>void getStats(RTCStatsCallback
        successCallback, RTCErrorCallback failureCallback)</dt>
        </dl>
    </section>
</section>

    <section>
      <h4>Example</h4>

    <p>Consider the case where the user is experiencing bad sound and the application wants to determine if the cause of it is packet loss. The following example code might be used:</p>

<pre class="example"><code>
</code></pre>

    </section>
  </section>
 </section>

<section id="rtcp-protocol*">
  <h2>RTCP Protocol</h2>

  <p>This specification requires that RTCP packets must be multiplexed with the RTP packets as defined by [[!RFC5761]].</p>
</section>

<section id="examples*">
  <h2>Examples</h2>

  <section id="simple-peer-to-peer-example*">
    <h3>Simple Peer-to-peer Example</h3>

    <p>This example code provides a basic audio and video session between two browsers.</p>

<pre class="example"><code>
</code></pre>

  </section>
</section>

  <section id="change-log*">
    <h2>Change Log</h2>

    <p>This section will be removed before publication.</p>
    <!-- Why do the first two headings automatically convert to <h2>? -->

  <section id="since-12-April-2014*">
    <h3>Changes since 12 April 2014</h3>

    <ol>
      <li> Fixes for error handling, as described in
           <a href="https://github.com/openpeer/ortc/issues/26">Issue 26</a></li>
      <li> Support for contributing sources removed (re-classified as a 1.2 feature), as described in
           <a href="https://github.com/openpeer/ortc/issues/27">Issue 27</a></li>
      <li> Cleanup of DataChannel construction, as described in
           <a href="https://github.com/openpeer/ortc/issues/60">Issue 60</a></li>
      <li> Separate proposal on simulcast/layering, as described in
           <a href="https://github.com/openpeer/ortc/issues/61">Issue 61</a></li>
      <li> Separate proposal on quality, as described in
           <a href="https://github.com/openpeer/ortc/issues/62">Issue 62</a></li>
      <li> Fix for TCP candidate type, as described in
           <a href="https://github.com/openpeer/ortc/issues/63">Issue 63</a></li>
      <li> Fix to the fingerprint attribute, as described in
           <a href="https://github.com/openpeer/ortc/issues/64">Issue 64</a></li>
      <li> Fix to RTCRtpFeatures, as described in
           <a href="https://github.com/openpeer/ortc/issues/65">Issue 65</a></li>
      <li> Support for retrieval of remote certificates, as described in
           <a href="https://github.com/openpeer/ortc/issues/67">Issue 67</a></li>
      <li> Support for ICE error handling, described in
           <a href="https://github.com/openpeer/ortc/issues/68">Issue 68</a></li>
      <li> Support for Data Channel send rate control, as described in
           <a href="https://github.com/openpeer/ortc/issues/69">Issue 69</a></li>
      <li> Support for capabilities and settings, as described in
           <a href="https://github.com/openpeer/ortc/issues/70">Issue 70</a></li>
      <li> Removal of duplicate RTCRtpListener functionality, as described in
           <a href="https://github.com/openpeer/ortc/issues/71">Issue 71</a></li>
      <li> ICE gathering state added, as described in
           <a href="https://github.com/openpeer/ortc/issues/72">Issue 72</a></li>
      <li> Removed ICE role from the ICE transport constructor, as described in
           <a href="https://github.com/openpeer/ortc/issues/73">Issue 73</a></li>
    </ol>
   </section>


  <section id="since-13-February-2014*">
    <h3>Changes since 13 February 2014</h3>

     <ol>
      <li> Support for contributing source information added, as described in
           <a href="https://github.com/openpeer/ortc/issues/27">Issue 27</a></li>
      <li> Support for control of quality, resolution, framerate and layering added, as described in
           <a href="https://github.com/openpeer/ortc/issues/31">Issue 31</a></li>
      <li> RTCRtpListener object added and figure in Section 1 updated, as described in
           <a href="https://github.com/openpeer/ortc/issues/32">Issue 32</a></li>
      <li> More complete support for RTP and Codec Parameters added, as described in
           <a href="https://github.com/openpeer/ortc/issues/33">Issue 33</a></li>
      <li> Data Channel transport problem fixed, as described in
           <a href="https://github.com/openpeer/ortc/issues/34">Issue 34</a></li>
      <li> Various NITs fixed, as described in
           <a href="https://github.com/openpeer/ortc/issues/37">Issue 37</a></li>
      <li> Section 2.2 and 2.3 issues fixed, as described in
           <a href="https://github.com/openpeer/ortc/issues/38">Issue 38</a></li>
      <li> Default values of some dictionary attributes added, to partially address the issue described in
           <a href="https://github.com/openpeer/ortc/issues/39">Issue 39</a></li>
      <li> Support for ICE TCP added, as described in
           <a href="https://github.com/openpeer/ortc/issues/41">Issue 41</a></li>
      <li> Fixed issue with sequences as attributes, as described in
           <a href="https://github.com/openpeer/ortc/issues/43">Issue 43</a></li>
      <li> Fix for issues with onlocalcandidate, as described in
           <a href="https://github.com/openpeer/ortc/issues/44">Issue 44</a></li>
      <li> Initial stab at a Stats API, as requested in 
           <a href="https://github.com/openpeer/ortc/issues/46">Issue 46</a></li>
      <li> Added support for ICE gather policy, as described in
           <a href="https://github.com/openpeer/ortc/issues/47">Issue 47</a></li>
     </ol>

</section>

  <section id="since-07-November-2013*">
    <h3>Changes since 07 November 2013</h3>

    <ol>

      <li> RTCTrack split into RTCRtpSender and RTCRtpReceiver objects, as proposed on 
           <a href="http://lists.w3.org/Archives/Public/public-orca/2014Jan/0000.html"> 06 January 2014.</a></li>
      <li> RTCConnection split into RTCIceTransport and RTCDtlsTransport objects, as proposed on 
           <a href="http://lists.w3.org/Archives/Public/public-orca/2014Jan/0005.html"> 09 January 2014. </a></li>
      <li> RTCSctpTransport object added, as described in 
           <a href="https://github.com/openpeer/ortc/issues/25">Issue 25</a></li>
      <li> RTCRtpHeaderExtensionParameters added, as described in 
           <a href="https://github.com/openpeer/ortc/issues/28">Issue 28</a></li>
      <li> RTCIceListener added, in order to support parallel forking, as described in
           <a href="https://github.com/openpeer/ortc/issues/29">Issue 29</a></li>
      <li> DTMF support added, as described in
           <a href="https://github.com/openpeer/ortc/issues/30">Issue 30</a></li>
    </ol>
   </section>
  </section>
</body>
</html>
