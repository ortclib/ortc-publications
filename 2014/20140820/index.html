<!DOCTYPE html>
<html lang="en" dir="ltr" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Object RTC (ORTC) API for WebRTC</title>
    <meta charset='utf-8'>
  
  <script src="http://www.w3.org/Tools/respec/respec-w3c-common"
          async class="remove"></script>
  <script class="remove">
var respecConfig = {
    "specStatus": "CG-DRAFT",
    "shortName":  "ortc-api",
    "publishDate": "2014-08-20",
    "editors": [
        {   "name":       "Robin Raymond",
            "url":        "http://about.me/robinraymond",
            "company":    "Hookflash",
            "companyURL": "http://www.hookflash.com/" }
    ],
    "authors": [
        {   "name":       "Bernard Aboba",
            "url":        "https://plus.google.com/+BernardAboba/about",
            "company":    "Microsoft Corporation",
            "companyURL": "http://www.microsoft.com/" },
        {   "name":       "Justin Uberti",
            "url":        "https://plus.google.com/+JustinUberti/posts",
            "company":    "Google",
            "companyURL": "https://www.google.com/" }
    ],
    "wg":           "Object-RTC API Community Group",
    "wgURI":        "http://www.w3.org/community/ortc/",
    "wgPublicList": "public-ortc",
    "wgPatentURI":  "",
    "localBiblio":  {
    "IANA-RTP-2": {
        title:    "RTP Payload Format media types"
    ,   href:     "http://www.iana.org/assignments/rtp-parameters/rtp-parameters.xhtml#rtp-parameters-2"
    ,   publisher:  "IANA"
    },
    "IANA-RTP-10": {
        title:    "RTP Compact Header Extensions"
    ,   href:     "http://www.iana.org/assignments/rtp-parameters/rtp-parameters.xhtml#rtp-parameters-10"
    ,   publisher:  "IANA"
    },    
    "IANA-SDP-14": {
        title:    "'rtcp-fb' Attribute Values"
    ,   href:     "http://www.iana.org/assignments/sdp-parameters/sdp-parameters.xhtml#sdp-parameters-14"
    ,   publisher:  "IANA"
    },
    "IANA-SDP-15": {
        title:    "'ack' and 'nack' Attribute Values"
    ,   href:     "http://www.iana.org/assignments/sdp-parameters/sdp-parameters.xhtml#sdp-parameters-15"
    ,   publisher:  "IANA"
    },
    "IANA-SDP-19": {
        title:    "Codec Control Messages"
    ,   href:     "http://www.iana.org/assignments/sdp-parameters/sdp-parameters.xhtml#sdp-parameters-19"
    ,   publisher:  "IANA"
    }, 
    "OPUS-RTP": {
        title:    "RTP Payload Format for Opus Speech and Audio Codec"
    ,   href:     "http://tools.ietf.org/html/draft-ietf-payload-rtp-opus"
    ,   authors:  [
            "J. Spittka"
        ,   "K. Vos"
        ,   "JM. Valin"
        ]
    ,   status:   "30 June 2014. Internet Draft (work in progress)"
    ,   publisher:  "IETF"
    },
    "RFC4585": {
        title:    "Extended RTP Profile for RTCP-Based Feedback (RTP/AVPF)"
    ,   href:     "http://tools.ietf.org/html/rfc4585"
    ,   authors:  [
            "J. Ott"
        ,   "S. Wenger"
        ,   "N. Sato"
        ,   "C. Burmeister"
        ,   "J. Rey"
        ]
    ,   status:   "July 2006. RFC"
    ,   publisher:  "IETF"
    },
    "RFC4733": {
        title:    "RTP Payload for DTMF Digits, Telephony Tones, and Telephony Signals"
    ,   href:     "http://tools.ietf.org/html/rfc4733"
    ,   authors:  [
            "H. Schulzrinne"
        ,   "T. Taylor"
        ]
    ,   status:   "December 2006. RFC"
    ,   publisher:  "IETF"
    },
    "RFC4961": {
        title:    "Symmetric RTP/RTC Control Protocol (RTCP)"
    ,   href:     "http://tools.ietf.org/html/rfc4961"
    ,   authors:  [
            "D. Wing"
        ]
    ,   status:   "July 2007. RFC"
    ,   publisher:  "IETF"
    },
    "RFC5104": {
        title:    "Codec Control Messages in the RTP Audio-Visual Profile with Feedback (AVPF)"
    ,   href:     "http://tools.ietf.org/html/rfc5104"
    ,   authors:  [
            "S. Wenger"
        ,   "U. Chandra"
        ,   "M. Westerlund"
        ,   "B. Burman"
        ]
    ,   status:   "February 2008. RFC"
    ,   publisher:  "IETF"
    },
    "RFC5285": {
        title:    "A General Mechanism for RTP Header Extensions"
    ,   href:     "http://tools.ietf.org/html/rfc5285"
    ,   authors:  [
            "D. Singer"
        ,   "H. Desineni"
        ]
    ,   status:   "July 2008. RFC"
    ,   publisher:  "IETF"
    },
    "RFC5450": {
        title:    "Transmission Time Offsets in RTP Streams"
    ,   href:     "http://tools.ietf.org/html/rfc5450"
    ,   authors:  [
            "D. Singer"
        ,   "H. Desineni"
        ]
    ,   status:   "March 2009. RFC"
    ,   publisher:  "IETF"
    },
    "RFC5506": {
        title:    "Support for Reduced-Size Real-Time Transport Control Protocol (RTCP): Opportunities and Consequences"
    ,   href:     "http://tools.ietf.org/html/rfc5506"
    ,   authors:  [
            "I. Johansson"
        ,   "M. Westerlund"
        ]
    ,   status:   "April 2009. RFC"
    ,   publisher:  "IETF"
    },
    "RFC5583": {
        title:    "Signaling Media Decoding Dependency in the SDP"
    ,   href:     "http://tools.ietf.org/html/rfc5583"
    ,   authors:  [
            "T. Schierl"
        ,   "S. Wenger"
        ]
    ,   status:   "July 2009. RFC"
    ,   publisher:  "IETF"
    },
    "RFC5761": {
        title:    "Multiplexing RTP Data and Control Packets on a Single Port"
    ,   href:     "http://tools.ietf.org/html/rfc5761"
    ,   authors:  [
            "C. Perkins"
        ,   "M. Westerlund"
        ]
    ,   status:   "April 2010. RFC"
    ,   publisher:  "IETF"
    },
    "RFC5764": {
        title:    "Datagram Transport Layer Security (DTLS) Extension to Establish Keys for the Secure Real-time Transport Protocol (SRTP)"
    ,   href:     "http://tools.ietf.org/html/rfc5764"
    ,   authors:  [
            "D. McGrew"
        ,   "E. Rescorla"
        ]
    ,   status:   "May 2010. RFC"
    ,   publisher:  "IETF"
    },
    "RFC6051": {
        title:    "Rapid Synchronisation of RTP Flows"
    ,   href:     "http://tools.ietf.org/html/rfc6051"
    ,   authors:  [
            "C. Perkins"
        ,   "T. Schierl"
        ]
    ,   status:   "November 2010. RFC"
    ,   publisher:  "IETF"
    },
    "RFC6184": {
        title:    "RTP Payload Format for H.264 Video"
    ,   href:     "http://tools.ietf.org/html/rfc6184"
    ,   authors:  [
            "Y.-K.. Wang"
        ,   "R. Even"
        ,   "T. Kristensen"
        ,   "R. Jesup"
        ]
    ,   status:   "May 2011. RFC"
    ,   publisher:  "IETF"
    },
    "RFC6190": {
        title:    "RTP Payload Format for Scalable Video Coding"
    ,   href:     "http://tools.ietf.org/html/rfc6190"
    ,   authors:  [
            "S. Wenger"
        ,   "Y.-K. Wang"
        ,   "T. Schierl"
        ,   "A. Eleftheriadis"
        ]
    ,   status:   "May 2011. RFC"
    ,   publisher:  "IETF"
    },
    "RFC6464": {
        title:    "A Real-time Transport Protocol (RTP) Header Extension for Client-to-Mixer Audio Level Indication"
    ,   href:     "http://tools.ietf.org/html/rfc6464"
    ,   authors:  [
            "J. Lennox, Ed."
        ,   "E. Ivov"
        ,   "E. Marocco"
        ]
    ,   status:   "December 2011. RFC"
    ,   publisher:  "IETF"
    },
    "RFC6465": {
        title:    "A Real-time Protocol (RTP) Header Extension for Mixer-to-Client Audio Level Indication"
    ,   href:     "http://tools.ietf.org/html/rfc6465"
    ,   authors:  [
            "E. Ivov"
        ,   "E. Marocco"
        ,   "J. Lennox"
        ]
    ,   status:   "December 2011. RFC"
    ,   publisher:  "IETF"
    },
    "RFC6455": {
        title:    "The WebSocket Protocol"
    ,   href:     "http://tools.ietf.org/html/rfc6455"
    ,   authors:  [
            "I. Fette"
        ,   "A. Melnikov"
        ]
    ,   status:   "December 2011. RFC"
    ,   publisher:  "IETF"
    },
    "RFC6544": {
        title:    "TCP Candidates with Interactive Connectivity Establishment (ICE)"
    ,   href:     "http://tools.ietf.org/html/rfc6544"
    ,   authors:  [
            "J. Rosenberg"
        ,   "A. Keranen"
        ,   "B. B. Lowekamp"
        ,   "A. B. Roach"
        ]
    ,   status:   "March 2012. RFC"
    ,   publisher:  "IETF"
    },
    "RFC6716": {
        title:    "Definition of the Opus Audio Codec"
    ,   href:     "http://tools.ietf.org/html/rfc6716"
    ,   authors:  [
            "JM. Valin",
            "K. Vos",
            "T. Terriberry"
        ]
    ,   status:   "September 2012. RFC"
    ,   publisher:  "IETF"
    },
    "RFC6904": {
        title:    "Encryption of Header Extensions in the SRTP"
    ,   href:     "http://tools.ietf.org/html/rfc6904"
    ,   authors:  [
            "J. Lennox"
        ]
    ,   status:   "April 2013. RFC"
    ,   publisher:  "IETF"
    },
    "RFC7064": {
        title:    "URI Scheme for Session Traversal Utilities for NAT (STUN) Protocol"
    ,   href:     "http://tools.ietf.org/html/rfc7064"
    ,   authors:  [
            "S. Nandakumar",
            "G. Salgueiro",
            "P. Jones",
            "M. Petit-Huguenin"
        ]
    ,   status:   "November 2013. RFC"
    ,   publisher:  "IETF"
    },
    "RFC7065": {
        title:    "Traversal Using Relays around NAT (TURN) Uniform Resource Identifiers"
    ,   href:     "http://tools.ietf.org/html/rfc7065"
    ,   authors:  [
            "M. Petit-Huguenin",
            "S. Nandakumar",
            "G. Salgueiro",
            "P. Jones"
        ]
    ,   status:   "November 2013. RFC"
    ,   publisher:  "IETF"
    },
    "BUNDLE": {
        title:    "Negotiating Media Multiplexing Using the Session Description Protocol (SDP)"
    ,   href:     "http://tools.ietf.org/html/draft-ietf-mmusic-sdp-bundle-negotation"
    ,   authors:  [
            "C. Holmberg",
            "H. Alvestrand",
            "C. Jennings"
        ]
    ,   status:   "23 April 2014. Internet Draft (work in progress)"
    ,   publisher:  "IETF"
    },
    "APPID": {
        title:    "The Session Description Protocol (SDP) Application Token Attribute"
    ,   href:     "http://tools.ietf.org/html/draft-even-mmusic-application-token" 
    ,   authors:  [
            "R. Even",
            "J. Lennox",
            "Q. Wu"
        ]
    ,   status:   "11 April 2014. Internet Draft (work in progress)"
    ,   publisher:  "IETF"
    },
    "DATA": {
        title:    "WebRTC Data Channels"
    ,   href:     "http://tools.ietf.org/html/draft-ietf-rtcweb-data-channel"
    ,   authors:  [
            "R. Jesup",
            "S. Loreto",
            "M. Tuexen"
        ]
    ,   status:   "09 April 2014. Internet Draft (work in progress)"
    ,   publisher:  "IETF"
    },
    "DATA-PROT": {
        title:    "WebRTC Data Channel Establishment Protocol"
    ,   href:     "http://tools.ietf.org/html/draft-ietf-rtcweb-data-protocol"
    ,   authors:  [
            "R. Jesup",
            "S. Loreto",
            "M. Tuexen"
        ]
    ,   status:   "09 April 2014. Internet Draft (work in progress)"
    ,   publisher:  "IETF"
    },
    "RTCWEB-SECURITY": {
        title:    "Security Considerations for WebRTC"
    ,   href:     "http://tools.ietf.org/html/draft-ietf-rtcweb-security"
    ,   authors:  [
            "E. Rescorla"
        ]
    ,   status:   "4 July 2014. Internet Draft (work in progress)"
    ,   publisher:  "IETF"
    },
    "RTCWEB-SECURITY-ARCH": {
        title:    "WebRTC Security Architecture"
    ,   href:     "http://tools.ietf.org/html/draft-ietf-rtcweb-security-arch"
    ,   authors:  [
            "E. Rescorla"
        ]
    ,   status:   "4 July 2014. Internet Draft (work in progress)"
    ,   publisher:  "IETF"
    },
    "RTCWEB-VIDEO": {
        title:    "WebRTC Video Processing and Codec Requirements"
    ,   href:     "http://tools.ietf.org/html/draft-ietf-rtcweb-video"
    ,   authors:  [
            "A.B. Roach"
        ]
    ,   status:   "1 July 2014. Internet Draft (work in progress)"
    ,   publisher:  "IETF"
    },
    "RTP-USAGE": {
        title:    "Web Real-Time Communication (WebRTC): Media Transport and Use of RTP"
    ,   href:     "http://tools.ietf.org/html/draft-ietf-rtcweb-rtp-usage"
    ,   authors:  [
            "C. Perkins"
        ,   "M. Westerlund"
        ,   "J. Ott"
        ]
    ,   status:   "28 May 2014. Internet Draft (work in progress)"
    ,   publisher:  "IETF"
    },
    "VP8-RTP": {
        title:    "RTP Payload Format for VP8 Video"
    ,   href:     "http://tools.ietf.org/html/draft-ietf-payload-vp8"
    ,   authors:  [
            "P. Westin",
            "H. Lundin",
            "M. Glover",
            "J. Uberti", 
            "F. Galligan"
        ]
    ,   status:   "10 February 2014. Internet Draft (work in progress)"
    ,   publisher:  "IETF"
    }
}
};
  </script>  
</head>
<body>

<section id="abstract">
<p>
This document defines a set of ECMAScript APIs in WebIDL to allow media to be sent and received
from another browser or device implementing the appropriate set of real-time protocols.  However,
unlike the WebRTC 1.0 API, Object Real-Time Communications (ORTC) API does not mandate a media signaling protocol or
format.  As a result, ORTC does not utilize Session Description Protocol (SDP), nor does it mandate support for
the Offer/Answer state machine.  
Instead, ORTC focuses on "sender", "receiver" and "transport" objects, which have
"capabilities" describing what they are capable of doing,
as well as "parameters" which define what they are configured to do.
"Tracks" and "data channels" are sent over the transports, between senders and receivers.
</p>
</section>

<section id='sotd'>
</section>

<section id="overview*">

  <h2><span class="secno"> </span>Overview</h2>

<p>Object Real-Time Communications (ORTC) provides a powerful API for the development of WebRTC based applications. 
ORTC does not mandate a media signaling protocol or format (as the current WebRTC 1.0 does by mandating SDP Offer/Answer). 
Instead, ORTC focuses on "sender", "receiver" and "transport" objects, which have 
"capabilities" describing what they are capable of doing, 
as well as "parameters" which define what they are configured to do. 
"Tracks" and "data channels" are sent over the transports, between senders and receivers.</p>
<p>This specification defines several objects: RTCDtlsTransport (<a href="#rtcdtlstransport*">Section 2</a>), 
RTCIceTransport (<a href="#rtcicetransport*">Section 3</a>), 
RTCIceTransportController (<a href="#rtcicetransportcontroller*">Section 4</a>), 
RTCIceListener (<a href="#rtcicelistener*">Section 5</a>), RTCRtpSender (<a href="#rtcrtpsender*">Section 6</a>), 
RTCRtpReceiver (<a href="#rtcrtpreceiver*">Section 7</a>), 
RTCRtpListener (<a href="#rtcrtplistener*">Section 8</a>),  
RTCDtmfSender (<a href="#rtcdtmfsender*">Section 10</a>), RTCDataChannel
(<a href="#rtcdatachannel*">Section 11</a>), and RTCSctpTransport (<a href="#sctp-transport*">Section 12</a>). 
RTP dictionaries are described in <a href="#rtcrtpdictionaries*">Section 9</a>,
the Statistics API is described in <a href="#statistics-api">Section 13</a>,
the Identity API is described in <a href="#identity-api">Section 14</a>,
an event summary is provided in <a href="#event-summary">Section 15</a>, 
and WebRTC 1.0 compatibility issues are discussed in <a href="#webrtc-compat*">Section 16</a>. 
</p>
<p>  
In a Javascript application utilizing the ORTC API,  
the relationship between the application and the objects, as well 
as between the objects themselves is shown below. 
Horizontal or slanted arrows denote the flow of media or data, 
whereas vertical arrows denote interactions via methods and events. 
</p>

<img alt="The non-normative ORTC Big Picture Diagram" src="ortc-big-picture.png" style="width:90%" />

  <section>
    <h3>Terminology</h3>

    <p>The <code><a href=
    "http://dev.w3.org/html5/spec/webappapis.html#eventhandler">EventHandler</a></code>
    interface represents a callback used for event handlers as defined in
    [[!HTML5]].</p>

    <p>The concepts <dfn><a href=
    "http://dev.w3.org/html5/spec/webappapis.html#queue-a-task">queue a
    task</a></dfn> and <dfn><a href=
    "http://dev.w3.org/html5/spec/webappapis.html#fire-a-simple-event">fires a
    simple event</a></dfn> are defined in [[!HTML5]].</p>

    <p>The terms <dfn>event</dfn>, <dfn><a href=
    "http://dev.w2.org/html5/spec/webappapis.html#event-handlers">event
    handlers</a></dfn> and <dfn><a href=
    "http://dev.w3.org/html5/spec/webappapis.html#event-handler-event-type">event
    handler event types</a></dfn> are defined in [[!HTML5]].</p>

    <p>The terms <dfn>MediaStream</dfn> and <dfn>MediaStreamTrack</dfn>
    are defined in
    [[!GETUSERMEDIA]].</p>

    <p>For Scalable Video Coding (SVC), the terms single-session transmission (<dfn>SST</dfn>) and multi-session transmission (<dfn>MST</dfn>)
    are defined in [[RFC6190]].  This specification only supports <a>SST</a> but not <a>MST</a>.  The term <dfn>SST-SS</dfn> refers to
    an SVC implementation that transmits all layers within a single RTP session, using a single SSRC. 
    The term <dfn>SST-MS</dfn> refers
    to an SVC implementation that transmits all layers within a single RTP session, using a distinct SSRC for each layer.</p>
  </section>
  </section>
<section id="rtcdtlstransport*">
  <h2>The RTCDtlsTransport Object</h2>

    <p>
The <dfn>RTCDtlsTransport</dfn> object includes information relating to Datagram Transport Layer Security (DTLS) transport. 
    </p>

  <section id="rtcdtlstransport-overview*">
    <h3>Overview</h3>

    <p>An <code><a>RTCDtlsTransport</a></code> instance is associated to an <code><a>RTCRtpSender</a></code>, 
    an <code><a>RTCRtpReceiver</a></code>, or an <code><a>RTCSctpTransport</a></code>.</p>
  </section>

  <section id="rtcdtlstransport-operation*">
    <h3>Operation</h3>

    <p>A <code><a>RTCDtlsTransport</a></code> instance is constructed with an <a>RTCIceTransport</a> 
       object.</p>

  </section>

  <section id="rtcdtlstransport-interface-definition*">
    <h3>Interface Definition</h3>

     <dl class="idl" title=
  "typedef (octet[]) ArrayBuffer">
        </dl>

    <dl class="idl" title="[Constructor(RTCIceTransport transport)] interface RTCDtlsTransport : RTCStatsProvider">
      <dt>readonly attribute RTCIceTransport transport</dt>
      <dd><p>The associated <code><a>RTCIceTransport</a></code> instance.</p></dd>

      <dt>readonly attribute RTCDtlsTransportState state</dt>
      <dd><p>The current state of the DTLS transport.</p></dd>

      <dt>RTCDtlsParameters getLocalParameters()</dt>
      <dd><p>Obtain the DTLS parameters of the local <code><a>RTCDtlsTransport</a></code>.</p></dd>

      <dt>RTCDtlsParameters? getRemoteParameters()</dt>
      <dd><p>Obtain the current DTLS parameters of the remote <code><a>RTCDtlsTransport</a></code>.</p></dd>

      <dt>sequence&lt;ArrayBuffer> getRemoteCertificates()</dt>
      <dd><p>Obtain the certificates used by the remote peer.</p></dd>

      <dt>void start(RTCDtlsParameters remoteParameters)</dt>
      <dd><p>Start DTLS transport negotiation with the parameters of the remote DTLS transport; 
      then once the DTLS transport session is established, negotiate a <dfn>DTLS-SRTP</dfn> [[!RFC5764]] session to protect media.
      Since symmetric RTP [[!RFC4961]] is utilized, the <a>DTLS-SRTP</a> session is bidirectional.
      If <code>remoteParameters</code> is invalid, throw an <code>InvalidParameter</code> exception.
      </p></dd>

      <dt>void stop()</dt>
      <dd><p>Stops and closes the DTLS transport object.  <code>stop()</code>. is final - calling <code>start()</code> afterwards
      will throw an <code>InvalidState</code> exception.</p></dd>

      <dt>attribute EventHandler? ondtlsstatechange</dt>
      <dd><p>This event handler, of event handler type <code>dtlsstatechange</code>
      uses the <code>RTCDtlsStateChangedEvent</code> interface.
      It <em class="rfc2119" title="MUST">MUST</em> be supported by 
      all objects implementing the <code><a>RTCDtlsTransport</a></code> interface.
      It is called any time the <var>RTCDtlsTransportState</var> changes.
      <p></dd>

      <dt>attribute EventHandler? onerror</dt>
      <dd><p>This event handler, of event handler type <code>error</code>, 
      <em class="rfc2119" title="MUST">MUST</em> be supported by all objects implementing the <code><a>RTCDtlsTransport</a></code> interface.
      This event <em class="rfc2119" title="MUST">MUST</em> be fired on reception of a DTLS alert.
      </p></dd>
    </dl>
  </section>

  <section id="rtcdtlsparameters*">
   <h3>The RTCDtlsParameters Object</h3>

   <p>
     The <dfn>RTCDtlsParameters</dfn> object includes information relating to DTLS configuration.
   </p>

    <dl class="idl" title="dictionary RTCDtlsParameters">
      <dt>RTCDtlsRole role="auto"</dt>
      <dd><p>The DTLS role, with a default of auto.</p></dd>
      <dt>sequence&lt;RTCDtlsFingerprint> fingerprints</dt>
      <dd><p>Sequence of fingerprints.</p></dd>
    </dl>

  <section id=rtcdtlsfingerprint*">
   <h3>The RTCDtlsFingerprint Object</h3>

   <p>
     The <dfn>RTCDtlsFingerprint</dfn> object includes the hash function algorithm and certificate fingerprint as described in [[!RFC4572]].
   </p>

    <dl class="idl" title="dictionary RTCDtlsFingerprint">
      <dt>DOMString algorithm</dt>
      <dd><p>One of the the hash function algorithms defined in the 'Hash function Textual Names' registry, initially specified in [[!RFC4572]] Section 8.</p></dd>
      <dt>DOMString value</dt>
      <dd><p>The value of the certificate fingerprint in lowercase hex string as expressed utilizing the syntax of 'fingerprint' in [[!RFC4572]] Section 5.</p></dd>
    </dl>
  </section>
 </section>

  <section id="rtcdtlsrole*">
    <h3>enum RTCDtlsRole</h3>
    <p><dfn>RTCDtlsRole</dfn> indicates the role of the DTLS transport.</p>
    <dl class="idl" title="enum RTCDtlsRole">
      <dt>auto</dt>
      <dd><p>The DTLS role is determined based on the resolved ICE role: the 
      'Controlled' role acts as the DTLS client, 
      the 'Controlling' role acts as the DTLS server.
      </p></dd>

      <dt>client</dt>
      <dd><p>The DTLS client role.</p></dd>

      <dt>server</dt>
      <dd><p>The DTLS server role.</p></dd>
    </dl>
  </section>

  <section id="rtcdtlstransportstate*">
    <h3>enum RTCDtlsTransportState</h3>
    <p><dfn>RTCDtlsTransportState</dfn> indicates the state of the DTLS transport. 
    </p>
    <dl class="idl" title="enum RTCDtlsTransportState">
      <dt>new</dt>
      <dd><p>The <code><a>RTCDtlsTransport</a></code> object has been created and has not started negotiating yet.</p></dd>

      <dt>connecting</dt>
      <dd><p>DTLS is in the process of negotiating a secure connection.</p></dd>

      <dt>connected</dt>
      <dd><p>DTLS has completed negotiation of a secure connection (including <a>DTLS-SRTP</a>).
      </p></dd>

      <dt>closed</dt>
      <dd><p>The DTLS connection has been closed intentionally or as the result of an error.</p></dd>
    </dl>
  </section>

  <section id="rtcdtlstransportstatechangedevent-interface-definition*">
      <h3>RTCDtlsTransportStateChangedEvent</h3>

        <p>The <code>dtlsstatechange</code> event of the <code><a>RTCDtlsTransport</a></code> object uses
        the <code><a>RTCDtlsTransportStateChangedEvent</a></code> interface.</p>

        <p><dfn title="Fire a DTLS transport state changed event">Firing an
        <code><a>RTCDtlsTransportStateChangedEvent</a></code> event named
        <var>e</var></dfn> with an <code><a>RTCDtlsTransportState</a></code>
        <var>state</var> means that an event with the name <var>e</var>,
        which does not bubble (except where otherwise stated) and is not
        cancelable (except where otherwise stated), and which uses the
        <code>RTCDtlsTransportStateChangedEvent</code> interface with the
        <code>state</code> attribute set to the new <var>RTCDtlsTransportState</var>, 
        <em class="rfc2119" title="MUST">MUST</em> be
        created and dispatched at the given target.</p>

        <dl class="idl" data-merge="RTCDtlsTransportStateChangedEventInit" title=
        "[Constructor(DOMString type, RTCDtlsTransportStateChangedEventInit eventInitDict)] interface RTCDtlsTransportStateChangedEvent : Event">

          <dt>readonly attribute RTCDtlsTransportState state</dt>

          <dd>
            <p>The <code>state</code> attribute is the new
            <code><a>RTCDtlsTransportState</a></code>  
            that caused the event.
          </p>
          </dd>
        </dl>

        <dl class="idl" title=
        "dictionary RTCDtlsTransportStateChangedEventInit : EventInit">
          <dt>RTCDtlsTransportState? state</dt>
          <dd>
            <p>The <code>state</code> attribute is the new
            <code><a>RTCDtlsTransportState</a></code>
            that caused the event.
          </p>
          </dd>
        </dl>
      </section>
</section>

<section id="rtcicetransport*">
  <h2>The RTCIceTransport Object</h2>

    <p>
      The <dfn>RTCIceTransport</dfn> includes information relating to Interactive Connectivity Establishment (ICE).
    </p>

  <section id="rtcicetransport-overview*">
    <h3>Overview</h3>

    <p>An <code><a>RTCIceTransport</a></code> instance is associated to a transport object (such as <code><a>RTCDtlsTransport</a></code>), 
       and provides RTC related methods to it.  
    </p>
  </section>

  <section id="rtcicetransport-operation*">
    <h3>Operation</h3>

    <p>An <code><a>RTCIceTransport</a></code> instance is constructed without any arguments.</p>
  </section>

  <section id="rtcicetransport-interface-definition*">
    <h3>Interface Definition</h3>

    <dl class="idl" title="[Constructor()] interface RTCIceTransport: RTCStatsProvider"> 
      <dt>readonly attribute RTCIceListener? iceListener</dt>
      <dd><p>
      The <var>iceListener</var> is set to the value of <var>listener</var> passed in the latest call to <code>start()</code>. 
      </p></dd>
      <dt>readonly attribute RTCIceRole role</dt>
      <dd><p>The current role of the ICE transport.</p></dd>
      <dt>readonly attribute RTCIceComponent component</dt>
      <dd><p>The component-id of the <code><a>RTCIceTransport</a></code>.</p></dd>
      <dt>readonly attribute RTCIceTransportState state</dt>
      <dd><p>The current state of the ICE transport.</p></dd>
      <dt>sequence&lt;RTCIceCandidate> getRemoteCandidates()</dt>
      <dd><p>Retrieve the sequence of candidates associated with the remote 
      <code><a>RTCIceTransport</a></code>.  Only returns the candidates previously
      added using <code>setRemoteCandidates</code> or <code>addRemoteCandidate</code>.</p></dd>

      <dt>RTCIceCandidatePair? getNominatedCandidatePair()</dt>
      <dd><p>Retrieves the nominated candidate pair.  If there is no nominated pair yet, NULL is returned.</p></dd>

      <dt>void start(RTCIceListener listener, RTCIceParameters remoteParameters, optional RTCIceRole role)</dt>
      <dd><p>The first time <code>start</code> is called candidate connectivity checks are started and the ICE transport attempts to connect to the remote 
      <code><a>RTCIceTransport</a></code>.  
      If <code>start</code> is called with invalid parameters,
      throw an <code>InvalidParameters</code> exception.
      If <code>start</code> is called again, an ICE restart occurs, all remote candidates are flushed, and <code>addRemoteCandidates</code> or
      <code>setRemoteCandidates</code> must be called to add the remote candidates back or replace them.
      </p></dd>

      <dt>void stop()</dt>
      <dd><p>Stops and closes the current object.  Also removes the object from the <code><a>RTCIceTransportController</a></code>.</p></dd>

      <dt>RTCIceParameters? getRemoteParameters()</dt>
      <dd><p>Obtain the current ICE parameters of the remote <code><a>RTCIceTransport</a></code>.</p></dd>

      <dt>RTCIceTransport createAssociatedTransport ()</dt>
      <dd><p>Create an associated <code><a>RTCIceTransport</a></code> for RTCP.
      If called more than once for the same   
      component, throw an <code>InvalidStateError</code>  exception.  If called when 
      <var>component</var> is "RTCP",
      throw a <code>SyntaxError</code> exception. 
      </p></dd>

      <dt>void addRemoteCandidate(RTCIceGatherCandidate remoteCandidate)</dt>
      <dd><p>Add remote candidate associated with remote <code><a>RTCIceTransport</a></code>.</p></dd>

      <dt>void setRemoteCandidates(sequence&lt;RTCIceCandidate> remoteCandidates)</dt>
      <dd><p>Set the sequence of candidates associated with the remote <code><a>RTCIceTransport</a></code>.</p></dd>

      <dt>attribute EventHandler? onicestatechange</dt>
      <dd><p>This event handler, of event handler type <code>icestatechange</code>, 
      uses the <code>RTCIceTransportStateChangedEvent</code> interface.
      It <em class="rfc2119" title="MUST">MUST</em> be supported by
      all objects implementing the <code><a>RTCIceTransport</a></code> interface.
      It is called any time the <code><a>RTCIceTransportState</a></code> changes.
      <p></dd>

      <dt>attribute EventHandler? oncandidatepairchange</dt>
      <dd><p>This event handler, of event handler type <code>icecandidatepairchange</code>,
      uses the <code>RTCIceCandidatePairChangedEvent</code> interface.
      It <em class="rfc2119" title="MUST">MUST</em> be supported by
      all objects implementing the <code><a>RTCIceTransport</a></code> interface.
      It is called any time the nominated <code><a>RTCIceCandidatePair</a></code> changes.
      <p></dd>
    </dl>
  </section>

  <section id="rtcicecomponent*">
    <h3>enum RTCIceComponent</h3>
    <p><dfn>RTCIceComponent</dfn> contains the component-id of the <code><a>RTCIceTransport</a></code>, which will be "RTP" unless RTP and RTCP are not multiplexed and
      the <code><a>RTCIceTransport</a></code> object was returned by <code>createAssociatedTransport()</code>.</p>
    <dl class="idl" title="enum RTCIceComponent">
      <dt>RTP</dt>
      <dd><p>The RTP component ID, defined (as '1') in [[!RFC5245]] Section 4.1.1.1.
      Protocols multiplexed with RTP (e.g. SCTP data channel) share its component ID. 
      </p></dd>
      <dt>RTCP</dt>
      <dd><p>The RTCP component ID, defined (as '2') in [[!RFC5245]] Section 4.1.1.1.</p></dd>
    </dl>
  </section>

  <section id="rtciceparameters*">
   <h3>The RTCIceParameters Object</h3>

   <p>
     The <dfn>RTCIceParameters</dfn> object includes the ICE username and password.
   </p>

    <dl class="idl" title="dictionary RTCIceParameters">
      <dt>DOMString usernameFragment</dt>
      <dd><p>ICE username.</p></dd>
      <dt>DOMString password</dt>
      <dd><p>ICE password.</p></dd>
    </dl>
  </section>

  <section id="rtcicerole*">
    <h3>enum RTCIceRole</h3>
    <p><dfn>RTCIceRole</dfn> contains the current role of the ICE transport.</p>
    <dl class="idl" title="enum RTCIceRole">
      <dt>controlling</dt>
      <dd><p>controlling state</p></dd>

      <dt>controlled</dt>
      <dd><p>controlled state</p></dd>
    </dl>
  </section>

  <section id="rtcicetransportstate*">
    <h3>enum RTCIceTransportState</h3>
    <p><dfn>RTCIceTransportState</dfn> represents the current state of the ICE transport.</p>
    <dl class="idl" title="enum RTCIceTransportState">
      <dt>new</dt>
      <dd><p>The ICE Transport is gathering addresses and/or waiting for remote candidates to be supplied.</p></dd>

      <dt>checking</dt>
      <dd><p>The ICE Transport has received at least one remote candidate, and is checking candidate pairs but has not yet found a connection. In addition to checking, it may also still be gathering.</p></dd>

      <dt>connected</dt>
      <dd><p>The ICE Transport has found a usable connection, but is still checking other candidate pairs to see if there is a better connection. It may also still be gathering.</p></dd>

      <dt>completed</dt>
      <dd><p>
      The ICE Transport has finished gathering and checking and found a connection.
      </p></dd>
      <dt>disconnected</dt>
      <dd><p>Liveness checks have failed.  This may trigger intermittently (and resolve 
      itself without action).
      </p></dd>

      <dt>closed</dt>
      <dd><p>The ICE Transport has shut down and is no longer responding to STUN requests.</p></dd>
    </dl>

<p>The non-normative ICE state transitions are:</p>

<img alt="The non-normative ICE State Transition Diagram" src="icestates.png" style="width:75%" />
</section>

  <section id="rtcicetransportstatechangedevent-interface-definition*">
      <h3>RTCIceTransportStateChangedEvent</h3>

        <p>The <code>icestatechange</code> event of the <code><a>RTCIceTransport</a></code> object uses
        the <code><a>RTCIceTransportStateChangedEvent</a></code> interface.</p>

        <p><dfn title="Fire an ICE transport state changed event">Firing an
        <code><a>RTCIceTransportStateChangedEvent</a></code> event named
        <var>e</var></dfn> with an <code><a>RTCIceTransportState</a></code>
        <var>state</var> means that an event with the name <var>e</var>,
        which does not bubble (except where otherwise stated) and is not
        cancelable (except where otherwise stated), and which uses the
        <code>RTCIceTransportStateChangedEvent</code> interface with the
        <code>state</code> attribute set to the new <var>RTCIceTransportState</var>, 
        <em class="rfc2119" title="MUST">MUST</em> be
        created and dispatched at the given target.</p>

        <dl class="idl" data-merge="RTCIceTransportStateChangedEventInit" title=
        "[Constructor(DOMString type, RTCIceTransportStateChangedEventInit eventInitDict)] interface RTCIceTransportStateChangedEvent : Event">

          <dt>readonly attribute RTCIceTransportState state</dt>

          <dd>
            <p>The <code>state</code> attribute is the new
            <code><a>RTCIceTransportState</a></code>  
            that caused the event.
          </p>
          </dd>
        </dl>

        <dl class="idl" title=
        "dictionary RTCIceTransportStateChangedEventInit : EventInit">
          <dt>RTCIceTransportState? state</dt>
          <dd>
            <p>The <code>state</code> attribute is the new
            <code><a>RTCIceTransportState</a></code>
            that caused the event.
          </p>
          </dd>
        </dl>
      </section>

  <section id="rtcicecandidatepairchangedevent-interface-definition*">
      <h3>RTCIceCandidatePairChangedEvent</h3>

        <p>The <code>icecandidatepairchange</code> event of the <code><a>RTCIceTransport</a></code> object uses
        the <code><a>RTCIceCandidatePairChangedEvent</a></code> interface.</p>

        <p><dfn title="Fire an ICE candidate pair changed event">Firing an
        <code><a>RTCIceCandidatePairChangedEvent</a></code> event named
        <var>e</var></dfn> with an <code><a>RTCIceCandidatePair</a></code>
        <var>pair</var> means that an event with the name <var>e</var>,
        which does not bubble (except where otherwise stated) and is not
        cancelable (except where otherwise stated), and which uses the
        <code>RTCIceCandidatePairChangedEvent</code> interface with the
        <code>pair</code> attribute set to the nominated <var>RTCIceCandidatePair</var>,
        <em class="rfc2119" title="MUST">MUST</em> be
        created and dispatched at the given target.</p>

        <dl class="idl" data-merge="RTCIceCandidatePairChangedEventInit" title=
        "[Constructor(DOMString type, RTCIceCandidatePairChangedEventInit eventInitDict)] interface RTCIceCandidatePairChangedEvent : Event">

          <dt>readonly attribute RTCIceCandidatePair pair</dt>

          <dd>
            <p>The <code>pair</code> attribute is the nominated
            <code><a>RTCIceCandidatePair</a></code>
            that caused the event.
          </p>
          </dd>
        </dl>

        <dl class="idl" title=
        "dictionary RTCIceCandidatePairChangedEventInit : EventInit">
          <dt>RTCIceCandidatePair pair</dt>
          <dd>
            <p>The <code>pair</code> attribute is the nominated
            <code><a>RTCIceCandidatePair</a></code>
            that caused the event.
          </p>
          </dd>
        </dl>
      </section>

  <section id="rtciceserver*">
   <h3>The RTCIceServer Object</h3>

   <p>
    The <dfn>RTCIceServer</dfn> is used to provide STUN or TURN server configuration. 
    In network topologies with multiple layers of NATs, it is desirable to have a STUN server 
    between every layer of NATs in addition to the TURN servers to minimize the peer to peer network latency.
   <p>

   </p>
     An example of an array of <code<<a>RTCIceServer</a></code> objects:
   </p>

    <pre class="example"><code class="javascript">
      [ { urls: "stun:stun1.example.net } , { urls:"turn:turn.example.org", username: "user", credential:"myPassword"} ]
    </code></pre>

    <dl class="idl" title="dictionary RTCIceServer">
      <dt>(DOMString or sequence&lt;DOMString>) urls</dt>
      <dd><p>STUN or TURN URI(s) as defined in [[!RFC7064]] and [[!RFC7065]]</p></dd>
      <dt>DOMString username</dt>
      <dd><p>If this <code<<a>RTCIceServer</a></code> object represents a TURN server, then this attribute specifies 
          the username to use with that TURN server.</p></dd>
      <dt>DOMString credential</dt>
      <dd><p>If the uri element is a TURN URI, then this is the credential to use with that TURN server.</p></dd>
    </dl>

  </section>

  <section id="rtcicecandidate*">
    <h3>The RTCIceCandidate Object</h3>

    <p>
      The <dfn>RTCIceCandidate</dfn> object includes information relating to an ICE candidate.
    </p>

    <pre class="example"><code class="javascript">{
  foundation: "abcd1234",
  priority: 1694498815,
  ip: "192.0.2.33",
  protocol: "udp",
  port: 10000,
  type: "host"
};
    </code></pre>

     <dl class="idl" title="typedef (RTCIceCandidate or RTCIceCandidateComplete) RTCIceGatherCandidate">
     </dl>

    <dl class="idl" title="dictionary RTCIceCandidate">
      <dt>DOMString foundation</dt>
      <dd>
        <p>A unique identifier that allows ICE to correlate candidates that appear on multiple <code><a>RTCIceTransport</a></code>s.</p>
      </dd>
      <dt>unsigned long priority</dt>
      <dd><p>The assigned priority of the candidate.  This is automatically populated by the browser.</p></dd>
      <dt>DOMString ip</dt>
      <dd><p>The IP address of the candidate.</p></dd>
      <dt>RTCIceProtocol protocol</dt>
      <dd><p>The protocol of the candidate (UDP/TCP).</p></dd>
      <dt>unsigned short port</dt>
      <dd><p>The port for the candidate.</p></dd>
      <dt>RTCIceCandidateType type</dt>
      <dd><p>The type of candidate.</p></dd>
      <dt>RTCIceTcpCandidateType tcpType</dt>
      <dd><p>The type of TCP candidate.</p></dd>
      <dt>DOMString relatedAddress=""</dt>
      <dd>
        <p>For candidates that are derived from others, such as relay or reflexive candidates, the <dfn>relatedAddress</dfn>
        refers to the host candidate that these are derived from.  For host candidates, the <var>relatedAddress</var>
        is set to the empty string.</p>
      </dd>
      <dt>unsigned short relatedPort</dt>
      <dd>
        <p>For candidates that are derived from others, such as relay or reflexive candidates, the <dfn>relatedPort</dfn>
        refers to the host candidate that these are derived from.  For host candidates, the <var>relatedPort</var>
        is null.</p> 
      </dd>
    </dl>

    <section>
      <h4>The RTCIceProtocol</h4>
      <p>
        The <dfn>RTCIceProtocol</dfn> includes the protocol of the ICE candidate.
      </p>
      <dl class="idl" title="enum RTCIceProtocol">
        <dt>udp</dt>
        <dd><p>A UDP candidate, as described in [[!RFC5245]].</p></dd> 
        <dt>tcp</dt>
        <dd><p>A TCP candidate, as described in [[!RFC6544]].</p></dd>
      </dl>
    </section>

    <section>
      <h4>The RTCIceTcpCandidateType</h4>
      <p>
        The <dfn>RTCIceTcpCandidateType</dfn> includes the type of the ICE TCP candidate, as described in [[!RFC6544]].
      </p>
      <dl class="idl" title="enum RTCIceTcpCandidateType">
        <dt>active</dt>
        <dd><p>An active TCP candidate is one for which the transport will
   attempt to open an outbound connection but will not receive incoming
   connection requests.</p></dd>
        <dt>passive</dt>
        <dd><p>A passive TCP candidate is one for which the transport
   will receive incoming connection attempts but not attempt a
   connection.</p></dd>
        <dt>so</dt>
        <dd><p>An so candidate is one for which the transport will attempt
   to open a connection simultaneously with its peer.</p></dd>
      </dl>
    </section>

    <section>
      <h4>The RTCIceCandidateType</h4>
      <p>
        The <dfn>RTCIceCandidateType</dfn> includes the type of the ICE candidate.
      </p>
      <dl class="idl" title="enum RTCIceCandidateType">
        <dt>host</dt>
        <dd><p>A host candidate.</p></dd>
        <dt>srflx</dt>
        <dd><p>A server reflexive candidate.</p></dd>
        <dt>prflx</dt>
        <dd><p>A peer reflexive candidate.</p></dd>
        <dt>relay</dt>
        <dd><p>A relay candidate.</p></dd>
      </dl>
    </section>
  </section>

  <section id="rtcicecandidatecomplete*">
   <h3>dictionary RTCIceCandidateComplete</h3>

   <p>
    The <dfn>RTCIceCandidateComplete</dfn> is an empty dictionary signifying that all <code>RTCIceCandidate</code>s are gathered. 
   <p>

    <dl class="idl" title="dictionary RTCIceCandidateComplete">
    </dl>
  </section>

  <section id="rtcicecandidatepair*">
   <h3>dictionary RTCIceCandidatePair</h3>

   <p>
    The <dfn>RTCIceCandidatePair</dfn> contains the currently selected ICE candidate pair.
   <p>

    <dl class="idl" title="dictionary RTCIceCandidatePair">
      <dt>RTCIceCandidate local</dt>
      <dd><p>The local ICE candidate.</p></dd>
      <dt>RTCIceCandidate remote</dt>
      <dd><p>The remote ICE candidate.</p></dd>
    </dl>

  </section>

      <section>
        <h4>RTCIceTransportEvent</h4>

        <p>The <code>icecandidate</code> event of the <code><a>RTCIceTransport</a></code> and <code><a>RTCIceListener</a></code> objects uses
        the <code><a>RTCIceTransportEvent</a></code> interface.</p>
        <p><dfn title="Fire an ice candidate event">Firing an
        <code><a>RTCIceTransportEvent</a></code> event named
        <var>e</var></dfn> with an <code><a>RTCIceGatherCandidate</a></code>
        <var>candidate</var> means that an event with the name <var>e</var>,
        which does not bubble (except where otherwise stated) and is not
        cancelable (except where otherwise stated), and which uses the
        <code>RTCIceTransportEvent</code> interface with the
        <code>candidate</code> attribute set to the new ICE candidate, 
       <em class="rfc2119" title="MUST">MUST</em> be
        created and dispatched at the given target.</p>

        <dl class="idl" data-merge="RTCIceTransportEventInit" title=
        "[Constructor(DOMString type, RTCIceTransportEventInit eventInitDict)] interface RTCIceTransportEvent : Event">

          <dt>readonly attribute RTCIceGatherCandidate candidate</dt>

          <dd>
            <p>The <code>candidate</code> attribute is the
            <code><a>RTCIceGatherCandidate</a></code> object with the new ICE
            candidate that caused the event.
             If <code>candidate</code> is of type <code>RTCIceCandidateComplete</code>, 
             there are no additional candidates.
          </p>
          </dd>
        </dl>

        <dl class="idl" title=
        "dictionary RTCIceTransportEventInit : EventInit">
          <dt>RTCIceGatherCandidate candidate</dt>
          <dd>
            <p>The ICE candidate that caused the event.</p>
          </dd>
        </dl>
      </section>

  <section id="rtcicetransport-example1*">
    <h3>Examples</h3>

    <pre class="example"><code class="javascript">

// Assume we already have a way to signal. This is an example
// of  how to offer ICE and DTLS parameters and ICE candidates and
// get back ICE and DTLS parameters and ICE candidates, and start
// both ICE and DTLS, assuming that RTP and RTCP are multiplexed. 

function initiate(mySignaller) {
 var gatherOptions = new RTCIceGatherOptions;
 gatherOptions.gatherPolicy = RTCIceGatherPolicy.all; 
 gatherOptions.iceservers = ... ;
 var iceListener = new RTCIceListener(gatherOptions); 
 var ice = new RTCIceTransport();
 var dtls = new RTCDtlsTransport(ice);
 // ... get tracks and RTP objects from other example

 mySignaller.mySendInitiate({
   "ice": iceListener.getLocalParameters(), 
   "dtls": dtls.getLocalParameters(), 
   // ... include RTP info from other example
 }, function(remote) {
   // Start the ICE transport
   ice.start(iceListener, remote.ice, RTCIceRole.controlling);
   dtls.start(remote.dtls);
   // ... start RTP senders and receivers from other example
 });

 iceListener.onlocalcandidate = function(candidate) {
   mySignaller.mySendLocalCandidate(candidate);
 }

 mySignaller.onRemoteCandidate = function(candidate) {
   ice.addRemoteCandidate(candidate);
 }
}

    </code></pre>

    <pre class="example"><code class="javascript">

// Assume we already have a way to signal and remote info is 
// signalled to us.  This is an example of how to answer with ICE and DTLS
// and DTLS parameters and ICE candidates and start both ICE and DTLS,
// assuming that RTP and RTCP are multiplexed.
//
function accept(mySignaller, remote) {
 var gatherOptions = new RTCIceGatherOptions;
 gatherOptions.gatherPolicy = RTCIceGatherPolicy.all;
 gatherOptions.iceservers = ... ;
 var iceListener = new RTCIceListener(gatherOptions);
 var ice = new RTCIceTransport();
 var dtls = new RTCDtlsTransport(ice);
 // ... get tracks and RTP objects from other example
 iceListener.onlocalcandidate = function(candidate) {
   mySignaller.mySendLocalCandidate(candidate);
 }

 mySignaller.onRemoteCandidate = function(candidate) {
   ice.addRemoteCandidate(candidate);
 }

 mySignaller.mySendAccept({
   "ice": iceListener.getLocalParameters(),
   "dtls": dtls.getLocalParameters()
   // ... include RTP info from other example
 });
 // Start the ICE transport with an implicit gather policy of "all"
 ice.start(iceListener,remote.ice, RTCIceRole.controlled);
 dtls.start(remote.dtls);

 // ... start RTP senders and receivers from other example
}

    </code></pre>
</section>
</section>

<section id="rtcicetransportcontroller*">
  <h2>The RTCIceTransportController Object</h2>

    <p>
    The <dfn>RTCIceTransportController</dfn> object assists in the managing of ICE freezing and bandwidth estimation.
    </p>

  <section id="rtctransportcontroller-overview*">
    <h3>Overview</h3>

    <p>An <code><a>RTCIceTransportController</a></code> object provides methods to add and retrieve <code><a>RTCIceTransport</a></code> objects with a <var>component</var> of "RTP".</p>
  </section>

  <section id="rtctransportcontroller-operation*">
    <h3>Operation</h3>

   <p>An <code><a>RTCIceTransportController</a></code> instance is automatically constructed.</p>
  </section>

  <section id="rtcicetransportcontroller-interface-definition*">
    <h3>Interface Definition</h3>

    <dl class="idl" title="[Constructor()] interface RTCIceTransportController">
      <dt>sequence&lt;RTCIceTransport> getTransports()</dt>
      <dd>
        <p>Returns the <code><a>RTCIceTransport</a></code> objects with a <var>component</var> 
      of "RTP".</p>
      </dd>
      <dt>void addTransport(RTCIceTransport transport, optional unsigned long index)</dt>
      <dd>
      <p>Adds <var>transport</var> to the <code><a>RTCIceTransportController</a></code> 
      object for the purposes of managing
      ICE freezing and sharing bandwidth estimation.
      Since <code>addTransport</code> manages ICE freezing, candidate pairs that are not in the
      frozen state maintain their state when <code>addTransport(transport)</code> is called. 
      <code><a>RTCIceTransport</a></code> objects will be unfrozen
      according to their <var>index</var>.  <var>transport</var> is inserted at <var>index</var>,
      or at the end if <var>index</var> is not specified.
      If <var>index</var> is greater than the current number of <code><a>RTCIceTransport</a></code>s 
      with a <var>component</var> of "RTP", 
      throw an <code>InvalidParameter</code> exception. 
      If <var>transport</var> has already been added to another
      <code><a>RTCIceTransportController</a></code> object, or if
      the <var>component</var> is "RTCP", throw an <code>InvalidStateError</code> exception.
      </p></dd>
    </dl>
  </section>

  <section id="rtcicetransportcontroller-example1*">
    <h3>Examples</h3>

    <pre class="example"><code class="javascript">
// This is an example of how to utilize distinct ICE transports for Audio and Video 
// As well as for RTP and RTCP.  If both sides can multiplex audio/video
// and/or RTP/RTCP then the multiplexing will occur.
//
// Assume we have an audioTrack and a videoTrack to send.
//
//create the RTP and RTCP ICE listeners for audio and video
var gatherOptions = new RTCIceGatherOptions;
gatherOptions.gatherPolicy = RTCIceGatherPolicy.all;
gatherOptions.iceservers = ... ;
var audioRtpIceListener = new RTCIceListener(gatherOptions);
var audioRtcpIceListener = new RTCIceListener(gatherOptions);
var videoRtpIceListener = new RTCIceListener(gatherOptions);
var videoRtcpIceListener = new RTCIceListener(gatherOptions);
//create the RTP and RTCP ICE transports for audio and video
var audioRtpIceTransport = new RTCIceTransport();
var audioRtcpIceTransport = audioRtpIceTransport.createAssociatedTransport();
var videoRtpIceTransport = new RTCIceTransport();
var videoRtcpIceTransport = audioRtpIceTransport.createAssociatedTransport();
//
// Prepare the audio and video ICE transports
audioRtpIceListener.onlocalcandidate = function (event)  {sendLocalCandidate(audioRtpIceTransport, event.candidate,"audio")};
audioRtcpIceListener.onlocalcandidate = function (event) {sendLocalCandidate(audioRtcpIceTransport, event.candidate,"audio")};
videoRtpIceListener.onlocalcandidate = function (event)  {sendLocalCandidate(videoRtpIceTransport, event.candidate,"video")};
videoRtcpIceListener.onlocalcandidate = function (event) {sendLocalCandidate(videoRtcpIceTransport, event.candidate,"video")};
audioRtpIceTransport.onicestatechange = ... ;
audioRtpIceListener.onerror = errorHandler;
audioRtcpIceTransport.onicestatechange = ... ;
audioRtcpIceListener.onerror = errorHandler;
videoRtpIceTransport.onicestatechange = ... ; 
videoRtpIceListener.onerror = errorHandler;
videoRctpIceTransport.onicestatechange = ... ; 
videoRctpIceListener.onerror = errorHandler;
//Prepare the remote candidate handler
mySignaller.onRemoteCandidate = function(remote) {
   switch (remote.kind) {
      case "audio":
        if (remote.component === RTCIceComponent.RTP){
           audioRtpIceTransport.addRemoteCandidate(remote.candidate);
        } else {
           audioRtcpIceTransport.addRemoteCandidate(remote.candidate);
        };
        break;
      case "video":
        if (remote.component === RTCIceComponent.RTP){
           videoRtpIceTransport.addRemoteCandidate(remote.candidate);
        } else {
           videoRtcpIceTransport.addRemoteCandidate(remote.candidate);
        };
        break;
      default:
         log('Invalid media type received');
   };
}
// Create the DTLS transports
var audioRtpDtlsTransport = new RTCDtlsTransport(audioRtpIceTransport);
var audioRtcpDtlsTransport = new RTCDtlsTransport(audioRtcpIceTransport);
var videoRtpDtlsTransport = new RTCDtlsTransport(videoRtpIceTransport);
var videoRtcpDtlsTransport = new RTCDtlsTransport(videoRtcpIceTransport); 
//
// Create the sender and receiver objects
var audioSender = new RtpSender(audioTrack, audioRtpDtlsTransport, audioRtcpDtlsTransport);
var videoSender = new RtpSender(videoTrack, videoRtpDtlsTransport, videoRtcpDtlsTransport);
var audioReceiver = new RtpReceiver(audioRtpDtlsTransport, audioRtcpDtlsTransport);
var videoReceiver = new RtpReceiver(videoRtpDtlsTransport, videoRtcpDtlsTransport);
//
// Retrieve the receiver and sender capabilities
var recvAudioCaps = RTCRtpReceiver.getCapabilities("audio"); 
var recvVideoCaps = RTCRtpReceiver.getCapabilities("video"); 
var sendAudioCaps = RTCRtpSender.getCapabilities("audio");
var recvVideoCaps = RTCRtpSender.getCapabilities("video"); 
//
// At this point, ICE/DTLS parameters and Send/Receive capabilities can be exchanged.
mySignaller.myOfferTracks({
   // Indicate that the initiator would prefer to multiplex both A/V and RTP/RTCP
   "bundle": true,
   // Indicate that the initiator is willing to multiplex RTP/RTCP without A/V mux
   "rtcpMux": true,
   // Offer the ICE parameters
   "audioRtpIce": audioRtpIceListener.getLocalParameters(),
   "audioRtcpIce": audioRtcpIceListener.getLocalParameters(),
   "videoRtpIce": videoRtpIceListener.getLocalParameters(),
   "videoRtcpIce": videoRtcpIceListener.getLocalParameters(),
   // Offer the DTLS parameters
   "audioRtpDtls": audioRtpDtlsTransport.getLocalParameters(),
   "audioRtcpDtls": audioRtcpDtlsTransport.getLocalParameters(),
   "videoRtpDtls": videoRtpDtlsTransport.getLocalParameters(),
   "videoRtcpDtls": videoRtcpDtlsTransport.getLocalParameters(),
   // Offer the receiver and sender audio and video capabilities.
   "recvAudioCaps": recvAudioCaps, 
   "recvVideoCaps": recvVideoCaps,
   "sendAudioCaps": sendAudioCaps,
   "sendVideoCaps": sendVideoCaps 
  }, function(answer) {
   // The responder answers with its preferences, parameters and capabilities
   //
   // Derive the send and receive parameters, assuming that RTP/RTCP mux will be enabled.
   var audioSendParams = myCapsToSendParams(sendAudioCaps, answer.recvAudioCaps); 
   var videoSendParams = myCapsToSendParams(sendVideoCaps, answer.recvVideoCaps); 
   var audioRecvParams = myCapsToRecvParams(recvAudioCaps, answer.sendAudioCaps);
   var videoRecvParams = myCapsToRecvParams(recvVideoCaps, answer.sendVideoCaps); 
   //
   // If the responder wishes to enable bundle, we will enable it
     if (answer.bundle) {
        // Only start the single ICE and DTLS transport that is needed.
        // No need for the ICE Transport Controller. 
        audioRtpIceTransport.start(audioRtpIceListener,answer.audioRtpIce, RTCIceRole.controlling);   
        audioRtpDtlsTransport.start(remote.audioRtpDtls); 
        // 
        // Replace the transport on the Sender and Receiver objects
        //
        audioSender.setTransport(audioRtpDtlsTransport); 
        videoSender.setTransport(audioRtpDtlsTransport); 
        audioReceiver.setTransport(audioRtpDtlsTransport); 
        videoReceiver.setTransport(audioRtpDtlsTransport); 
        // If BUNDLE was requested, then also assume RTP/RTCP mux 
        answer.rtcpMux = true;  
      } else {
        if (answer.rtcpMux){
         // The peer doesn't want BUNDLE, but it does want to multiplex RTP/RTCP
         // Create the ICE Transport Controller object
         var controller = new RTCIceTransportController();
         controller.addTransport(audioRtpIceTransport);
         controller.addTransport(videoRtpIceTransport);
         // Start the audio and video ICE transports, with an implicit gather policy of "all"
         audioRtpIceTransport.start(audioRtpIceListener,answer.audioRtpIce, RTCIceRole.controlling);
         videoRtpIceTransport.start(videoRtpIceListener,answer.videoRtpIce, RTCIceRole.controlling);
         // Start the audio and video DTLS transports
         audioRtpDtlsTransport.onerror = errorHandler; 
         audioRtpDtlsTransport.start(answer.audioRtpDtls);
         videoRtpDtlsTransport.onerror = errorHandler;
         videoRtpDtlsTransport.start(answer.videoRtpDtls);
         // Replace the transport on the Sender and Receiver objects
         //
         audioSender.setTransport(audioRtpDtlsTransport);
         videoSender.setTransport(videoRtpDtlsTransport);
         audioReceiver.setTransport(audioRtpDtlsTransport);
         videoReceiver.setTransport(videoRtpDtlsTransport);
      };
      // Check if the responder does not want BUNDLE
      // and does not want RTP/RTCP multiplexing
      if (!answer.rtcpMux) {
         // Create the ICE Transport Controller object
         var controller = new RTCIceTransportController();
         controller.addTransport(audioRtpIceTransport);
         controller.addTransport(videoRtpIceTransport);
         controller.addTransport(audioRtcpIceTransport);
         controller.addTransport(videoRtcpIceTransport);
         // Start the ICE transports
         audioRtpIceTransport.start(audioRtpIceListener,answer.audioRtpIce, RTCIceRole.controlling); 
         audioRtcpIceTransport.start(audioRtcpIceListener,answer.audioRtcpIce, RTCIceRole.controlling); 
         videoRtpIceTransport.start(videoRtpIceListener,answer.videoRtpIce, RTCIceRole.controlling); 
         videoRtcpIceTransport.start(videoRtcpIceListener,answer.videoRtcpIce, RTCIceRole.controlling);
         // Start the DTLS transports that are needed 
         audioRtpDtlsTransport.start(answer.audioRtpDtls);
         audioRtcpDtlsTransport.start(answer.audioRtcpDtls);
         videoRtpDtlsTransport.start(answer.videoRtpDtls);
         videoRtcpDtlsTransport.start(answer.videoRtcpDtls);
         // Disable RTP/RTCP multiplexing 
         audioSendParams.rtcp.mux = false; 
         videoSendParams.rtcp.mux = false;
         audioRecvParams.rtcp.mux = false;
         videoRecvParams.rtcp.mux = false;
       };
     //
     // Set the audio and video send and receive parameters.  
     audioSender.send(audioSendParams);
     videoSender.send(videoSendParams);
     audioReceiver.receive(audioRecvParams);
     videoReceiver.receive(videoRecvParams);
  });
// Now we can render/play
// audioReceiver.track and videoReceiver.track.

// Helper functions
function log(text) {
  console.log('Time: ' + (performance.now() / 1000).toFixed(3) + ' ' + text);
}

function errorHandler (error) {
	log('Error encountered: ' + error.name);
}

function sendLocalCandidate(transport, candidate, kind){
   mySignaller.mySendLocalCandidate({
   "candidate": candidate,
   "kind": kind,
   "component": transport.component
   });
}
  </code></pre>
  </section>

</section>

<section id="rtcicelistener*">
  <h2>The RTCIceListener Object</h2>

    <p>
      The <dfn>RTCIceListener</dfn> enables an endpoint to construct multiple <code><a>RTCIceTransport</a></code>
      objects from a set of local ICE parameters, 
      enabling usage scenarios such as parallel forking.
    </p>

  <section id="rtcicelistener-overview*">
    <h3>Overview</h3>

    <p>An <code><a>RTCIceListener</a></code> instance is associated to an <code><a>RTCIceTransport</a></code>.</p>
  </section>

  <section id="rtcicelistener-operation*">
    <h3>Operation</h3>

    <p>An <code><a>RTCIceListener</a></code> instance is constructed from an 
    <code><a>RTCIceGatherOptions</a></code> object.</p>
  </section>

  <section id="rtcicelistener-interface-definition*">
    <h3>Interface Definition</h3>

    <dl class="idl" title="[Constructor(RTCIceGatherOptions options)] interface RTCIceListener">
      <dt>RTCIceParameters getLocalParameters()</dt>
      <dd><p>Obtain the ICE parameters of the <code><a>RTCIceListener</a></code>.</p></dd>
      <dt>sequence&lt;RTCIceCandidate>  getLocalCandidates()</dt>
      <dd><p>Retrieve the sequence of valid local candidates associated with the
      <code><a>RTCIceListener</a></code>.
      This retrieves all local candidates currently known (except for peer reflexive candidates),
      even if an <code><a>onlocalcandidate</a></code>
      event hasn't been processed yet.</p></dd>
      <dt>attribute EventHandler? onerror</dt>
      <dd><p>This event handler, of event handler type <code>error</code>,
      <em class="rfc2119" title="MUST">MUST</em> be supported by all objects 
      implementing the <code><a>RTCIceListener</a></code> interface.
      If TURN credentials are invalid, then this event <em class="rfc2119" title="MUST">MUST</em>
      be fired.
      </p></dd>

      <dt>attribute EventHandler? onlocalcandidate</dt>
      <dd><p>This event handler, of event handler event type <code>icecandidate</code>,
      <em class="rfc2119" title="MUST">MUST</em>  be supported by all objects implementing the
      <code><a>RTCIceListener</a></code> interface.
      It receives events when a new local ICE candidate is available.
    </p></dd>
    </dl>
  </section>

  <section id="rtcicegatheroptions*">
    <h3>dictionary RTCIceGatherOptions</h3>
   <p><dfn>RTCIceGatherOptions</dfn> provides options relating to the gathering of ICE candidates.</p>

        <dl class="idl" title=
        "dictionary RTCIceGatherOptions">
          <dt>RTCIceGatherPolicy gatherPolicy</dt>
          <dd><p>The ICE gather policy.</p></dd>
          <dt>sequence&lt;RTCIceServer> iceservers</dt>
          <dd><p>The ICE servers to be configured.</p></dd>
        </dl>
  </section>

  <section id="rtcicegatherpolicy*">
    <h3>enum RTCIceGatherPolicy</h3>
    <p><dfn>RTCIceGatherPolicy</dfn> denotes the policy relating to the gathering of ICE candidates.</p>
    <dl class="idl" title="enum RTCIceGatherPolicy">
      <dt>all</dt>
      <dd><p>The ICE transport gathers all types of candidates when this value is specified.</p></dd>
      <dt>nohost</dt>
      <dd><p>The ICE transport gathers all ICE candidate types except for host candidates.</p></dd>
      <dt>relay</dt>
      <dd><p>The ICE transport <em class="rfc2119" title="MUST">MUST</em> only gather media relay candidates such as candidates passing through a TURN server.
      This can be used to reduce leakage of IP addresses in certain use cases.</p></dd>
    </dl>
  </section>

  <section id="rtcicelistener-example*">
    <h3>Example</h3>
    <pre class="example"><code class="javascript">

// Example to demonstrate forking when RTP and RTCP are not multiplexed. 

var iceGatherOptions = new RTCIceGatherOptions(); 
gatherOptions.gatherPolicy = RTCIceGatherPolicy.relay; 
gatherOptions.iceservers = ... ; 
var iceRtpListener = new RTCIceListener(gatherOptions);
var iceRtcpListener = new RTCIceListener(gatherOptions); 
var iceBaseRtpTransport = new RTCIceTransport();
//create the RTCP ICE transport, which inherits the iceGatherOptions
var iceBaseRtcpTransport = iceBaseRtpTransport.createAssociatedTransport();

mySendInitiate(
{
   "icertp": iceRtpListener.getLocalParameters(),
   "icertcp": iceRtcpListener.getLocalParameters()
 },
  function(response) {
  // We may get N responses
  // Create the ICE Transport Controller object
  var controller = new RTCIceTransportController();
  controller.addTransport(iceRtpTransport);
  controller.addTransport(iceRtcpTransport);
  // Start the ICE transports (using the "relay" gather policy inherited from the iceListener)
  iceRtpTransport.start(iceRtpListener,response.icertp, RTCIceRole.controlling);
  iceRtcpTransport.start(iceRtcpListener,response.icertcp, RTCIceRole.controlling); 
  // ... setup DTLS, RTP, SCTP, etc.
});

iceRtpListener.onlocalcandidate = mySendLocalRtpCandidate;
iceRtcpListener.onlocalcandidate = mySendLocalRtcpCandidate; 
    </code></pre>

  </section>
</section>

<section id="rtcrtpsender*">
  <h2>The RTCRtpSender Object</h2>

    <p>
      The <dfn>RTCRtpSender</dfn> includes information relating to the RTP sender.
    </p>

  <section id="rtcrtpsender-overview*">
    <h3>Overview</h3>

    <p>An <code><a>RTCRtpSender</a></code> instance is associated to a sending <a>MediaStreamTrack</a> 
    and provides RTC related methods to it.</p>
  </section>

  <section id="rtcrtpsender-operation*">
    <h3>Operation</h3>

    <p>A <code><a>RTCRtpSender</a></code> instance is constructed from an <a>MediaStreamTrack</a> object and 
    associated to an <code><a>RTCDtlsTransport</a></code>.</p>
  </section>

  <section id="rtcrtpsender-interface-definition*">
    <h3>Interface Definition</h3>

    <dl class="idl" title="[Constructor(MediaStreamTrack track, RTCDtlsTransport transport, optional RTCDtlsTransport rtcpTransport)] interface RTCRtpSender : RTCStatsProvider">
      <dt>readonly attribute MediaStreamTrack                    track</dt>
      <dd>
        <p>The associated <code><a>MediaStreamTrack</a></code> instance.</p>
      </dd>
      
      <dt>readonly attribute RTCDtlsTransport                    transport</dt>
      <dd>
        <p>The associated RTP <code><a>RTCDtlsTransport</a></code> instance.</p>
      </dd>

      <dt>readonly attribute RTCDtlsTransport                    rtcpTransport</dt>
      <dd>
        <p>The associated RTCP <code><a>RTCDtlsTransport</a></code> instance.</p>
      </dd>

      <dt>void setTransport(RTCDtlsTransport transport, optional RTCDtlsTransport rtcpTransport)</dt>
      <dd><p>Set the RTP <code><a>RTCDtlsTransport</a></code> (and if used) RTCP <code><a>RTCDtlsTransport</a></code>.</p></dd>

      <dt>void setTrack(MediaStreamTrack track)</dt>
      <dd><p>Set the <code><a>MediaStreamTrack</a></code>.</p></dd>
      <dt>static RTCRtpCapabilities getCapabilities(optional DOMString kind)</dt>
      <dd><p>Obtain the sender capabilities, based on <var>kind</var>.  If <var>kind</var> is
      omitted or is set to "", then all capabilities are returned.</p></dd>
      <dt>void send(RTCRtpParameters parameters)</dt>
      <dd><p>Media to be sent is controlled by parameters.
      If <code>send()</code> is called with invalid <code>RTCRtpParameters</code>,
      throw an <code>InvalidParameters</code> exception.
      The <code>send()</code> method does not update
      <var>parameters</var> based on what is currently being sent, so that the value of <var>parameters</var> remains that
      last passed to the <code>send()</code> method.
      The <code>RTCRtpSender</code> object starts sending when <code>send()</code> 
      is called for the first time, and changes the sending <code>parameters</code> when <code>send()</code> is called again. 
      The <code>RTCRtpSender</code> object stops sending when <code>stop()</code> is called.
      </p></dd>

      <dt>void stop()</dt>
      <dd><p>Stops sending the track on the wire, and sends an RTCP BYE.  
      Stop is final as in <code>MediaStreamTrack.stop()</code></p></dd>

      <dt>attribute EventHandler? onerror</dt>
      <dd><p>This event handler, of event handler type <code>error</code>,
      <em class="rfc2119" title="MUST">MUST</em> be supported by all objects implementing the <code><a>RTCRtpSender</a></code> interface.
      This event <em class="rfc2119" title="MUST">MUST</em> be fired if an issue is found 
      with the <code><a>RTCRtpParameters</a></code> object passed to
      <code>send()</code>, that is not immediately detected. 
      </p></dd>
      <dt>attribute EventHandler? onssrcconflict</dt>
      <dd><p>This event handler, of event handler type <code>RTCSsrcConflictEvent</code>,
      <em class="rfc2119" title="MUST">MUST</em> be supported by all objects implementing the <code><a>RTCRtpSender</a></code> interface.
      This event <em class="rfc2119" title="MUST">MUST</em> be fired if an SSRC conflict is detected.
      On an SSRC conflict, the <code>RTCRtpSender</code> automatically sends an RTCP BYE on the conflicted SSRC.  
    </p></dd>
    </dl>
  </section>

  <section id="rtcsssrcconflictevent-interface-definition*">
      <h3>RTCSsrcConflictEvent</h3>

        <p>The <code>ssrcconflict</code> event of the <code><a>RTCRtpSender</a></code> object uses
        the <code><a>RTCSsrcConflictEvent</a></code> interface.</p>

        <p>Firing an
        <dfn>RTCSsrcConflictEvent</dfn> event named
        <var>e</var> with an 
        <var>ssrc</var> means that an event with the name <var>e</var>,
        which does not bubble (except where otherwise stated) and is not
        cancelable (except where otherwise stated), and which uses the
        <code><a>RTCSsrcConflictEvent</a></code> interface with the
        <code>ssrc</code> attribute set to the conflicting SSRC
        <em class="rfc2119" title="MUST">MUST</em> be
        created and dispatched at the given target.</p>

        <dl class="idl" data-merge="RTCSsrcConflictEventInit" title=
        "[Constructor(DOMString type, RTCSsrcConflictEventInit eventInitDict)] interface RTCSsrcConflictEvent : Event">

          <dt>readonly attribute unsigned long ssrc</dt>
          <dd>
            <p>The <var>ssrc</var> attribute represents the conflicting SSRC
            that caused the event.
          </p>
          </dd>
        </dl>

        <dl class="idl" title=
        "dictionary RTCSsrcConflictEventInit : EventInit">
          <dt>unsigned long? ssrc</dt>
          <dd>
            <p>The <var>ssrc</var> attribute represents the conflicting SSRC
            that caused the event.
          </p>
          </dd>
        </dl>
      </section>

  <section id="ssrcconflict-example*">
    <h3>Example</h3>
    <pre class="example"><code class="javascript">

    </code></pre>
  </section>


</section>

<section id="rtcrtpreceiver*">
  <h2>The RTCRtpReceiver Object</h2>

    <p>
      The <dfn>RTCRtpReceiver</dfn> includes information relating to the RTP receiver. 
    </p>

  <section id="rtcrtpreceiver-overview*">
    <h3>Overview</h3>

    <p>An <code><a>RTCRtpReceiver</a></code> instance is associated to a receiving 
    <a>MediaStreamTrack</a> and provides RTC related methods to it.</p>
  </section>

  <section id="rtcrtpreceiver-operation*">
    <h3>Operation</h3>

    <p>A <code><a>RTCRtpReceiver</a></code> instance is constructed from an <code><a>RTCDtlsTransport</a></code> object.</p>
  </section>

  <section id="rtcrtpreceiver-interface-definition*">
    <h3>Interface Definition</h3>

    <dl class="idl" title="[Constructor(RTCDtlsTransport transport, optional RTCDtlsTransport rtcpTransport)] interface RTCRtpReceiver : RTCStatsProvider">
      <dt>readonly attribute MediaStreamTrack? track</dt>
      <dd>
        <p>The associated <code><a>MediaStreamTrack</a></code> instance.</p>
      </dd>

      <dt>readonly attribute RTCDtlsTransport                    transport</dt>
      <dd>
        <p>The associated RTP <code><a>RTCDtlsTransport</a></code> instance.</p>
      </dd>

      <dt>readonly attribute RTCDtlsTransport                    rtcpTransport</dt>
      <dd>
        <p>The associated RTCP <code><a>RTCDtlsTransport</a></code> instance.</p>
      </dd>

      <dt>void setTransport(RTCDtlsTransport transport, optional RTCDtlsTransport rtcpTransport)</dt>
      <dd><p>Set the RTP <code><a>RTCDtlsTransport</a></code> (and if used) RTCP <code><a>RTCDtlsTransport</a></code>.</p></dd>

      <dt>static RTCRtpCapabilities getCapabilities(optional DOMString kind)</dt>
      <dd><p>Obtain the receiver capabilities, based on <var>kind</var>.  If <var>kind</var> is omitted or set to "", then
      all capabilities are returned.</p></dd>
      <dt>void receive(RTCRtpParameters parameters)</dt>
      <dd><p>Media to be received is controlled by <var>parameters</var>.  
      If <code>receive()</code> is called with invalid <code><a>RTCRtpParameters</a></code>,
      throw an <code>InvalidParameters</code> exception.
      The <code>receive()</code> method does not update
      <var>parameters</var> based on what is currently being received, so that the value of <var>parameters</var> remains that
      last passed to the <code>receive()</code> method.
      The <code>RTCRtpReceiver</code> object starts receiving when <code>receive()</code>       
      is called for the first time, and changes the receiving <code>parameters</code> when <code>receive()</code> is called again.
      The <code>RTCRtpReceiver</code> object stops receiving when <code>stop()</code> is called.

      After <code>receive</code> returns, <var>track</var> is set, and the value of <var>track.kind</var> is determined
      based on the <var>kind</var> of the codecs provided in <var>parameters.codecs</var>.  
      If <var>parameters.codecs</var> are all of a single <var>kind</var> then <var>track.kind</var> is set to that <var>kind</var>.
      If <var>parameters.codecs</var> are of mixed <var>kind</var>, 
      throw an <code>InvalidParameters</code> exception.
     </p></dd>

      <dt>void stop()</dt>
      <dd><p>Stops receiving the track on the wire. Stop is final like <a>MediaStreamTrack</a>.
      </p></dd>

      <dt>attribute EventHandler? onerror</dt>
      <dd><p>This event handler, of event handler type <code>error</code>,
      <em class="rfc2119" title="MUST">MUST</em> be supported by all objects implementing the <code><a>RTCRtpReceiver</a></code> interface.
      This event <em class="rfc2119" title="MUST">MUST</em> be fired if an issue is found with the <code><a>RTCRtpParameters</a></code> object passed to
      <code>receive()</code>, that is not immediately detected.
    </p></dd>
    </dl>
  </section>

  <section id="rtcrtpreceiver-example*">
    <h3>Examples</h3>

    <pre class="example"><code class="javascript">
// Assume we already have a way to signal, a transport
// (RTCDtlsTransport), and audio and video tracks. This is an example
// of  how to offer them  and get back an answer with audio and
// video tracks, and begin sending and receiving them.
// The example assumes that RTP and RTCP are multiplexed. 
function myInitiate(mySignaller, transport, audioTrack, videoTrack) {
  var audioSender = new RTCRtpSender(audioTrack, transport);
  var videoSender = new RTCRtpSender(videoTrack, transport);
  var audioReceiver = new RTCRtpReceiver(transport);
  var videoReceiver = new RTCRtpReceiver(transport);

// Retrieve the audio and video receiver capabilities
  var recvAudioCaps = RTCRtpReceiver.getCapabilities("audio");
  var recvVideoCaps = RTCRtpReceiver.getCapabilities("video");   
// Retrieve the audio and video sender capabilities
  var sendAudioCaps = RTCRtpSender.getCapabilities("audio"); 
  var sendVideoCaps = RTCRtpSender.getCapabilities("video"); 

  mySignaller.myOfferTracks({
    // The initiator offers its receiver and sender capabilities. 
    "recvAudioCaps": recvAudioCaps, 
    "recvVideoCaps": recvVideoCaps,
    "sendAudioCaps": sendAudioCaps,
    "sendVideoCaps": sendVideoCaps 
  }, function(answer) {
    // The responder answers with its receiver capabilities

    // Derive the send and receive parameters
    var audioSendParams = myCapsToSendParams(sendAudioCaps, answer.recvAudioCaps); 
    var videoSendParams = myCapsToSendParams(sendVideoCaps, answer.recvVideoCaps); 
    var audioRecvParams = myCapsToRecvParams(recvAudioCaps, answer.sendAudioCaps);
    var videoRecvParams = myCapsToRecvParams(recvVideoCaps, answer.sendVideoCaps); 
    audioSender.send(audioSendParams);
    videoSender.send(videoSendParams);
    audioReceiver.receive(audioRecvParams);
    videoReceiver.receive(videoRecvParams);

    // Now we can render/play
    // audioReceiver.track and videoReceiver.track.
  });
}
    </code></pre>
    <pre class="example"><code class="javascript">
// Assume we already have a way to signal, a transport (RTCDtlsTransport)
// and audio and video tracks. This is an example of how to answer an
// offer with audio and video tracks, and begin sending and receiving them. 
// The example assumes that RTP and RTCP are multiplexed. 
function myAccept(
  mySignaller, remote, transport, audioTrack, videoTrack) {
  var audioSender = new RTCRtpSender(audioTrack, transport);
  var videoSender = new RTCRtpSender(videoTrack, transport);
  var audioReceiver = new RTCRtpReceiver(transport);
  var videoReceiver = new RTCRtpReceiver(transport);

// Retrieve the send and receive capabilities
  var recvAudioCaps = RTCRtpReceiver.getCapabilities("audio");
  var recvVideoCaps = RTCRtpReceiver.getCapabilities("video");
  var sendAudioCaps = RTCRtpSender.getCapabilities("audio"); 
  var sendVideoCaps = RTCRtpSender.getCapabilities("video"); 

  mySignaller.myAnswerTracks({
    "recvAudioCaps": recvAudioCaps,
    "recvVideoCaps": recvVideoCaps,
    "sendAudioCaps": sendAudioCaps,
    "sendVideoCaps": sendVideoCaps
  });

    // Derive the send and receive parameters using Javascript functions defined in Section 15.2.
    var audioSendParams = myCapsToSendParams(sendAudioCaps, remote.recvAudioCaps);
    var videoSendParams = myCapsToSendParams(sendVideoCaps, remote.recvVideoCaps);
    var audioRecvParams = myCapsToRecvParams(recvAudioCaps, remote.sendAudioCaps);
    var videoRecvParams = myCapsToRecvParams(recvVideoCaps, remote.sendVideoCaps);
    audioSender.send(audioSendParams);
    videoSender.send(videoSendParams);
    audioReceiver.receive(audioRecvParams);
    videoReceiver.receive(videoRecvParams);

  // Now we can render/play
  // audioReceiver.track and videoReceiver.track.
}
    </code></pre>
  </section>

</section>

<section id="rtcrtplistener*">
  <h2>The RTCRtpListener Object</h2>

    <p>
      The <dfn>RTCRtpListener</dfn> listens to RTP packets received from the DTLS transport.</p>

  <section id="rtcrtplistener-overview*">
    <h3>Overview</h3>

    <p>An <code><a>RTCRtpListener</a></code> instance is associated to an <code><a>RTCDtlsTransport</a></code>.</p>
  </section>

  <section id="rtcrtplistener-operation*">
    <h3>Operation</h3>

    <p>An <a>RTCRtpListener</a> instance is constructed from an <a>RTCDtlsTransport</a> object.</p>
  </section>

  <section id="rtcrtplistener-interface-definition*">
    <h3>Interface Definition</h3>

    <dl class="idl" title="[Constructor(RTCDtlsTransport transport)] interface RTCRtpListener">
      <dt>readonly attribute RTCDtlsTransport                    transport</dt>
      <dd>
        <p>The RTP <code><a>RTCDtlsTransport</a></code> instance.</p>
      </dd>
      <dt>attribute EventHandler?   onunhandledrtp</dt>
      <dd><p>The event handler which handles the <a>RTCRtpUnhandledRtpEvent</a>.</p>
    </dd>
    </dl>
  </section>

  <section id="rtcrtpunhandledevent-interface-definition*">
      <h3>RTCRtpUnhandledEvent</h3>

        <p>An <code><a>unhandledrtp</a></code> event is fired if the <code><a>RTCRtpListener</a></code> detects an 
      RTP stream that is not configured to be processed by an
      existing <code><a>RTCRtpReceiver</a></code> object.  The amount of buffering to be provided for unhandled
      RTP streams is recommended to be strictly limited to protect against denial of service attacks.
      </p>
   <p>To determine whether an RTP stream is configured to be processed by an existing <code><a>RTCRtpReceiver</a></code> object,
   the <code><a>RTCRtpListener</a></code> attempts to match the values of an incoming RTP packet's
   Payload Type and SSRC fields as well as the value of the muxId (if present in the <a>MID</a> RTP header extension) against the
   <code>RTCRtpReceiver.RTCRtpParameters.RTCRtpCodecParameters.payLoadType</code>,
   <code>RTCRtpReceiver.RTCRtpParameters.RTCRtpEncodingParameters.ssrc</code>,
   and <code>RTCRtpReceiver.RTCRtpParameters.muxId</code> attributes of configured <code><a>RTCRtpReceiver</a></code> objects.
   </p>

   <p>TODO: provide details of matching behavior, along with examples.</p>


   <p>The <code><a>unhandledrtp</a></code> event of the <code><a>RTCRtpListener</a></code> object uses
   the <code><a>RTCRtpUnhandledEvent</a></code> interface.</p>

        <p><dfn title="Fire an unhandledrtp event">Firing an
        <code><a>unhandledrtp</a></code> event named
        <var>e</var></dfn> with an <code><a>RTCRtpUnhandled</a></code>
        <var>stream</var> means that an event with the name <var>e</var>,
        which does not bubble (except where otherwise stated) and is not
        cancelable (except where otherwise stated), and which uses the
        <code>RTCRtpUnhandledEvent</code> interface with the
        <code>stream</code> attribute set to an <code>RTCRtpUnhandled</code> object, 
       <em class="rfc2119" title="MUST">MUST</em> be
        created and dispatched at the given target.</p>

       <dl class="idl" data-merge="RTCRtpUnhandledEventInit" title=
        "[Constructor(DOMString type, RTCRtpUnhandledEventInit eventInitDict)] interface RTCRtpUnhandledEvent : Event">

          <dt>readonly attribute RTCRtpUnhandled stream</dt>

          <dd>
            <p>The <code>stream</code> attribute is the
            <code><a>RTCRtpUnhandled</a></code> object with the characteristics of the RTP stream
            that caused the event.
          </p>
          </dd>
        </dl>

        <dl class="idl" title=
        "dictionary RTCRtpUnhandledEventInit : EventInit">
          <dt>RTCRtpUnhandled? stream</dt>
          <dd>
            <p>The characteristics of the RTP stream that caused the event.</p>
          </dd>
        </dl>
      </section>

  <section id="rtcrtplistener-example*">
    <h3>Example</h3>
    <pre class="example"><code class="javascript">

    </code></pre>

  </section>
</section>

<section id="rtcrtpdictionaries*">
  <h2>Dictionaries related to Rtp</h2>

  <section id="Dictionary rtcrtpunhandled*">
      <h3>RTCRtpUnhandled</h3>
    <p><dfn>RTCRtpUnhandled</dfn> provides information on the RTP packet that caused the <code>RTCRtpUnhandled</code> event.</p>

     <dl class="idl" title=
  "typedef octet payloadtype">
        </dl>

    <dl class="idl" title="dictionary RTCRtpUnhandled">
        <dt>unsigned long  ssrc</dt>
        <dd>
          <p>The SSRC in the RTP stream triggering the <code><a>unhandledrtp</a></code> event.</p>
        </dd>
        <dt>payloadtype payloadType</dt>
        <dd>
          <p>The Payload Type value in the RTP stream triggering the <code><a>unhandledrtp</a></code> event.</p>
        </dd>
        <dt>DOMString muxId</dt>
        <dd>
          <p>If present, the value of the <a>MID</a> RTP header extension [[!BUNDLE]] in the RTP stream 
          triggering the <code><a>unhandledrtp</a></code> event.</p>
        </dd>
    </dl>
  </section>

  <section id="rtcrtpcapabilities*">
    <h3>dictionary RTCRtpCapabilities</h3>

<p>The <dfn>RTCRtpCapabilities</dfn> object expresses the capabilities of <code><a>RTCRtpSender</a></code> and 
<code><a>RTCRtpReceiver</a></code> objects.
Features which are mandatory to implement in [[!RTP-USAGE]], such as RTP/RTCP multiplexing [[!RFC5761]] 
and reduced size RTCP [[!RFC5506]] are assumed to be available and are therefore 
not included in <code><a>RTCRtpCapabilities</a></code>, 
although these features can be set via <code><a>RTCRtpParameters</a></code>.</p>

    <dl title='dictionary RTCRtpCapabilities' class='idl'>
      <dt>sequence&lt;RTCRtpCodecCapability> codecs</dt>
      <dd><p>Supported codecs.</p></dd>
      <dt>sequence&lt;RTCRtpHeaderExtension> headerExtensions</dt>
      <dd><p>Supported RTP header extensions.</p></dd>
      </p></dd>
      <dt>sequence&lt;DOMString> fecMechanisms</dt>
      <dd><p>Supported FEC mechanisms.  Currently [[!RTP-USAGE]] makes no recommendations relating to FEC mechanisms.
      </p></dd>
    </dl>

 </section>

  <section id="rtcrtcpfeedback*">
    <h3>dictionary RTCRtcpFeedback</h3>
    <p><dfn>RTCRtcpFeedback</dfn> provides information on RTCP feedback messages.</p>
    <dl title='dictionary RTCRtcpFeedback' class='idl'>
      <dt>DOMString type</dt>
      <dd><p>Valid values for <var>type</var> are the "RTCP Feedback" Attribute Values enumerated in [[!IANA-SDP-14]] ("ack", "ccm", "nack", etc.).</p></dd>
      <dt>DOMString parameter</dt>
      <dd><p>For a <var>type</var> of "ack" or "nack", valid values for <var>parameters</var> are the "ack" and "nack" Attribute Values enumerated in [[!IANA-SDP-15]] ("sli", "rpsi", etc.).
      For a <var>type</var> of "ccm",  valid values for <var>parameters</var> are the "Codec Control Messages" enumerated in [[!IANA-SDP-19]] ("fir", "tmmbr" (includes "tmmbn"), etc.). </p></dd>
    </dl>
  </section>

  <section id="rtcrtpcodeccapability*">
    <h3>dictionary RTCRtpCodecCapability</h3>
    <p><dfn>RTCRtpCodecCapability</dfn> provides information on the capabilities of a codec.</p>

     <dl class="idl" title=
  "typedef object Dictionary">
        </dl>

    <dl class="idl" title="dictionary RTCRtpCodecCapability">
      <dt>DOMString name</dt>
        <dd><p>The MIME media type.  Valid types are
        listed in [[!IANA-RTP-2]].</p></dd>
      <dt>DOMString kind</dt>
        <dd><p>The media supported by the codec: "audio", "video" or "" for both.</p></dd>
      <dt>unsigned long clockRate</dt>
        <dd><p>Codec clock rate expressed in Hertz, null if unset.</p></dd>
      <dt>payloadtype preferredPayloadType</dt>
      <dd><p>Added to make it possible for the sender and receiver to pick a
      matching payload type when creating sender and receiver parameters.</p></dd>
      <dt>unsigned long numChannels</dt>
        <dd><p>The number of channels supported (e.g. stereo). 
        For video, this will be unset.</p></dd>
      <dt>sequence&lt;RTCRtcpFeedback> rtcpFeedback</dt>
      <dd><p>Transport layer and codec-specific feedback messages for this codec.</p></dd>
      <dt>Dictionary parameters</dt>
        <dd><p>Codec-specific parameters that must be signaled to the remote party.</p></dd>
      <dt>Dictionary options</dt>
        <dd><p>Codec-specific parameters available for signaling.</p></dd>
      <dt>unsigned short maxTemporalLayers = 0</dt>
      <dd><p>Maximum number of temporal layer extensions supported by this codec (e.g. a value of 1 indicates support for up to 2 temporal layers).  A value of 0 indicates no support for temporal scalability.</p></dd>
      <dt>unsigned short maxSpatialLayers = 0</dt>
      <dd><p>Maximum number of spatial layer extensions supported by this codec (e.g. a value of 1 indicates support for up to 2 spatial layers).  A value of 0 indicates no support for spatial scalability.</p></dd>
      <dt>boolean svcMultiStreamSupport</dt>
      <dd><p>Whether the implementation can send SVC layers utilizing distinct SSRCs. 
      Unset for audio codecs.  For video codecs, only set if the codec supports scalable video coding with 
      multiple streams. 
      </p></dd>
    </dl>
  <section id="codec-capabilities*">
    <h3>Codec capability parameters</h3>

    <p>The capability parameters for commonly implemented codecs are provided below.</p>

  <section id="opus-codec-capabilities*">
    <h3>Opus</h3>
    <p>The following capabilities are defined for Opus, as noted in [[!OPUS-RTP]] Section 6.1:</p>

      <table class="simple">
        <thead>
          <tr>
            <th>Property Name</th>

            <th>Values</th>

            <th>Notes</th>
          </tr>
        </thead>
        <tbody>
          <tr id="def-maxplaybackrate*">
            <td><dfn>maxplaybackrate</dfn></td>

            <td>
              <code>unsigned long</code>
            </td>

            <td>A hint about the maximum output sampling rate that
            the receiver is capable of rendering in Hz.  
            </td>
            </tr>
          <tr id="def-stereo*">
            <td><dfn>stereo</dfn></td>
        
            <td>
              <code>boolean</code>
            </td>
      
            <td>Specifies whether the decoder prefers receiving stereo (if true) or mono signals (if false). 
            </td>
            </tr>
        </tbody>
      </table>

  </section> 
  <section id="vp-codec-dictionary*">
    <h3>VP8</h3>

      <p>The following receiver capabilities are defined for VP8, as noted in [[VP8-RTP]] Section 6.1:</p>

      <table class="simple">
        <thead>
          <tr>
            <th>Property Name</th>

            <th>Values</th>

            <th>Notes</th>
          </tr>
        </thead>
        <tbody>
          <tr id="def-max-fr*">
            <td><dfn>max-fr</dfn></td>

            <td>
              <code>unsigned long</code>
            </td>

            <td>This capability indicates the maximum frame rate in frames per second that the decoder is capable of decoding. 
            </td>
            </tr>
          <tr id="def-max-fs*">
            <td><dfn>max-fs</dfn></td>
      
            <td>
              <code>unsigned long long</code>
            </td>

            <td>This capability indicates the maximum frame size in macroblocks that the decoder is capable of decoding. 
            </td>
            </tr>
        </tbody>
      </table>
  </section>

  <section id="h264-capabilities*">
    <h3>H.264</h3>
    <p>The following capabilities are defined for H.264, as noted in [[RFC6184]] Section 8.1, and [[!RTCWEB-VIDEO]].</p>   

      <table class="simple">
        <thead>
          <tr>
            <th>Property Name</th>

            <th>Values</th>

            <th>Notes</th>
          </tr>
        </thead>
        <tbody>
          <tr id="def-max-recv-level*">
            <td><dfn>max-recv-level</dfn></td>

            <td>
              <code>unsigned long</code>
            </td>

            <td>Indicates the highest level a receiver supports.</td>
            </tr>
          <tr id="def-packetization-mode*">
            <td><dfn>packetization-mode</dfn></td>

            <td><code>sequence&lt;unsigned short&gt;</code></td>
            <td>
A sequence of unsigned shorts, each ranging from 0 to 2, indicating supported <var>packetization-mode</var> values.
Support for <var>packetization-mode</var> 1 is mandatory in [[!RTCWEB-VIDEO]].
            </td>
            </tr>
        </tbody>
      </table>
  </section>

  </section>
</section>
  <section id="rtcrtpparameters*">
    <h3>dictionary RTCRtpParameters</h3>
    <p><dfn>RTCRtpParameters</dfn> contains the RTP stack settings.</p>
    <dl title='dictionary RTCRtpParameters' class='idl'>
      <dt>DOMString muxId=""</dt>
      <dd><p>The <var>muxId</var> assigned to the RTP stream, if any, empty string if unset.   
In an <code><a>RTCRtpReceiver</a></code> or <code><a>RTCRtpSender</a></code> object, this corresponds to
<a>MID</a> RTP header extension defined in [[!BUNDLE]].  
This is a stable identifier that permits the track corresponding to an RTP stream to be identified, rather than relying on an SSRC.
An SSRC is randomly generated and can change arbitrarily due to conflicts with other SSRCs, whereas
the <var>muxId</var> has a value 
whose meaning can be defined in advance between RTP
sender and receiver, assisting in RTP demultiplexing.
Note that including <var>muxId</var> in <code><a>RTCRtpParameters</a></code> rather than in <code><a>RTCRtpEncodingParameters</a></code> implies that if it is desired to send simulcast streams with different <var>muxId</var> values for each stream, then multiple
<code><a>RTCRtpSender</a></code> objects are needed. 
</p></dd>
      <dt>sequence&lt;RTCRtpCodecParameters> codecs</dt>
      <dd><p>The codecs to send or receive (could include RED [[RFC2198]], RTX [[!RFC4588]] and CN [[RFC3389]]).</p></dd>
      <dt>sequence&lt;RTCRtpHeaderExtensionParameters> headerExtensions</dt>
      <dd><p>Configured header extensions.</p></dd>
      <dt>sequence&lt;RTCRtpEncodingParameters> encodings</dt>
      <dd><p>The "encodings" or "layers" to be used for things like simulcast, Scalable Video Coding, RTX, FEC, etc.</p></dd>
      <dt>RTCRtcpParameters rtcp</dt>
      <dd><p>Parameters to configure RTCP.<p></dd>
    </dl>
  </section>

  <section id=rtcrtcpparameters*">
    <h3>dictionary RTCRtcpParameters</h3>
    <p><dfn>RTCRtcpParameters</dfn> provides information on RTCP settings.</p>
    <dl title='dictionary RTCRtcpParameters' class='idl'>
      <dt>unsigned long ssrc</dt>
      <dd><p>The SSRC to be used in the Receiver Report "SSRC of packet sender" field as defined in [[!RFC3550]] Section 6.4.2. 
      If unset, <var>ssrc</var> is chosen by the browser, and the chosen value is not reflected in <code>RTCRtcpParameters.ssrc</code>.
      If the browser chooses the <var>ssrc</var> it may change it in event of a collision, as described in [[!RFC3550]].</p></dd>
      <dt>DOMString cname</dt>
      <dd><p>The Canonical Name (CNAME) used by RTCP (e.g. in SDES messages).  Guidelines for CNAME generation are provided in [[!RTP-USAGE]] Section 4.9.
      By default, ORTC implementations SHOULD set the CNAME to be the same within all <code>RTCRtcpParameter</code> objects created within the 
      same Javascript sandbox.   For backward compatibility with WebRTC 1.0, applications MAY set the CNAME; if unset, the CNAME is chosen by the browser. </p></dd>
      <dt>boolean reducedSize=false</dt>
      <dd><p>Whether reduced size RTCP [[!RFC5506]] is configured (if true) or compound RTCP as specified in [[!RFC3550]] (if false).  
      The default is <code>false</code>.</p></dd>
      <dt>boolean mux=true</dt>
      <dd><p>Whether RTP and RTCP are multiplexed, as specified in [[!RFC5761]].
      The default is <code>true</code>.  If set to <code>false</code>, the
      <code><a>RTCIceTransport</a></code>
      <em class="rfc2119" title="MUST">MUST</em> have an associated <code><a>RTCIceTransport</a></code> object with
      a <var>component</var> of "RTCP",
      in which case RTCP will be sent on the associated <code><a>RTCIceTransport</a></code>.
      </p></dd>
    </dl>
  </section>

  <section id="rtcrtpcodecparameters*">
    <h3>dictionary RTCRtpCodecParameters</h3>
<p><dfn>RTCRtpCodecParameters</dfn> provides information on codec settings.</p>
    <dl title='dictionary RTCRtpCodecParameters' class='idl'>
      <dt>DOMString name</dt>
        <dd><p>The MIME media type.  Valid types are
       listed in [[!IANA-RTP-2]].  The <var>name</var> MUST always be provided.  
      </p></dd>
      <dt>payloadtype       payloadType</dt>
      <dd><p>The value that goes in the RTP Payload Type Field [[!RFC3550]].  The <var>payloadType</var>
      MUST always be provided.</p></dd>
      <dt>unsigned long clockRate</dt>
        <dd><p>Codec clock rate expressed in Hertz, null if unset.</p></dd>
      <dt>unsigned long numChannels</dt>
      <dd><p>The number of channels supported (e.g. stereo).  If unset for audio, use the codec default.  
      For video, this can be left unset.</p></dd>
      <dt>sequence&lt;RTCRtcpFeedback> rtcpFeedback</dt>
      <dd><p>Transport layer and codec-specific feedback messages for this codec.</p></dd>
      <dt>Dictionary parameters</dt>
        <dd><p>Codec-specific parameters available for signaling.</p></dd>
    </dl>

  <section id="codec-parameters*">
    <h3>Codec parameters</h3>

   <p>The capabilities for commonly implemented codecs described in Section 9.4.2, are also
   used as codec parameters, with
   <code>RTCRtpCodecCapability.parameters</code> of the receiver used as
   <code>RTCRtpCodecParameters.parameters</code> of the sender, and
   <code>RTCRtpCodecCapability.parameters</code> of the sender used as
   <code>RTCRtpCodecParameters.parameters</code> of the receiver, with the Property Name
   and Values unchanged. 
   </p>
  </section>

  </section>

  <section id="rtcrtpencodingparameters*">
    <h3>dictionary RTCRtpEncodingParameters</h3>
    <dl class="idl" title="dictionary RTCRtpEncodingParameters">
      <dt>unsigned long ssrc</dt>
      <dd><p>The SSRC for this layering/encoding.
      If <var>ssrc</var> is unset in a <code>RTCRtpEncodingParameters</code> object passed to the <code>RTCRtpReceiver.receive</code> method, the
      next unhandled SSRC will match, and an <code>RTCRtpUnhandledEvent</code> will not be fired. 
      If <var>ssrc</var> is unset in a <code>RTCRtpEncodingParameters</code> object passed to the <code>RTCRtpSender.send</code> 
      method,  the browser will choose, and the chosen value is not reflected in <code>RTCRtpEncodingParameters.ssrc</code>.  
      If the browser chooses the
      <var>ssrc</var>, it may change it due to a collision without firing an <code>RTCSsrcConflictEvent</code>.  
      If <var>ssrc</var> is set in a <code>RTCRtpEncodingParameters</code> object passed to the <code>RTCRtpSender.send</code> method and an 
      SSRC conflict is detected, then an <code>RTCSsrcConflictEvent</code> is fired (see Section 6.4). 
      </p></dd>
      <dt>payloadtype codecPayloadType</dt>
      <dd><p>For per-encoding codec specifications, give the codec Payload Type here.  
      If unset, the browser will choose.</p></dd>
      <dt>RTCRtpFecParameters fec</dt>
      <dd><p>Specifies the FEC mechanism if set.</p></dd>
      <dt>RTCRtpRtxParameters rtx</dt>
      <dd><p>Specifies the RTX [[!RFC4588]] parameters if set.</p></dd>
      <dt>double priority=1.0</dt>
      <dd><p>The higher the value, the more the bits will be given to each as available bandwidth goes up.  Default is 1.0.
      For scalable video coding, this parameter is only relevant for the base layer.
      This parameter is ignored in an <code><a>RTCRtpReceiver</a></code> object.
      If unset, the default is assumed.
      </p></dd>
      <dt>double maxBitrate</dt>
      <dd><p>Ramp up resolution/quality/framerate until this bitrate, if set.  Summed when using dependent layers.
      This parameter is ignored in scalable video coding, or in an <code><a>RTCRtpReceiver</a></code> object.
      If unset, there is no maximum bitrate.  
      </p></dd>
      <dt>double minQuality=0</dt>
      <dd><p>Never send less than this quality.  1.0 = maximum attainable quality.
      For scalable video coding, this parameter is only relevant for the base layer.
      This parameter is ignored in an <code><a>RTCRtpReceiver</a></code> object.
      </p></dd>
      <dt>double framerateBias=0.5</dt>
      <dd><p>What to give more bits to, if available.  0.0 = strongly favor resolution or 1.0 = strongly favor 
      framerate. 0.5 = neither (default).  For scalable video coding, this parameter is only relevant for the base layer. 
      This parameter is ignored in an <code><a>RTCRtpReceiver</a></code> object.
      If unset, the default is assumed.</p></dd>
      <dt>double resolutionScale</dt>
      <dd><p>Inverse of the input resolution fraction to be encoded, or die trying.  Example: 1.0 = full resolution,  
      2.0 = one half of the full resolution.  
      For scalable video coding, <var>resolutionScale</var> refers to 
      the inverse aggregate fraction of the input resolution achieved by this 
      layer when combined with all
      dependent layers.</p></dd>
      <dt>double framerateScale</dt>
      <dd><p>Inverse of the input framerate fraction to be encoded.  Example: 1.0 = full framerate,
      2.0 = one half of the full framerate.  
      For scalable video coding, <var>framerateScale</var> refers to the inverse of the aggregate fraction of input framerate 
      achieved by this layer when combined with all dependent layers. 
      </p></dd>
      <dt>boolean active=true</dt>
      <dd><p>Whether the sender or receiver is active.  If false, don't send any media right now.
      Disable is different than omitting the encoding;  it can keep resources
      available to re-enable more quickly than re-adding.  Plus, it still sends RTCP.  If unset, the default is assumed.</p></dd>
      <dt>DOMString encodingId</dt>
      <dd><p>
An identifier for the encoding object.  This identifier should be unique within the scope of the
localized sequence of <code><a>RTCRtpEncodingParameters</a></code> for any given <code><a>RTCRtpParameters</a></code> object.
      </p>
      </dd>
      <dt>sequence&lt;DOMString> dependencyEncodingIds</dt>
      <dd><p>The <code><a>encodingId</a></code>s on which this layer depends. 
       Within this specification <code><a>encodingId</a></code>s are permitted only within the same <code><a>RTCRtpEncodingParameters</a></code> sequence.
       In the future if <a>MST</a> were to be supported, then if searching within an 
       <code><a>RTCRtpEncodingParameters</a></code> sequence did not produce a match, then a global search
       would be carried out.</p></dd>
    </dl>
</section>

<section id="rtcrtpencodingparameters-example*">
    <h3>Examples</h3>
<section id="rtcrtpencodingparameters-basicexample*">
    <h4>Basic Example</h3>
<pre class="example"><code>
//Send a thumbnail along with regular size
var encodings = [{ ssrc: 1,  priority: 1.0 }] 

// Control the resolution and framerate with a different track and RtpSender. 
var encodings = [{ ssrc: 2,  
// Prioritize the thumbnail over the main video.  
priority: 10.0 }];

// Sign Language (need high framerate, but don't get too bad quality)
var encodings = [{ minQuality: 0.2,  framerateBias: 1.0 }]; 

// Screencast (High quality, framerate can be low)
var encodings = [{ framerateBias: 0.0 }]; 

//Remote Desktop (High framerate, must not downscale) 
var encodings = [{ framerateBias: 1.0 }];

// Audio more important than video
var audioEncodings = [{ priority: 10.0 }]; 
var videoEncodings = [{ priority: 0.1 }]; 

//Video more important than audio
var audioEncodings = [{ priority: 0.1 }]; 
var videoEncodings = [{ priority: 10.0 }];

//Crank up the quality
var encodings = [{ maxBitrate: 10000000 }]; 

//Keep the bandwidth low
var encodings = [{ maxBitrate: 100000 }]; 
</code></pre>
</section>
<section id="rtcrtpencodingtemporal-example*">
  <h4>Temporal Scalability</h4>
<pre class="example"><code>
Example of 3-layer temporal scalability encoding
var encodings =[{
// Base framerate is one quarter of the input framerate
  encodingId: "0",
  framerateScale: 4.0
}, {
// Temporal enhancement (half the input framerate when combined with the base layer)
  encodingId: "1",
  dependencyEncodingIds: ["0"]
  framerateScale: 2.0
}, {
// Another temporal enhancement layer (full input framerate when all layers combined)
  encodingId: "2",
  dependencyEncodingIds: ["0", "1"]
  framerateScale: 1.0
}]

Example of 3-layer temporal scalability with all but the base layer disabled
var encodings =[{
  encodingId: "0",
  framerateScale: 4.0
}, {
  encodingId: "1",
  dependencyEncodingIds: ["0"],
  framerateScale: 2.0,
  active: false
}, {
  encodingId: "2",
  dependencyEncodingIds: ["0", "1"],
  framerateScale: 1.0,
  active: false
}];
</code></pre>

<p>Below is a representation of a 3-layer temporal scalability encoding.  In the diagram, I0 is the base layer I-frame,
and P0 represents base-layer P-frames.  P1 represents the first temporal enhancement layer, and P2 represents the
second temporal enhancement layer.</p>

<img alt="3-layer temporal scalability encoding" src="3-layer-temporal.png" style="width:75%" />
</section>

<section id="rtcrtpencodingspatialsim-example*">
  <h4>Spatial Simulcast</h4>
<pre class="example"><code>
Example of 3-layer spatial simulcast
var encodings =[{
// Simulcast layer at one quarter scale
  encodingId: "0",
  resolutionScale: 4.0
}, {
// Simulcast layer at one half scale
  encodingId: "1",
  resolutionScale: 2.0
}, {
// Simulcast layer at full scale
  encodingId: "2",
  resolutionScale: 1.0
}]

Example of 3-layer spatial simulcast with all but the lowest resolution layer disabled
var encodings =[{
  encodingId: "0",
  resolutionScale: 4.0
}, {
  encodingId: "1",
  resolutionScale: 2.0,
  active: false
}, {
  encodingId: "2",
  resolutionScale: 1.0,
  active: false
}];

Example of 2-layer spatial simulcast combined with 2-layer temporal scalability
var encodings =[{
// Low resolution base layer (half the input framerate, half the input resolution)
  encodingId: "0",
  resolutionScale: 2.0,
  framerateScale: 2.0
}, {
// Enhanced resolution Base layer (half the input framerate, full input resolution)
  encodingId: "E0",
  resolutionScale: 1.0,
  framerateScale: 2.0
}, {
// Temporal enhancement to the low resolution base layer (full input framerate, half resolution)
  encodingId: "1",
  dependencyEncodingIds: ["0"],
  resolutionScale: 2.0,
  framerateScale: 1.0
}, {
// Temporal enhancement to the enhanced resolution base layer (full input framerate and resolution)
  encodingId: "E1",
  dependencyEncodingIds: ["E0"],
  resolutionScale: 1.0,
  framerateScale: 1.0
}]
</code></pre>
<p>Below is a representation of 2-layer temporal scalability combined with 2-layer spatial simulcast. 
Solid arrows represent temporal prediction.
In the diagram, I0 is the base-layer I-frame, and P0 represents base-layer P-frames. 
EI0 is an enhanced resolution base-layer I-frame, and EP0 represents P-frames within the enhanced resolution base layer. 
P1 represents the first temporal enhancement layer, and EP1 represents a temporal enhancement to the
enhanced resolution simulcast base-layer.
</p>
<img alt="2-layer spatial simulcast and temporal scalability encoding" src="2-layer-spatialsim-temporal.png" style="width:75%" />
</section>
<section id="rtcrtpencodingspatialscal-example*">
  <h4>Spatial Scalability</h4>
<pre class="example"><code>
Example of 3-layer spatial scalability encoding
var encodings =[{
// Base layer with one quarter input resolution
  encodingId: "0",
  resolutionScale: 4.0
}, {
// Spatial enhancement layer providing half input resolution when combined with the base layer
  encodingId: "1",
  dependencyEncodingIds: ["0"]
  resolutionScale: 2.0
}, {
// Additional spatial enhancement layer providing full input resolution when combined with all layers 
  encodingId: "2",
  dependencyEncodingIds: ["0", "1"]
  resolutionScale: 1.0
}]

Example of 3-layer spatial scalability with all but the base layer disabled
var encodings =[{
  encodingId: "0",
  resolutionScale: 4.0
}, {
  encodingId: "1",
  dependencyEncodingIds: ["0"],
  resolutionScale: 2.0,
  active: false
}, {
  encodingId: "2",
  dependencyEncodingIds: ["0", "1"],
  resolutionScale: 1.0,
  active: false
}];

Example of 2-layer spatial scalability combined with 2-layer temporal scalability
var encodings =[{
// Base layer (half input framerate, half resolution)
  encodingId: "0",
  resolutionScale: 2.0,
  framerateScale: 2.0
}, {
// Temporal enhancement to the base layer (full input framerate, half resolution)
  encodingId: "1",
  dependencyEncodingIds: ["0"],
  resolutionScale: 2.0,
  framerateScale: 1.0
}, {
// Spatial enhancement to the base layer (half input framerate, full resolution)
  encodingId: "E0",
  dependencyEncodingIds: ["0"],
  resolutionScale: 1.0,
  framerateScale: 2.0
}, {
// Temporal enhancement to the spatial enhancement layer (full input framerate, full resolution)
  encodingId: "E1",
  dependencyEncodingIds: ["E0", "1"],
  resolutionScale: 1.0,
  framerateScale: 1.0
}]
</code></pre>
<p>Below is a representation of 2-layer temporal scalability combined with 2-layer spatial scalability. 
Solid arrows represent temporal prediction and dashed arrows represent inter-layer prediction.
In the diagram, I0 is the base-layer I-frame, and EI0 is an intra spatial enhancement.  
P0 represents base-layer P-frames, and P1 represents the first temporal enhancement layer.
EP0 represents a resolution enhancement to the base-layer P frames, and EP1 represents a resolution enhancement to the  
second temporal layer P-frames.  
</p>
<img alt="2-layer spatial and temporal scalability encoding" src="2-layer-spatial-temporal.png" style="width:75%" />
  </section>
  </section>
  <section id="rtcrtpfecparameters*">
    <h3>dictionary RTCRtpFecParameters</h3>
    <dl title='dictionary RTCRtpFecParameters' class='idl'>
      <dt>unsigned long ssrc</dt>
      <dd><p>The SSRC to use for FEC.
      If unset in an <code><a>RTCRtpSender</a></code> object, the browser will choose. 
      </p></dd>
      <dt>DOMString mechanism</dt>
      <dd><p>The Forward Error Correction (FEC) mechanism to use.</p></dd>
    </dl>
  </section>

  <section id="rtcrtprtxparameters*">
    <h3>dictionary RTCRtpRtxParameters</h3>
    <dl title='dictionary RTCRtpRtxParameters' class='idl'>
      <dt>unsigned long ssrc</dt>
      <dd><p>The SSRC to use for RTX.
      If unset in an <code><a>RTCRtpSender</a></code> object, the browser will choose.
      </p></dd>
    </dl>
  </section>

  <section id="rtcrtpheaderextension*">
    <h3>dictionary RTCRtpHeaderExtension</h3>
    <dl class="idl" title="dictionary RTCRtpHeaderExtension">
      <dt>DOMString kind</dt>
        <dd><p>The media supported by the header extension: "audio" for an audio codec, 
          "video" for a video codec, and "" for both.</p></dd>
      <dt>DOMString           uri</dt>
         <dd><p>The URI of the RTP header extension, as defined in [[!RFC5285]].</p></dd>
      <dt>unsigned short      preferredId</dt>
         <dd><p>The preferred ID value that goes in the packet.</p></dd>
      <dt>boolean             preferredEncrypt=false</dt>
          <dd><p>If true, it is preferred that the value in the header be 
          encrypted as per [[!RFC6904]].  Default is to prefer unencrypted.</p></dd>
    </dl>
  </section>

  <section id="rtcrtpheaderextensionparameters*">
    <h3>dictionary RTCRtpHeaderExtensionParameters</h3>
    <dl class="idl" title="dictionary RTCRtpHeaderExtensionParameters">
      <dt>DOMString           uri</dt>
         <dd><p>The URI of the RTP header extension, as defined in [[!RFC5285]].</p></dd>
      <dt>unsigned short      id</dt>
         <dd><p>The value that goes in the packet.</p></dd>
      <dt>boolean             encrypt=false</dt>
          <dd><p>If true, the value in the header is encrypted as per [[!RFC6904]].  Default is unencrypted.</p></dd>
    </dl>
  </section>
  <section id="headerextensions*">
    <h3>RTP header extensions</h3>

      <p>Registered RTP header extensions are listed in [[!IANA-RTP-10]].  Header extensions mentioned in [[!RTP-USAGE]] include: 

      <table class="simple">
        <thead>
          <tr>
            <th>Header Extension</th>

            <th>Reference</th>

            <th>Notes</th>
          </tr>
        </thead>
        <tbody>

          <tr id="def-rapid-sync*">
            <td><dfn>Rapid Synchronization</dfn></td>

            <td>
              [[RFC6051]]
            </td>

            <td>This extension enables carriage of an NTP-format timestamp, as defined in [[!RFC6051]] Section 3.3. 
            </td>
           </tr>


          <tr id="def-client-to-mixer*">
            <td><dfn>Client-to-Mixer Audio Level</dfn></td>

            <td>
              [[!RFC6464]]
            </td>

            <td>This extension indicates the audio level of the audio sample carried in an RTP packet.
            </td>
           </tr>
         
           <tr id="def-mixer-to-client*">
            <td><dfn>Mixer-to-Client Audio Level</dfn></td>
            <td>
              [[RFC6465]]
            </td>

            <td>This extension indicates the audio level of individual conference participants.
            </td>
            </tr>
          <tr id="def-mid*">
            <td><dfn>MID</dfn></td>
            <td>
              [[!BUNDLE]]
            </td>

            <td>This extension defines a track identifier which can be used to identify the track corresponding to an RTP stream. 
            </td>
            </tr>

        </tbody>
      </table>

  </section>

  </section>
  </section>
</section>

<section id="rtcdtmfsender*">
  <h2>The RTCDtmfSender Object</h2>

      <div class="note">
        This section of the ORTC API specification depends on the WebRTC 1.0 DtmfSender API, and needs to be synchronized once it is updated.
      </div>

  <section id="rtcdtmfsender-overview*">
    <h3>Overview</h3>
    <p>An <dfn>RTCDtmfSender</dfn> instance allows sending DTMF tones to/from the remote peer, as per [[!RFC4733]].</p>

  </section>

  <section id="rtcdtmfsender-operation*">
    <h3>Operation</h3>

    <p>An <a>RTCDtmfSender</a> object is constructed from an <a>RTCRtpSender</a> object.</p>
  </section>

  <section id="rtcdtmfsender-interface-definition*">
    <h3>Interface Definition</h3>

    <dl class="idl" title="[Constructor(RTCRtpSender sender)] interface RTCDtmfSender">
      <dt>readonly attribute boolean <a>canInsertDTMF</a></dt>
      <dd>
        <p>Whether the <a>RTCDtmfSender</a> is capable of sending DTMF.</p>
      </dd>

        <dt>void insertDTMF(in DOMString tones, optional long duration, long
        interToneGap)</dt>
      <dd></dd>

      <dt>readonly attribute <a>RTCRtpSender</a> sender</dt>
      <dd><p>The <a>RTCRtpSender</a> instance</p></dd>

      <dt>attribute EventHandler ontonechange</dt>
        <dd>
          <p>The <dfn>ontonechange</dfn> event handler uses the
          <a>RTCDTMFToneChangeEvent</a> interface to return the
          character for each tone as it is played out. 
          </p>
        </dd>

      <dt>readonly attribute DOMString toneBuffer</dt>
         <dd>
          <p>The <dfn>toneBuffer</dfn> attribute returns a list of the 
          tones remaining to be played out.</p>
        </dd> 

        <dt>readonly attribute long duration</dt>

        <dd>
          <p>The <dfn>duration</dfn> attribute returns the current tone duration
          value in milliseconds.  This value will be the value last set via the 
          <code>insertDTMF()</code> method, or the default value of 70 ms if
          <code>insertDTMF()</code> was called without specifying the duration.</p>
        </dd>

        <dt>readonly attribute long interToneGap</dt>

        <dd>
          <p>The <dfn>interToneGap</dfn> attribute returns the current value of
          the between-tone gap.  This value will be the value last set via the
          <code>insertDTMF()</code> method, or the default value of 70
          ms if <code>insertDTMF()</code> was called without specifying
          the <code>interToneGap.</code></p>
        </dd>

    </dl>

    </section>

    <section>
      <h3>RTCDTMFToneChangeEvent</h3>

      <p>The tonechange event uses the
      <a>RTCDTMFToneChangeEvent</a> interface.</p>

      <p> Firing an tonechange event named
      <var>e</var> with a DOMString <var>tone</var> means
      that an event with the name <var>e</var>, which does not bubble (except
      where otherwise stated) and is not cancelable (except where otherwise
      stated), and which uses the <a>RTCDTMFToneChangeEvent</a>
      interface with the <a>tone</a>
      attribute set to
      <var>tone</var>, MUST be created and dispatched at the given target.</p>

       <dl class="idl" data-merge="RTCDTMFToneChangeEventInit" title=
      "[Constructor(DOMString type, RTCDTMFToneChangedEventInit eventInitDict)] interface RTCDTMFToneChangeEvent : Event">
        <dt>readonly attribute DOMString tone</dt>
        <dd>
          <p>The <dfn>tone</dfn>
          attribute contains the character for the tone that has just begun
          playout (see <code>insertDTMF()</code>).  If the value is the
          empty string, it indicates that the previous tone has completed
          playback.</p>
        </dd>
      </dl>
      <dl class="idl" title=
      "dictionary RTCDTMFToneChangeEventInit : EventInit">
        <dt>DOMString tone=""</dt>
        <dd>
          <p>The <a>tone</a> parameter is treated as a series of characters. 
          The characters 0 through 9, A through D, #, and * generate the associated DTMF tones. 
          The characters a to d are equivalent to A to D. 
          The character ',' indicates a delay of 2 seconds before processing the next character in the tones parameter. 
          Unrecognized characters are ignored.</p>
        </dd>
      </dl>
    </section>
<section>
      <h3>DTMF Example</h3>


      <p>Examples assume that <var>sendObject</var> is an <code><a>RTCRtpSender</a></code> object.</p>

      <p>Sending the DTMF signal "1234" with 500 ms duration per tone:</p>

      <pre xml:space="preserve" class='example highlight'>
var sender = new RTCDtmfSender(sendObject);
if (sender.canInsertDTMF) {
    var duration = 500;
    sender.insertDTMF("1234", duration);
} else
    log("DTMF function not available");
      
</pre>

      <p>Send the DTMF signal "1234", and light up the active key using
      <code>lightKey(key)</code> while the tone is playing (assuming that
      <code>lightKey("")</code> will darken all the keys):</p>

      <pre xml:space="preserve" class='example highlight'>
var sender = new RTCDtmfSender(sendObject);
sender.ontonechange = function (e) {
    if (!e.tone)
        return;
    // light up the key when playout starts
    lightKey(e.tone);
    // turn off the light after tone duration
    setTimeout(lightKey, sender.duration, "");
};
sender.insertDTMF("1234");
      
</pre>

      <p>Send a 1-second "1" tone followed by a 2-second "2" tone:</p>

      <pre xml:space="preserve" class='example highlight'>
var sender = new RTCDtmfSender(sendObject);
sender.ontonechange = function (e) {
    if (e.tone == "1")
        sender.insertDTMF("2", 2000);
};
sender.insertDTMF("1", 1000);
      
</pre>

      <p>It is always safe to append to the tone buffer. This example appends
      before any tone playout has started as well as during playout.</p>

      <pre xml:space="preserve" class='example highlight'>
var sender = new RTCDtmfSender(sendObject);
sender.insertDTMF("123");
// append more tones to the tone buffer before playout has begun
sender.insertDTMF(sender.toneBuffer + "456");

sender.ontonechange = function (e) {
    if (e.tone == "1")
        // append more tones when playout has begun
        sender.insertDTMF(sender.toneBuffer + "789");
};
      
</pre>

      <p>Send the DTMF signal "123" and abort after sending "2".</p>

      <pre xml:space="preserve" class='example highlight'>
var sender = new RTCDtmfSender(sendObject);
sender.ontonechange = function (e) {
    if (e.tone == "2")
        // empty the buffer to not play any tone after "2"
        sender.insertDTMF("");
};
sender.insertDTMF("123");
      
</pre>
    </section>
</section>

<section id="rtcdatachannel*">
  <h2>The RTCDataChannel Object</h2>

  <section id="rtcdatachannel-overview*">
    <h3>Overview</h3>

    <p>
      An <dfn>RTCDataChannel</dfn> class instance allows sending data messages to/from the remote peer.
    </p>
  </section>

  <section id="rtcdatachannel-operation*">
    <h3>Operation</h3>

    <p>An <code><a>RTCDataChannel</a></code> object is constructed from an <code><a>RTCDataTransport</a></code> object and
an <code><a>RTCDataChannelParameters</a></code> object.</p>
  </section>

  <section id="rtcdatachannel-interface-definition*">
    <h3>Interface Definition</h3>

    <p>The <code><a>RTCDataChannel</a></code> interface represents a bi-directional data channel between 
    two peers.  
    There are two ways to establish a connection with <code><a>RTCDataChannel</a></code>. 
    The first way is to construct an <code><a>RTCDataChannel</a></code> at one of the peers with the 
    <code><a>RTCDataChannelParameters</a></code>.<a>negotiated</a> attribute unset or set to its default value false.    
    This will announce the new channel in-band and trigger an <a>ondatachannel</a> event with the 
     corresponding <code><a>RTCDataChannel</a></code> object at the other peer. 
     The second way is to let the application negotiate the <code><a>RTCDataChannel</a></code>. 
      To do this, create an <code><a>RTCDataChannel</a></code> object with the <code><a>RTCDataChannelParameters</a></code>.<a>negotiated</a>
     dictionary member set to true, and signal out-of-band (e.g. via a web server) to the other 
     side that it should create a corresponding <code><a>RTCDataChannel</a></code> with the 
     <code><a>RTCDataChannelParameters</a></code>.<a>negotiated</a> dictionary member set to true and the same id. 
     This will connect the two separately created <code><a>RTCDataChannel</a></code> objects. 
     The second way makes it possible to create channels with asymmetric properties and to 
     create channels in a declarative way by specifying matching ids.

     Each <code><a>RTCDataChannel</a></code> has an associated <dfn>underlying data transport</dfn> that is used 
     to transport actual data to the other peer. 
     The transport properties of the underlying data transport, such as in order delivery 
     settings and reliability mode, are configured by the peer as the channel is created. 
     The properties of a channel cannot change after the channel has been created. 
</p>
    <dl class="idl" title="[Constructor(RTCDataTransport transport, RTCDataChannelParameters parameters)] interface RTCDataChannel : EventTarget">
      <dt>readonly attribute RTCDataTransport           transport</dt>
      <dd><p>The readonly attribute referring to the related transport object.</p></dd>
      <dt>readonly attribute RTCDataChannelParameters parameters</dt>
      <dd><p>The parameters applying to this data channel.</p></dd>
      <dt>readonly attribute RTCDataChannelState readyState</dt>
      <dd><p>The <dfn id="dom-datachannel-readystate"><code>readyState</code></dfn> attribute represents the state of the <a>RTCDataChannel</a> object. 
      It <em class="rfc2119" title="MUST">MUST</em> return the value to which the user agent last set it (as defined by the processing model algorithms).
      </p></dd>
      <dt>readonly attribute unsigned long bufferedAmount</dt>
      <dd><p>The <dfn id="dom-datachannel-buffereamount"><code>bufferedAmount</code></dfn> attribute 
      <em class="rfc2119" title="MUST">MUST</em> return the number of bytes of application data 
      (UTF-8 text and binary data) that have been queued using send() but that, as of the last time 
      the event loop started executing a task, had not yet been transmitted to the network. 
      This includes any text sent during the execution of the current task, regardless of whether the 
      user agent is able to transmit text asynchronously with script execution. 
      This does not include framing overhead incurred by the protocol, or buffering done by the 
      operating system or network hardware. 
      If the channel is closed, this attribute's value will only increase with each call to the 
      send() method (the attribute does not reset to zero once the channel closes).
      </p></dd>
      <dt>attribute DOMString binaryType</dt>
      <dd><p>The <dfn id="dom-datachannel-binarytype"><code>binaryType</code></dfn> attribute 
      <em class="rfc2119" title="MUST">MUST</em>, on getting, return the value to which it was last set. 
      On setting, the user agent <em class="rfc2119" title="MUST">MUST</em> set the IDL attribute to the new value. 
      When an <a>RTCDataChannel</a> object is constructed, the <code>binaryType</code> attribute 
      <em class="rfc2119" title="MUST">MUST</em> be initialized to the string 'blob'.
      This attribute controls how binary data is exposed to scripts. 
      See the [[WEBSOCKETS-API]] for more information.
      </p></dd>
      <dt>void close()</dt>
      <dd><p>Closes the <a>RTCDataChannel</a>. 
      It may be called regardless of whether the <a>RTCDataChannel</a> object was created by this peer or the remote peer.
      When the <code>close()</code> method is called, the user agent 
      <em class="rfc2119" title="MUST">MUST</em> run the following steps:</p>
<p>1. Let channel be the <a>RTCDataChannel</a> object which is about to be closed.</p>
<p>2. If channel's <code>readyState</code> is closing or closed, then abort these steps.</p>
<p>3. Set channel's <code>readyState</code> attribute to closing.</p>
<p>4. If the closing procedure has not started yet, start it.</p>
      </dd>
      <dt>attribute EventHandler          onopen</dt>
      <dd><p>This event handler, of event handler type <code>open</code>, 
      <em class="rfc2119" title="MUST">MUST</em> be supported by all objects implementing the RTCDataChannel interface.</p></dd>
      <dt>attribute EventHandler          onerror</dt>
      <dd><p>This event handler, of event handler type <code>error</code>, 
      <em class="rfc2119" title="MUST">MUST</em> be supported by all objects implementing the RTCDataChannel interface.</p></dd>
      <dt>attribute EventHandler          onclose</dt>
      <dd><p>This event handler, of event handler type <code>close</code>, 
      <em class="rfc2119" title="MUST">MUST</em> be supported by all objects implementing the RTCDataChannel interface.</p></dd>
      <dt>attribute EventHandler          onmessage</dt>
      <dd>
        <p>This event handler, of event handler event type <code>message</code>, 
      <em class="rfc2119" title="MUST">MUST</em> be fired to 
      allow a developer's JavaScript to receive data from a remote peer.</p>

        <table border="1">
          <tr>
            <td><em>Event Argument</em></td>
            <td><em>Description</em></td>
          </tr>
          <tr>
            <td>Object data</td>
            <td>The received remote data.</td>
          </tr>
        </table>
      </dd>
      <dt>void send (DOMString data)</dt>
      <dd><p>Run the steps described by the <code>send()</code> algorithm with argument type <code>string</code> object.</p></dd>
      <dt>void send (Blob data)</dt>
      <dd><p>Run the steps described by the <code>send()</code> algorithm with argument type <code>Blob</code> object.</p></dd>
      <dt>void send (ArrayBuffer data)</dt>
      <dd><p>Run the steps described by the <code>send()</code> algorithm with argument type <code>ArrayBuffer</code> object.</p></dd>
      <dt>void send (ArrayBufferView data)</dt>
      <dd><p>Run the steps described by the <code>send()</code> algorithm with argument type <code>ArrayBufferView</code> object.</p></dd>
    </dl>
  </section>

  <section id="rtcdatatransport-interface-definition*">
    <h3>Interface Definition</h3>

    <dl class="idl" title="interface RTCDataTransport : RTCStatsProvider">
    </dl>
  </section>

  <section id="rtcdatachannelstate*">
    <h3>enum RTCDataChannelState</h3>

      <dl class="idl" title="enum RTCDataChannelState">
        <dt>connecting</dt>
        <dd><p>The user agent is attempting to establish the underlying data transport.
        This is the initial state of an <a>RTCDataChannel</a> object.</p></dd>
        <dt>open</dt>
        <dd><p>The underlying data transport is established and communication is possible.
        This is the initial state of an <a>RTCDataChannel</a> object dispatched as a
        part of an RTCDataChannelEvent.</p></dd>
        <dt>closing</dt>
        <dd><p>The procedure to close down the underlying data transport has started.</p></dd>
        <dt>closed</dt>
        <dd><p>The underlying data transport has been closed or could not be established.</p></dd>
      </dl>
  </section>

<section id="rtcdatachannelparameters*">
    <h3>dictionary RTCDataChannelParameters</h3>
    <p>An <a>RTCDataChannel</a> can be configured to operate in different reliability modes. 
    A reliable channel ensures that the data is delivered at the other peer through retransmissions. 
    An unreliable channel is configured to either limit the number of retransmissions (maxRetransmits ) or set 
    a time during which transmissions (including retransmissions) are allowed (maxPacketLifeTime). 
    These properties can not be used simultaneously and an attempt to do so will result in an error. 
    Not setting any of these properties results in a reliable channel.</p>

    <dl class="idl" title="dictionary RTCDataChannelParameters">
      <dt>DOMString label=""</dt>
      <dd><p>The <dfn>label</dfn> attribute represents a label that can be used to distinguish this <a>RTCDataChannel</a> object from other <a>RTCDataChannel</a> objects. 
      The attribute <em class="rfc2119" title="MUST">MUST</em> return the value to which it was set when the <a>RTCDataChannel</a> object was constructed.
      For an SCTP data channel, the label is carried in the DATA_CHANNEL_OPEN message defined in 
      [[!DATA-PROT]] Section 5.1.</p></dd>
      <dt>boolean                  ordered=true</dt>
         <dd><p>The <dfn id="dom-datachannel-ordered"><code>ordered</code></dfn> 
         attribute returns true if the <a>RTCDataChannel</a> is ordered, and 
         false if out of order delivery is allowed.  Default is true.
         The attribute <em class="rfc2119" title="MUST">MUST</em> return the value to which it was set when the
         <a>RTCDataChannel</a> was constructed.
      </p></dd>
      <dt>unsigned short          maxPacketLifetime</dt>
         <dd><p>The <dfn id="dom-datachannel-maxpacketlifetime"><code>maxPacketLifetime</code></dfn> 
         attribute represents the length of the time window (in milliseconds) during which
         retransmissions may occur in unreliable mode, or null if unset.
         The attribute <em class="rfc2119" title="MUST">MUST</em> return the value to which it was set when the
         <a>RTCDataChannel</a> was constructed.</p></dd>
      <dt>unsigned short          maxRetransmits</dt>
         <dd><p>The <dfn id="dom-datachannel-maxretransmits"><code>maxRetransmits</code></dfn> 
         attribute returns the maximum number of 
         retransmissions that are attempted in unreliable mode, or null if unset. 
         The attribute <em class="rfc2119" title="MUST">MUST</em> be initialized to null by default and 
         <em class="rfc2119" title="MUST">MUST</em> return the 
         value to which it was set when the <a>RTCDataChannel</a> was constructed.
      </p></dd>
      <dt>DOMString               protocol=""</dt>
          <dd><p>The name of the sub-protocol used with this <a>RTCDataChannel</a> if any,
          or the empty string otherwise (in which case the protocol is unspecified).
          The attribute <em class="rfc2119" title="MUST">MUST</em> return the value to which it was set when the
          <a>RTCDataChannel</a> was constucted.  Sub-protocols are registered in the 
          'Websocket Subprotocol Name Registry' created in [[RFC6455]] Section 11.5.</p></dd>
      <dt>boolean                 negotiated=false</dt>
          <dd><p>The <dfn id="dom-datachannel-negotiated"><code>negotiated</code></dfn> 
          attribute returns true if this <a>RTCDataChannel</a> 
          was negotiated by the application, or false otherwise.  The attribute <em class="rfc2119" title="MUST">MUST</em> 
          be initialized to <code>false</code> by default and <em class="rfc2119" title="MUST">MUST</em> return the value to which it 
          was set when the <a>RTCDataChannel</a> was constructed.
          If set to true, the application developer <em class="rfc2119" title="MUST">MUST</em> signal to the remote peer to 
          construct an <a>RTCDataChannel</a> object with the same id for the data channel 
          to be open. 
          If set to false, the remote party will receive an ondatachannel event with 
          a system constructed <a>RTCDataChannel</a> object.  
      </p></dd>
      <dt>unsigned short        id</dt>
      <dd><p>The id attribute returns the id for this <a>RTCDataChannel</a>, or null if unset.  
      The id was either assigned by the user agent at channel creation time or was selected by the script.                             
      For SCTP, the id represents a stream identifier, as discussed in [[!DATA]] Section 6.5.  
      The attribute <em class="rfc2119" title="MUST">MUST</em> return the value to which it was set when the 
      <a>RTCDataChannel</a> was constructed.</p></dd>
    </dl>
</section>
</section>

<section id="sctp-transport*">
  <h2>The RTCSctpTransport Object</h2>

    <p>
      The <dfn>RTCSctpTransport</dfn> includes information relating to Stream Control Transmission Protocol (SCTP) transport.
    </p>

  <section id="sctp-transport-overview*">
    <h3>Overview</h3>

    <p>An <a>RTCSctpTransport</a> inherits from an <a>RTCDataTransport</a> object, which is associated to an <a>RTCDataChannel</a> object.</p>
  </section>

  <section id="sctptransport-operation*">
    <h3>Operation</h3>

    <p>An <a>RTCSctpTransport</a> is constructed from an <a>RTCDtlsTransport</a> object.</p>
  </section>

  <section id="sctptransport-interface-definition*">
    <h3>Interface Definition</h3>

    <dl class="idl" title="[Constructor(RTCDtlsTransport transport)] interface RTCSctpTransport : RTCDataTransport">
      <dt>readonly attribute <a>RTCDtlsTransport</a>                    transport</dt>
      <dd><p>The <a>RTCDtlsTransport</a> instance the <a>RTCSctpTransport</a> object is sending over.</p></dd>
      <dt>static <a>RTCSctpCapabilities</a> getCapabilities()</dt>
      <dd><p>Retrieves the <a>RTCSctpCapabilities</a> of the <a>RTCSctpTransport</a> instance.</p></dd>

      <dt>void start(<a>RTCSctpCapabilities</a> remoteCaps)</dt>
      <dd></dd>

      <dt>void stop()</dt>
      <dd><p>Stops the <a>RTCSctpTransport</a> instance.</p></dd>

    <dt>attribute EventHandler       ondatachannel</dt>
    <dd><p>
    The <dfn>ondatachannel</dfn> event handler, of type <code>datachannel</code>, <em class="rfc2119" title="MUST">MUST</em> be
    supported by all objects implementing the
    <code><a>RTCSctpTransport</a></code> interface.
    If the remote peers sets <code><a>RTCDataChannelParameters</a></code>.<code><a>negotiated</a></code> to false, 
    then the event will fire indicating a new <code><a>RTCDataChannel</a></code> object has been 
    constructed to connect with the <code><a>RTCDataChannel</a></code> constructed by the remote peer.
    </p></dd>
    </dl>

  <section id="rtcsctpcapabilities*">
    <h3>dictionary RTCSctpCapabilities</h3>
    <dl class="idl" title="dictionary RTCSctpCapabilities">
      <dt>unsigned short    maxMessageSize</dt>
      <dd><p>Maximum message size.</p></dd>
    </dl>
  </section>
</section>

    <section>
      <h3>RTCDataChannelEvent</h3>

      <p>The <code><a href="#event-datachannel">datachannel</a></code> event
      uses the <code><a>RTCDataChannelEvent</a></code> interface.</p>

      <p><dfn id="fire-a-datachannel-event" title=
      "fire a datachannel event">Firing a datachannel event named
      <var>e</var></dfn> with a <code><a>RTCDataChannel</a></code>
      <var>channel</var> means that an event with the name <var>e</var>, which
      does not bubble (except where otherwise stated) and is not cancelable
      (except where otherwise stated), and which uses the
      <code><a>RTCDataChannelEvent</a></code> interface with the <code><a href=
      "#dom-datachannelevent-channel">channel</a></code> attribute set to
      <var>channel</var>, MUST be created and dispatched at the given
      target.</p>

       <dl class="idl" data-merge="RTCDataChannelEventInit" title=
      "[Constructor(DOMString type, RTCDataChannelEventInit eventInitDict)] interface RTCDataChannelEvent : Event">
        <dt>readonly attribute RTCDataChannel channel</dt>
        <dd>
          <p>The <dfn id=
          "dom-datachannelevent-channel"><code>channel</code></dfn> attribute
          represents the <code><a>RTCDataChannel</a></code> object associated
          with the event.</p>
        </dd>
      </dl>

      <dl class="idl" title="dictionary RTCDataChannelEventInit : EventInit">
        <dt>RTCDataChannel channel</dt>
        <dd>
          <p>TODO</p>
        </dd>
      </dl>
    </section>

  <section id=rtcsctpexample*">
    <h2>Example</h2>

<pre class="example"><code>
function initiate(signaller) {
  var dtls = ...;  // See ICE/DTLS example.
  var sctp = new RTCSctpTransport(dtls);
  var parameters = ...; // Construct RTCDataChannelParameters object

  signaller.sendInitiate({
    // ... include ICE/DTLS info from other example.
  "sctpCapabilities": RTCSctpTransport.getCapabilities()
  }, function(remote) {
    sctp.start(remote.sctpCapabilities);
  });

  var channel = new RTCDataChannel (sctp, parameters); 
  channel.send("foo");
}

function accept(signaller, remote) {
  var dtls = ...;  // See ICE/DTLS example.
  signaller.sendAccept({
    // ... include ICE/DTLS info from other example.
    "sctpCapabilities": RTCSctpTransport.getCapabilities()
  });

  var sctp = new RTCSctpTransport(dtls);
  sctp.start(remote.sctpCapabilties);

  // Assume in-band signalling.  We could also easily add
  // RTCDataChannelParameters into the out-of-band signalling
  // And construct the data channel with with negotiated: true.

  sctp.ondatachannel = function(channel) {
    channel.onmessage = function(message) {
    if (message == "foo") {
      channel.send("bar");
    }
  }
}
</code></pre>

</section>
</section>

    <section>
      <h3>Statistics API</h3>

      <p>The Statistics API enables retrieval of statistics relating to <code><a>RTCRtpSender</a></code>, 
      <code><a>RTCRtpReceiver</a></code>, 
      <code><a>RTCDtlsTransport</a></code>, <code><a>RTCIceTransport</a></code> and 
      <code><a>RTCSctpTransport</a></code> objects.</p>

      <div class="note">
        This section of the ORTC API specification depends on the WebRTC 1.0 Statistics API, and needs to be synchronized once it is updated.
      </div>

      <dl class="idl" title="interface RTCStatsProvider">
        <dt>Promise&lt;RTCStatsReport> getStats()</dt>

        <dd>
          <p>Gathers stats for the given object
          and reports the result asynchronously.</p>

          <p>When the
          <dfn>getStats()</dfn> method is
          invoked, the user agent MUST queue a task to run the following
          steps:</p>

          <ol>
            <li>
              <p>If the object's 
              <code>RTCRtpParameters.RTCRtpEncodingParameters.active</code> state is <code>false</code>, throw an
              <code>InvalidStateError</code> exception.</p>
            </li>


            <li>
              <p>Return, but continue the following steps in the
              background.</p>
            </li>

            <li>
              <p>Start gathering the stats.</p>
            </li>

            <li>
              <p>When the relevant stats have been gathered, return a 
              new <code><a>RTCStatsReport</a></code> object, representing the
              gathered stats.</p>
            </li>
          </ol>
        </dd>
      </dl>

    <section>
      <h4>RTCStatsReport Object</h4>

      <p>The <code><a>getStats()</a></code>
      method delivers a successful result in the form of a
      <code><a>RTCStatsReport</a></code> object. A
      <code><a>RTCStatsReport</a></code> object represents a map between
      strings, identifying the inspected objects (<a href=
      "#dom-rtcstats-id">RTCStats.id</a>), and their corresponding
      <code><a>RTCStats</a></code> objects.</p>

      <p>An <code><a>RTCStatsReport</a></code> may be composed of several
      <code><a>RTCStats</a></code> objects, each reporting stats for one
      underlying object.
      One achieves the total for the object by summing over all stats of a 
      certain type; for instance, if an <a>RTCRtpSender</a> object is sending
      RTP streams involving multiple SSRCs over the network, the
      <code><a>RTCStatsReport</a></code> may contain one <code>RTCStats</code>
      object per SSRC (which can be distinguished by the value of the "ssrc"
      stats attribute).</p>

      <dl class="idl" title="interface RTCStatsReport">
        <dt>getter RTCStats (DOMString id)</dt>
        <dd>
          <p>Getter to retrieve the <code><a>RTCStats</a></code> objects that
          this stats report is composed of.</p>

          <p>The set of supported property names [[!WEBIDL]] is defined as the
          ids of all the <code><a>RTCStats</a></code> objects that has been
          generated for this stats report. The order of the property names is
          left to the user agent.</p>
        </dd>
      </dl>
    </section>

    <section>
      <h4>RTCStats Dictionary</h4>
      <p>An <code><a>RTCStats</a></code> dictionary represents the stats
      gathered by inspecting a specific object.
      The <code><a>RTCStats</a></code>
      dictionary is a base type that specifies as set of default attributes,
      such as <a href="#dom-rtcstats-timestamp">timestamp</a> and <a href=
      "#dom-rtcstats-type">type</a>. Specific stats are added by extending the
      <code><a>RTCStats</a></code> dictionary.</p>

      <p>Note that while stats names are standardized, any given implementation
      may be using experimental values or values not yet known to the Web
      application. Thus, applications MUST be prepared to deal with unknown
      stats.</p>

      <div class="note">
        OPEN ISSUE: Need to define an IANA registry for this and populate with
        pointers to existing things such as the RTCP statistics.
      </div>

      <p>Statistics need to be synchronized with each other in order to yield
      reasonable values in computation; for instance, if "bytesSent" and
      "packetsSent" are both reported, they both need to be reported over the
      same interval, so that "average packet size" can be computed as "bytes /
      packets" - if the intervals are different, this will yield errors. Thus
      implementations MUST return synchronized values for all stats in a
      <code><a>RTCStats</a></code> object.</p>

      <dl class="idl" title="dictionary RTCStats">
        <dt>DOMHiResTimeStamp timestamp</dt>

        <dd>
          R<p>The <dfn id="dom-rtcstats-timestamp"><code>timestamp</code></dfn>,
          of type <code>DOMHiResTimeStamp</code> [[!HIGHRES-TIME]], associated
          with this object. The time is relative to the UNIX epoch (Jan 1,
          1970, UTC).</p>
        </dd>

        <dt>RTCStatsType type</dt>
        <dd>
          <p>The type of this object.</p>
          <p>The <dfn id="dom-rtcstats-type"><code>type</code></dfn> attribute
          MUST be initialized to the name of the most specific type this
          <code><a>RTCStats</a></code> dictionary represents.</p>
        </dd>
        <dt>DOMString id</dt>
        <dd>
          <p>A unique <dfn id="dom-rtcstats-id"><code>id</code></dfn> that is
          associated with the object that was inspected to produce this
          <code><a>RTCStats</a></code> object. Two <code><a>RTCStats</a></code>
          objects, extracted from two different
          <code><a>RTCStatsReport</a></code> objects, MUST have the same id if
          they were produced by inspecting the same underlying object. User
          agents are free to pick any format for the id as long as it meets the
          requirements above.</p>

          <div class="note">
            Consider naming id something that indicates that the id refers to
            the underlying object that was inspected to produce the stats,
            instead of being an id for the JavaScript object. Suggestions:
            statsObjectId, reporterId, srcId.
          </div>
        </dd>
      </dl>

  <section id="rtcstatstype*">
      <h3>enum RTCStatsType</h3>

      <dl class="idl" title="enum RTCStatsType">
        <dt>inboundrtp</dt>
        <dd><p>Inbound RTP.  Relevant to <code><a>RTCRtpReceiver</a></code> objects.</p></dd>
        <dt>outboundrtp</dt>
        <dd><p>Outbound RTP.  Relevant to <code><a>RTCRtpSender</a></code> objects.</p></dd>
        <dt>session</dt>
        <dd><p></p></dd>
        <dt>track</dt>
        <dd><p></p></dd>
        <dt>transport</dt>
        <dd><p>Transport statistics.  Relevant to <code><a>RTCDtlsTransport</a></code> objects.</p></dd>
        <dt>candidatepair</dt>
        <dd><p>ICE candidate pair statistics.  Relevant to <code><a>RTCIceTransport</a></code> objects.</p></dd>
        <dt>localcandidate</dt>
        <dd><p>ICE local candidate statistics.  Relevant to <code><a>RTCIceTransport</a></code> objects.</p></dd>
        <dt>remotecandidate</dt>
        <dd><p>ICE remote candidate statistics.  Relevant to <code><a>RTCIceTransport</a></code> objects.</p></dd>
      </dl>
    </section>
   </section>
    <section>
      <h4>Derived Stats Dictionaries</h4>

    <section>
       <h3>RTCRtpStreamStats</h3>
       <p></p>
      <dl class="idl" title="dictionary RTCRTPStreamStats : RTCStats">
        <dt>DOMString ssrc</dt>
        <dd>
          <p>...</p>
        </dd>
        <dt>DOMString remoteId</dt>
        <dd>
          <p>The <code>remoteId</code> can be used to look up the corresponding
          <code><a>RTCStats</a></code> object that represents stats reported by
          the other peer.</p>
        </dd>
        <dt>boolean isRemote = false</dt>
        <dd><p></p></dd>
        <dt>DOMString mediaTrackId</dt>
        <dd><p></p></dd>
        <dt>DOMString transportId</dt>
        <dd><p></p></dd>
        <dt>DOMString codecId</dt>
        <dd><p></p></dd>
        <dt>unsigned long firCount</dt>
        <dd><p>Count of FIR packets, defined in [[!RFC5104]] Section 4.3.1.
        We are not counting the FIR defined in RFC 2032 Section 5.2.1, which was deprecated in [[RFC4587]]. 
        </p></dd>
        <dt>unsigned long pliCount</dt>
        <dd><p>Count of PLI packets, defined in [[!RFC4585]] Section 6.3.1.</p></dd>
        <dt>unsigned long nackCount</dt>
        <dd><p>Count of NACK packets, defined in [[!RFC4585]] Section 6.2.1.</p></dd>
        <dt>unsigned long sliCount</dt>
        <dd><p>Count of SLI packets, defined in [[!RFC4585]] Section 6.3.2.</p></dd>
      </dl>
    </section>

    <section>
       <h3>RTCInboundRTPStreamStats</h3>
       <p><dfn>RTCInboundRTPStreamStats</dfn> are relevant to <code><a>RTCRtpReceiver</a></code> objects.</p>
      <dl class="idl" title=
      "dictionary RTCInboundRTPStreamStats : RTCRTPStreamStats">
        <dt>unsigned long packetsReceived</dt>
        <dd>
          <p>Packets received.</p>
        </dd>
        <dt>unsigned long long bytesReceived</dt>
        <dd>
          <p>Bytes received.</p>
        </dd>
        <dt>unsigned long packetsLost</dt>
        <dd>
          <p>Packets lost.</p>
        </dd>
        <dt>double jitter</dt>
        <dd>
          <p>Jitter, as calculated in [[!RFC3550]] Section 6.4.1, but given in seconds.</p>
        </dd>
      </dl>
     </section>

    <section>
       <h3>RTCOutboundRTPStreamStats</h3>
       <p><dfn>RTCOutboundRTPStreamStats</dfn> are relevant to <code><a>RTCRtpSender</a></code> objects.</p>
      <dl class="idl" title=
      "dictionary RTCOutboundRTPStreamStats : RTCRTPStreamStats">
        <dt>unsigned long packetsSent</dt>
        <dd>
          <p>Packets sent.</p>
        </dd>
        <dt>unsigned long long bytesSent</dt>
        <dd>
          <p>Bytes sent.</p>
        </dd>
        <dt>double targetBitrate</dt>
       <dd>
       <p>Presently configured bitrate target of this SSRC, in bits per second.
       Typically this is a configuration parameter of the codec's encoder.
       </p>
       </dd>
        <dt>double roundTripTime</dt>
        <dd>
          <p>Estimated round trip time (seconds) based on the RTCP timestamp, as described
          in [[!RFC3550]] Section 6.4.1.</p>
        </dd>
      </dl>
    </section>

    <section>
       <h3>RTCMediaStreamTrackStats</h3>
       <p><dfn>RTCMediaStreamTrackStats</dfn> are relevant to <code>MediaStreamTrack</code>s.</p>
      <dl class="idl" title=
      "dictionary RTCMediaStreamTrackStats : RTCStats">
        <dt>DOMString trackIdentifier</dt>
        <dd>
          <p>track.id property</p>
        </dd>
        <dt>boolean remoteSource</dt>
        <dd>
           <p></p>
        </dd>
        <dt>sequence&lt;DOMString> ssrcIds</dt>
        <dd>
          <p>SSRCs.</p>
        </dd>
        <dt>unsigned long frameWidth</dt>
       <dd>
       <p></p>
       </dd>
       <dt>unsigned long frameHeight</dt>
       <dd>
       <p></p>
       </dd>
        <dt>double framesPerSecond</dt>
        <dd>
          <p>The nominal FPS value.</p>
        </dd>
       <dt>unsigned long framesSent</dt>
       <dd>
       <p></p>
       </dd>
       <dt>unsigned long framesReceived</dt>
       <dd>
       <p>Only makes sense for remoteSource=true.</p>
       </dd>
       <dt>unsigned long framesDecoded</dt>
       <dd>
       <p></p>
       </dd>
       <dt>unsigned long framesDropped</dt>
       <dd>
       <p>Same definition as droppedVideoFrames in media-source VideoPlaybackQuality</p>
       </dd>
       <dt>unsigned long framesCorrupted</dt>
       <dd>
       <p></p>
       </dd>
        <dt>double audioLevel</dt>
        <dd>
          <p>Values 0..1, linear, with 1.0 = 0dBov as defined in [[!RFC6464]]. 
        </dd>
        <dt>double echoReturnLoss</dt>
        <dd>
          <p>As defined in G.168 (2012) Section 3.14, in decibels.</p>
        </dd>
        <dt>double echoReturnLossEnhancement</dt>
        <dd>
          <p>As above, Section 3.15.</p>
        </dd>
      </dl>
    </section>

    <section>
       <h3>RTCMediaStreamStats</h3>
       <p><dfn>RTCMediaStreamStats</dfn> are relevant to <code>MediaStream</code>s.</p>

      <dl class="idl" title=
      "dictionary RTCMediaStreamStats : RTCStats">
        <dt>DOMString streamIdentifier</dt>
        <dd>
          <p>stream.id property</p>
        </dd>
         <dt>sequence&lt;DOMString> trackIds</dt>
        <dd>
          <p>This is the id of the stats object, not the track.id</p>
        </dd>
       </dl>
      </section>

    <section>
       <h3>RTCDataChannelStats</h3>
       <p><dfn>RTCDataChannelStats</dfn> are relevant to <code>RTCDataChannel</code>s.</p>

      <dl class="idl" title=
      "dictionary RTCDataChannelStats : RTCStats">
        <dt>DOMString label</dt>
        <dd>
          <p></p>
        </dd>
        <dt>DOMString protocol</dt>
        <dd>
          <p></p>
        </dd>
        <dt>long datachannelid</dt>
        <dd>
          <p>The 'id' attribute of the <code>RTCDataChannel</code> object.</p>
        </dd>
         <dt>RTCDataChannelState state</dt>
        <dd>
          <p>The state of the <code>RTCDataChannel</code> object.</p>
        </dd>
        <dt>unsigned long long bytesSent</dt>
        <dd>
          <p></p>
        </dd>
        <dt>unsigned long long bytesReceived</dt>
        <dd>
          <p></p>
        </dd>
        <dt>unsigned long messagesSent</dt>
        <dd>
          <p>Number of API 'message' events.</p>
        </dd>
        <dt>unsigned long messagesReceived</dt>
        <dd>
          <p></p>
        </dd>
       </dl>
      </section>

    <section>
       <h3>RTCTransportStats</h3>
       <p><dfn>RTCTransportStats</dfn> are relevant to <code><a>RTCDtlsTransport</a></code> objects.</p>

      <dl class="idl" title=
      "dictionary RTCTransportStats : RTCStats">
        <dt>unsigned long long bytesSent</dt>
        <dd>
          <p></p>
        </dd>
        <dt>unsigned long long bytesReceived</dt>
        <dd>
          <p></p>
        </dd>
        <dt>DOMString rtcpTransportStatsId</dt>
        <dd>
          <p>If RTP and RTCP are not multiplexed, this is the ID of the transport
          that gives stats for the RTCP component, and this record has only the RTP component stats.
          </p>
        </dd>
        <dt>boolean activeConnection</dt>
        <dd>
          <p></p>
        </dd>
        <dt>DOMString selectedCandidatePairId</dt>
        <dd>
          <p></p>
        </dd>
        <dt>DOMString localCertificateId</dt>
        <dd>
          <p></p>
        </dd>
        <dt>DOMString remoteCertificateId</dt>
        <dd>
          <p></p>
        </dd>
       </dl>
      </section>

  <section id="rtcstatsicecandidatepairstate*">
      <h3>enum RTCStatsIceCandidatePairState</h3>
      <p><dfn>RTCStatsIceCandidatePairState</dfn> provides the state of an ICE candidate pair.</p>
      <dl class="idl" title="enum RTCStatsIceCandidatePairState">
        <dt>frozen</dt>
        <dd><p>The candidate pair is frozen.</p></dd>
        <dt>waiting</dt>
        <dd><p>The candidate pair is waiting for a connectivity check to go out.</p></dd>
        <dt>inprogress</dt>
        <dd><p>A connectivity check is in progress.</p></dd>
        <dt>failed</dt>
        <dd><p>The connectivity check has failed.</p></dd>
        <dt>succeeded</dt>
        <dd><p>The connectivity check has succeeded.</p></dd>
        <dt>cancelled</dt>
        <dd><p>The connectivity check has been cancelled.</p></dd>
      </dl>
    </section>

  <section id="rtcicecandidatepairstats*">
      <h3>dictionary RTCIceCandidatePairStats</h3>
      <p><dfn>RTCStatsIceCandidatePairStats</dfn> provides statistics on ICE candidate pairs.</p>
      <dl class="idl" title=
      "dictionary RTCIceCandidatePairStats : RTCStats">
        <dt>DOMString transportId</dt>
        <dd>
          <p></p>
        </dd>
        <dt>DOMString localCandidateId</dt>
        <dd>
          <p></p>
        </dd>
        <dt>DOMString remoteCandidateId</dt>
        <dd>
          <p></p>
        </dd>
        <dt>RTCStatsIceCandidatePairState state</dt>
        <dd>
          <p></p>
        </dd>
        <dt>unsigned long long priority</dt>
        <dd>
          <p></p>
        </dd>
        <dt>boolean nominated</dt>
        <dd>
          <p></p>
        </dd>
        <dt>boolean writable</dt>
        <dd>
          <p></p>
        </dd>
        <dt>boolean readable</dt>
        <dd>
          <p></p>
        </dd>
        <dt>unsigned long long bytesSent</dt>
        <dd>
          <p></p>
        </dd>
        <dt>unsigned long long bytesReceived</dt>
        <dd>
          <p></p>
        </dd>
        <dt>double roundTripTime</dt>
        <dd>
          <p></p>
        </dd>
        <dt>double availableOutgoingBitrate</dt>
        <dd>
          <p>Bits per second, implementation dependent computation.</p>
        </dd>
        <dt>double availableIncomingBitrate</dt>
        <dd>
          <p>Bits per second, implementation dependent computation.</p>
        </dd>
       </dl>
    </section>

  <section id="rtccertificatestats*">
      <h3>dictionary RTCCertificateStats</h3>
      <p><dfn>RTCCertificateStats</dfn> provides information on certificates.</p>
      <dl class="idl" title=
      "dictionary RTCCertificateStats : RTCStats">
        <dt>DOMString fingerprint</dt>
        <dd>
          <p>As defined in RFC 4572 section 5 - the fingerprint value only
          </p>
        </dd>
        <dt>DOMString fingerprintAlgorithm</dt>
        <dd>
          <p>For instance 'sha-256'.</p>
        </dd>
        <dt>DOMString base64Certificate</dt>
        <dd>
          <p>DER-encoded, base-64 representation of the certificate.</p>
        </dd>
        <dt>DOMString issuerCertificateId</dt>
        <dd>
          <p></p>
        </dd>
       </dl>
    </section>

  </section>
    <section>
      <h4>Example</h4>

    <p>Consider the case where the user is experiencing bad sound and the application wants to 
    determine if the cause of it is packet loss.  The following example code might be used:</p>

      <pre class="example highlight" xml:space="preserve">
var mySender = new RTCRtpSender(myTrack); 
var myPreviousReport = null;

// ... wait a bit
setTimeout(function () {
        mySender.getStats().then(function (report) {
        processStats(report);
        myPreviousReport = report;
    });
}, aBit);

function processStats(currentReport) {
    if (myPreviousReport === null) return;
    // currentReport + myPreviousReport are an RTCStatsReport interface
    // compare the elements from the current report with the baseline
    for (var now in currentReport) {
        if (now.type != "outbound-rtp")
            continue;
        // get the corresponding stats from the previous report
        base = myPreviousReport[now.id];
        // base + now will be of RTCRtpStreamStats dictionary type
        if (base) {
            remoteNow = currentReport[now.remoteId];
            remoteBase = myPreviousReport[base.remoteId];
            var packetsSent = now.packetsSent - base.packetsSent;
            var packetsReceived = remoteNow.packetsReceived - remoteBase.packetsReceived;
            // if fractionLost is > 0.3, we have probably found the culprit
            var fractionLost = (packetsSent - packetsReceived) / packetsSent;
        }
    }
}
      </pre>

    </section>
  </section>
 </section>

<section id="identity-api">
  <h2>Identity</h2>

      <div class="note">
This section of the ORTC API specification depends on the WebRTC 1.0 Identity API, 
and needs to be synchronized once it is updated.
      </div>

  <section id="rtcidentity-overview*">
    <h3>Overview</h3>

    <p>An <code><a>RTCIdentity</a></code> instance enables authentication of a DTLS transport using a 
    web-based identity provider (IdP).
The idea is that the initiator acts as the Authenticating Party
(AP) and obtains an identity assertion from the IdP which is then conveyed in signaling.
The responder acts as the Relying Party (RP) and verifies the assertion.
</p>
<p>The interaction with the IdP is designed to decouple the browser from any particular
identity provider, so that the browser need only know how to load the IdP's
Javascript (which is deterministic from the IdP's identity), and the generic protocol
for requesting and verifying assertions.  The IdP provides whatever logic
is necessary to bridge the generic protocol to the IdP's specific requirements.
Thus, a single browser can support any number of identity protocols, including being
forward compatible with IdPs which did not exist at the time the Identity Provider API was implemented.
The generic protocol details are described in [[!RTCWEB-SECURITY-ARCH]].
This section specifices the procedures required to instantiate the IdP proxy,
request identity assertions, and consume the results.
    </p>
  </section>

  <section id="rtcidentity-operation*">
    <h3>Operation</h3>
    <p>A <a>RTCIdentity</a> instance is constructed from an <a>RTCDtlsTransport</a>
       object.</p>
  </section>

      <section>
        <h4 id="sec.identity-proxy-communications">Identity Provider Selection</h4>

        <p>In order to communicate with the IdP, the browser instantiates an
        isolated interpreted context, effectively an invisible IFRAME. The
        initial contents of the context are loaded from a URI derived from the
        IdP's domain name, as described in [[!RTCWEB-SECURITY-ARCH]].</p>

        <p>For purposes of generating assertions, the IdP shall be chosen as
        follows:</p>

        <ol>
          <li>If the <code>getIdentityAssertion()</code> method has been called,
          the IdP provided shall be used.</li>

          <li>If the <code>getIdentityAssertion()</code> method has not been
          called, then the browser can use an IdP configured into the
          browser.</li>
        </ol>

        <p>In order to verify assertions, the IdP domain name and protocol are
        taken from the <code>domain</code> and <code>protocol</code> fields of
        the identity assertion.</p>
      </section>

      <section>
        <h4 id="sec.create-identity-proxy">Instantiating an IdP Proxy</h4>

        <p>The browser creates an IdP proxy by loading an isolated, invisible
        IFRAME with HTML content from the IdP URI. The URI for the IdP is a
        well-known URI formed from the <q>domain</q> and <q>protocol</q>
        fields, as specified in [[!RTCWEB-SECURITY-ARCH]].</p>

        <p>When an IdP proxy is required, the browser performs the following
        steps:</p>

        <ol>
          <li>An invisible, sandboxed IFRAME is created within the browser
          context. The IFRAME <code>sandbox</code> attribute is set to
          "allow-forms allow-scripts allow-same-origin" to limit the
          capabilities available to the IdP.  The browser MUST prevent the IdP
          proxy from navigating the browsing context to a different location.
          The browser MUST prevent the IdP proxy from interacting with the user
          (this includes, in particular, popup windows and user dialogs).</li>

          <li>Once the IdP proxy is created, the browser creates a
          <code>MessageChannel</code> [[!webmessaging]] within the context of
          the IdP proxy and assigns one port from the channel to a variable
          named <var>rtcwebIdentityPort</var> on the <var>window</var>. This
          message channel forms the basis of communication between the browser
          and the IdP proxy.  Since it is an essential security property of the
          web sandbox that a page is unable to insert objects into content from
          another origin, this ensures that the IdP proxy can trust that
          messages originating from <var>window.rtcwebIdentityPort</var> are
          from <code>RTCIdentity</code> and not some other page. This
          protection ensures that pages from other origins are unable to
          instantiate IdP proxies and obtain identity assertions.</li>

          <li>The IdP proxy completes loading and informs the
          <code>RTCIdentity</code> object that it is ready by sending a "READY"
          message to the message channel port [[!RTCWEB-SECURITY-ARCH]].  Once
          this message is received by the <code>RTCIdentity</code> object, the
          IdP is considered ready to receive requests to generate or verify
          identity assertions.</li>
        </ol>

        <p>[TODO: This is not sufficient unless we expect the IdP to protect
        this information. Otherwise, the identity information can be copied
        from a session with "good" properties to any other session with the same
        fingerprint information. Since we want to reuse credentials, that would
        be bad.] The identity mechanism MUST provide an indication to the remote
        side of whether it requires the stream contents to be
        protected. Implementations MUST have an user interface that indicates
        the different cases and identity for these.</p>
      </section>

    <section>
      <h3 id="sec.identity-proxy-assertion-request">Requesting Identity Assertions</h3>

      <p>The identity assertion request process involves the following steps:</p>

      <ol>
        <li>The <code>RTCIdentity</code> instantiates an IdP proxy as
        described in <a href="#sec.identity-proxy-communications">Identity
        Provider Selection section</a> and waits
        for the IdP to signal that it is ready.</li>

        <li>The IdP sends a "SIGN" message to the IdP proxy. This message
        includes the material the
        <code>RTCIdentity</code> object desires to be bound to the user's
        identity.</li>

         <li>If the user has been authenticated by the IdP, and the IdP is
        willing to generate an identity assertion, the IdP generates an identity
        assertion.  This step depends entirely on the IdP.  The methods by which
        an IdP authenticates users or generates assertions is not specified,
        though this could involve interacting with the IdP server or other
        servers.</li>

        <li>The IdP proxy sends a response containing the identity assertion to
        the <code>RTCIdentity</code> object over the message channel.</li>

        <li>The <code>RTCIdentity</code> object MAY store the identity assertion.
        </li>
      </ol>

      <p>The format and contents of the messages that are exchanged are
      described in detail in [[!RTCWEB-SECURITY-ARCH]].</p>

      <p>The IdP proxy can return an "ERROR" response.  If an error is
      encountered, the <code>getIdentityAssertion</code> Promise MUST 
      be rejected.</p>

      <p>The browser SHOULD limit the time that it will allow for this process.
      This includes both the loading of
      the <a href="#sec.identity-proxy-communications">IdP proxy</a> and the
      identity assertion generation.  Failure to do so potentially causes the
      corresponding operation to take an indefinite amount of time.  This timer
      can be cancelled when the IdP produces a response.  The timer running to
      completion can be treated as equivalent to an error from the IdP.</p>

      <p>NOTE: Where RTP and RTCP are not multiplexed, distinct <code>RTCRtpIceTransport</code>,  <code>RTCRtpDtlsTransport</code>
      and <code>RTCIdentity</code> objects can be constructed for RTP and RTCP.
      However, while it is possible for <code>getIdentityAssertion()</code>
      to be called with different values of <var>provider</var>, <var>protocol</var> and <var>username</var> for the RTP and RTCP
      <code>RTCIdentity</code> objects, application developers desiring backward compatibility with WebRTC 1.0 are strongly
      discouraged from doing so, since this is likely to result in an error.</p>

      <section>
        <h4 id="sec.idp-loginneeded">User Login Procedure</h4>

        <p>An IdP could respond to a request to generate an identity assertion
        with a "LOGINNEEDED" error.  This indicates that the site does not have
        the necessary information available to it (such as cookies) to authorize
        the creation of an identity assertion.</p>

        <p>The "LOGINNEEDED" response includes a URL for a page where the
        authorization process can be completed.  This URL is exposed to the
        application through the <code><a href="##">loginUrl</a></code> attribute
        of the <code>RTCIdentityError</code> object.
        This URL might be to a page where a user is able to enter their (IdP)
        username and password, or otherwise provide any information the IdP
        needs to authorize a assertion request.</p>

        <p>An application can load the login URL in an IFRAME or popup; the
        resulting page then provides the user with an opportunity to provide
        information necessary to complete the authorization process.</p>

        <p>Once the authorization process is complete, the page loaded in the
        IFRAME or popup sends a message using <var>postMessage</var>
        [[!webmessaging]] to the page that loaded it (through the <var><a
        href="http://www.w3.org/html/wg/drafts/html/master/browsers.html#dom-opener">window.opener</a></var>
        attribute for popups, or through <var><a
        href="http://www.w3.org/html/wg/drafts/html/master/browsers.html#dom-parent">window.parent</a></var>
        for pages loaded in an IFRAME).  The message MUST be the
        <var>DOMString</var> "LOGINDONE".  This message informs the application
        that another attempt at generating an identity assertion is likely to be
        successful.</p>
      </section>
    </section>

    <section>
      <h3 id="sec.identity-verify-assertion">Verifying Identity Assertions</h3>

      <p>Identity assertion validation happens
      when <code>setIdentityAssertion()</code>
      is invoked. The process runs
      asynchronously.</p>

      <p>The identity assertion validation process involves the following
      steps:</p>

      <ol>
        <li>The <code>RTCIdentity</code> instantiates an IdP proxy as
        described in <a href="#sec.identity-proxy-communications"> Identity
        Provider Selection section </a> and waits
        for the IdP to signal that it is ready.</li>

        <li>The IdP sends a "VERIFY" message to the IdP proxy. This message
        includes the assertion which is to be
        verified.</li>

        <li>The IdP proxy verifies the identity assertion (depending on the
        authentication protocol this could involve interacting with the IDP
        server).</li>

        <li>Once the assertion is verified, the IdP proxy sends a response
        containing the verified assertion results to the
        <code>RTCIdentity</code> object over the message channel.</li>

        <li>The <code>RTCIdentity</code> object validates that the fingerprint
        provided by the IdP in the validation response matches the certificate
        fingerprint that is, or will be, used for communications.  This is done by
        waiting for the DTLS connection to be established and checking
        that the certificate fingerprint on the connection matches the one
        provided by the IdP.</li>

        <li>The <code>RTCIdentity</code> validates that the domain portion
        of the identity matches the domain of the IdP as described in [[!RTCWEB-SECURITY-ARCH]].</li>

        <li>The <code>RTCIdentity</code> stores the assertion in the
        <code><a>peerIdentity</a></code>, and returns an <code>RTCIdentityAssertion</code> object
        when the Promise from <code>setIdentityAssertion()</code> is fulfilled.
        The assertion
        information to be displayed MUST contain the domain name of the IdP as
        provided in the assertion.</li>

        <li>The browser MAY display identity information to a user in browser
        UI.  Any user identity information that is displayed in this fashion
        MUST use a mechanism that cannot be spoofed by content.</li>
      </ol>

      <p>The IdP might fail to validate the identity assertion by providing an
      "ERROR" response to the validation request.  Validation can also fail due
      to the additional checks performed by the browser.  In both cases, the
      process terminates and no identity information is exposed to the
      application or the user.</p>

      <p>The browser MUST cause the Promise of <code>setIdentityAssertion()</code> to be rejected if
      validation of an identity assertion fails for any reason.</p>

      <p>The browser SHOULD limit the time that it will allow for this process.
      This includes both the loading of
      the <a href="#sec.identity-proxy-communications">IdP proxy</a> and the
      identity assertion validation.  Failure to do so potentially causes the
      corresponding operation to take an indefinite amount of time.  This timer
      can be cancelled when the IdP produces a response.  The timer running to
      completion can be treated as equivalent to an error from the IdP.</p>
 
      <p>The format and contents of the messages that are exchanged are
      described in detail in [[!RTCWEB-SECURITY-ARCH]].</p>

      <p>NOTE: Where RTP and RTCP are not multiplexed, it is possible that the assertions for both the RTP and RTCP will be validated, 
      but that the identities will not be equivalent.   For applications requiring backward compatibility with WebRTC 1.0,  
      this MUST be considered an error.  However, if backward compatibility with WebRTC 1.0 is not required the application MAY consider 
      an alternative, such as ignoring the RTCP identity assertion.</p>
    </section>

    <section>
      <h3>RTCIdentity Interface</h3>
      <p>The Identity API is described below.</p>

      <dl class="idl" title="[Constructor(RTCDtlsTransport transport)] interface RTCIdentity">
        <dt>readonly attribute RTCIdentityAssertion? peerIdentity</dt>
        <dd>
          <p><dfn>peerIdentity</dfn> contains the peer identity assertion information if an identity
          assertion was provided and verified.  Once this value is set to a
          non-<var>null</var> value, it cannot change.</p>
        </dd>
        <dt>readonly attribute RTCDtlsTransport transport</dt>
        <dd><p>The <code>RTCDtlsTransport</code> to be authenticated.</p></dd>
        <dt>Promise&lt;DOMString> getIdentityAssertion (DOMString provider, optional DOMString protocol = "default", optional DOMString username)</dt>
        <dd><p>Sets the identity provider to be used for a given
        <code><a>RTCIdentity</a></code> object, and initiates the process of obtaining an identity assertion.
        </p>

          <p>When <dfn>getIdentityAssertion()</dfn> is invoked, the user agent MUST 
          run the following steps:</p>

          <ol>
            <li>
              <p>If <code>transport.state</code>
              is <code>closed</code>, throw an
              <code>InvalidStateError</code> exception and abort these
              steps.</p>
            </li>

            <li>
              <p>Set the current identity provider values to the triplet
              (<code>provider</code>, <code>protocol</code>,
              <code>username</code>).</p>
            </li>

            <li>
              <p>If any identity provider value has changed, discard any stored
              identity assertion.</p>
            </li>
            <li>
              <p><a href="#sec.identity-proxy-assertion-request">Request an
              identity assertion</a> from the IdP.</p>
            </li>
            <li>
              <p>
              If the IdP proxy provides an assertion over the message channel, 
              the Promise is fulfilled, and the assertion is returned (equivalent to <code>onidentityresult</code> in the
        WebRTC 1.0 API).  If the IdP proxy returns an "ERROR" response, the Promise is rejected, and an <code>RTCIdentityError</code> object is returned,
        (equivalent to <code>onidpassertionerror</code> in the WebRTC 1.0 API).
              </p>
            </li>
          </ol>
       </dd>

        <dt>Promise&lt;RTCIdentityAssertion> setIdentityAssertion (DOMString assertion)</dt>
        <dd><p>Validates the identity assertion.  If the Promise is fulfilled, 
        an <code>RTCIdentityAssertion</code> is returned.
        If the Promise is rejected, an <code>RTCIdentityError</code> object is returned, (equivalent to  
        <code>onidpvalidationerror</code> in the WebRTC 1.0 API).</p> 
        </dd>
      </dl>
  </section>

    <section>
      <h3>dictionary RTCIdentityError</h3>
      <dl class="idl" title="dictionary RTCIdentityError">
        <dt>DOMString idp</dt>
        <dd>
          <p>The domain name of the identity provider that is providing the error response.</p>
        </dd>
        <dt>DOMString protocol</dt>
        <dd>
          <p>The IdP protocol that is in use.</p>
        </dd>
        <dt>DOMString? loginUrl</dt>
        <dd>
          <p>An IdP that is unable to generate an identity assertion due to a 
          lack of sufficient user authentication information can provide a URL 
          to a page where the user can complete authentication. 
          If the IdP provides this URL, this attribute includes the value provided 
          by the IdP.</p>
        </dd>
      </dl>
    </section>

    <section>
      <h3>dictionary RTCIdentityAssertion</h3>
      <dl class="idl" title="dictionary RTCIdentityAssertion">
        <dt>DOMString idp</dt>
        <dd>
          <p>A domain name representing the identity provider.</p>
        </dd>
        <dt>DOMString name</dt>
        <dd>
          <p>A representation of the verified peer identity conforming to [[RFC5322]].
          This identity will have been verified via the
          procedures described in [[!RTCWEB-SECURITY-ARCH]].</p>
        </dd>
      </dl>
    </section>

    <section>
      <h3>Example</h3>
      <p>The identity system is designed so that applications need not take any
      special action in order for users to generate and verify identity
      assertions; if a user has configured an IdP into their browser, then the
      browser will automatically request/generate assertions and the other side
      will automatically verify them and display the results. However,
      applications may wish to exercise tighter control over the identity
      system as shown by the following examples.</p>

      <div>
        <p>This example shows how to configure the identity provider and
        protocol, and consume identity assertions.</p>

        <pre xml:space="preserve" class="example highlight">
var iceOptions = ...;
var ice = new RTCIceTransport(iceOptions);
var dtls = new RTCDtlsTransport(ice);
var identity = new RTCIdentity(dtls); 
identity.getIdentityAssertion("example.com", "default", "alice@example.com").then(signalAssertion(assertion) 
 ,function (e) {
    console.log("Could not obtain an Identity Assertion. idp: ",e.idp,"Protocol: ",e.protocol,"loginUrl: ",e.loginUrl); 
}); 

function signalAssertion(assertion){
  mySignalInitiate(
    { "myAssertion": assertion
    }, function (response) {
          identity.setIdentityAssertion(response.myAssertion).then(function (peerAssertion) {
              console.log("Peer identity assertion validated. idp: ",peerAssertion.idp, "name: ", peerAssertion.name); 
              }, function (e) {
                 console.log("Could not validate peer assertion. idp: ", e.idp, "Protocol: ",e.protocol);
          });
    });
}
      </pre>
      </div>
    </section>

</section>

  <section class="informative">
    <h2>Event summary</h2>

    <p>The following events fire on <code><a>RTCDtlsTransport</a></code>
    objects:</p>

    <table border="1" style="border-width:0; width:60%">
      <tr>
        <th>Event name</th>
        <th>Interface</th>
        <th>Fired when...</th>
      </tr>
      <tbody>
        <tr>
          <td><code>error</code></td>
          <td><code><a>Event</a></code>
          </td>

          <td>The <code><a>RTCDtlsTransport</a></code> object has
          received a DTLS Alert.</td>
        </tr>
        <tr>
          <td><dfn id="event-dtlsstatechange"><code>dtlsstatechange</code></dfn></td>
          <td><code><a>RTCDtlsTransportStateChangedEvent</a></code>
          </td>
          <td>The <var>RTCDtlsTransportState</var> changed.</td>
        </tr>
      </tbody>
    </table>

    <p>The following events fire on <code><a>RTCIceTransport</a></code>
    objects:</p>

    <table border="1" style="border-width:0; width:60%">
      <tr>
        <th>Event name</th>
        <th>Interface</th>
        <th>Fired when...</th>
      </tr>
      <tbody>
        <tr>
          <td><code>icestatechange</code></td>
          <td><code><a>RTCIceTransportStateChangedEvent</a></code>
          </td>
          <td>The <var>RTCIceTransportState</var> changed.</td>
        </tr>
        <tr>
          <td><code>icecandidatepairchange</code></td>
          <td><code><a>RTCIceCandidatePairChangedEvent</a></code>
          </td>
          <td>The nominated <var>RTCIceCandidatePair</var> changed.</td>
        </tr>
      </tbody>
    </table>

    <p>The following events fire on <code><a>RTCIceListener</a></code>
    objects:</p>

    <table border="1" style="border-width:0; width:60%">
      <tr>
        <th>Event name</th>
        <th>Interface</th>
        <th>Fired when...</th>
      </tr>
      <tbody>
        <tr>
          <td><code>error</code></td>
          <td><code><a>Event</a></code>
          </td>
          <td>The <code><a>RTCIceListener</a></code> object has
          experienced an ICE gathering failure (such as an authentication failure with TURN credentials).</td>
        </tr>
        <tr>
          <td><code>icecandidate</code></td>
          <td><code><a>RTCIceListener</a></code>
          </td>
          <td>A new <code><a>RTCIceGatherCandidate</a></code> is made available to the script.</td>
        </tr>
      </tbody>
    </table>

    <p>The following events fire on <code><a>RTCRtpSender</a></code>
    objects:</p>

    <table border="1" style="border-width:0; width:60%">
      <tr>
        <th>Event name</th>
        <th>Interface</th>
        <th>Fired when...</th>
      </tr>
      <tbody>
        <tr>
          <td><code>error</code></td>
          <td><code><a>Event</a></code>
          </td>
          <td>An error has been detected within the <code><a>RTCRtpSender</a></code> object.
         This is not used for programmatic exceptions.</td>
        </tr>
        <tr>
          <td><dfn id="event-ssrcconflict"><code>ssrcconflict</code></dfn></td>
          <td><code><a>RTCSsrcConflictEvent</a></code>
          </td>
          <td>An SSRC conflict has been detected.</td>
        </tr>
      </tbody>
    </table>

    <p>The following event fires on <code><a>RTCRtpReceiver</a></code>
    objects:</p>

    <table border="1" style="border-width:0; width:60%">
      <tr>
        <th>Event name</th>
        <th>Interface</th>
        <th>Fired when...</th>
      </tr>
      <tbody>
        <tr>
          <td><code>error</code></td>
          <td><code><a>Event</a></code>
          </td>
          <td>An error has been detected within the <code><a>RTCRtpReceiver</a></code> object,
          such as an issue with <code><a>RTCRtpParameters</a></code> that could not be detected
          until media arrival.   
          This is not used for programmatic exceptions.</td>
        </tr>
      </tbody>
    </table>

    <p>The following events fire on <code><a>RTCRtpListener</a></code>
    objects:</p>

    <table border="1" style="border-width:0; width:60%">
      <tr>
        <th>Event name</th>
        <th>Interface</th>
        <th>Fired when...</th>
      </tr>
      <tbody>
        <tr>
          <td><dfn id=
          "event-RTCRtpListener-unhandledrtp"><code>unhandledrtp</code></dfn>
          </td>

          <td><code><a>RTCRtpUnhandledEvent</a></code>
          </td>

          <td>The <code><a>RTCRtpListener</a></code> object has received an
          RTP packet that it cannot deliver to an <code><a>RTCRtpReceiver</a></code> object.
        </td>
        </tr>
      </tbody>
    </table>

    <p>The following events fire on <code><a>RTCDTMFSender</a></code>
    objects:</p>

    <table border="1" style="border-width:0; width:60%">
      <tr>
        <th>Event name</th>
        <th>Interface</th>
        <th>Fired when...</th>
      </tr>
      <tbody>
        <tr>
          <td><dfn id=
          "event-RTCDTMFSender-tonechange"><code>tonechange</code></dfn>
          </td>

          <td><code><a>Event</a></code>
          </td>

          <td>The <code><a>RTCDTMFSender</a></code> object has either just
          begun playout of a tone (returned as the <code><a>tone</a></code>
          attribute) or just ended playout of a tone (returned as an empty
          value in the <code><a>tone</a></code> attribute).</td>
        </tr>
      </tbody>
    </table>

    <p>The following events fire on <code><a>RTCDataChannel</a></code>
    objects:</p>

    <table border="1" style="border-width:0; width:60%">
      <tr>
        <th>Event name</th>

        <th>Interface</th>

        <th>Fired when...</th>
      </tr>
      <tbody>
        <tr>
          <td><dfn id="event-datachannel-open"><code>open</code></dfn>
          </td>

          <td><code><a>Event</a></code>
          </td>

          <td>
            The <code><a>RTCDataChannel</a></code> object's <a>underlying data transport</a>
            has been established (or re-established).
          </td>
        </tr>

        <tr>
          <td><dfn id=
          "event-datachannel-message"><code>MessageEvent</code></dfn>
          </td>

          <td><code><a>Event</a></code>
          </td>

          <td>A message was successfully received. TODO: Ref where MessageEvent
          is defined?</td>
        </tr>

        <tr>
          <td><dfn id="event-datachannel-error"><code>error</code></dfn>
          </td>

          <td><code><a>Event</a></code>
          </td>

          <td>TODO.</td>
        </tr>

        <tr>
          <td><dfn id="event-datachannel-close"><code>close</code></dfn>
          </td>

          <td><code><a>Event</a></code>
          </td>

          <td>
            The <code><a>RTCDataChannel</a></code> object's <a>underlying data transport</a>
            has been closed.
          </td>
        </tr>
      </tbody>
    </table>

    <p>The following events fire on <code><a>RTCSctpTransport</a></code>
    objects:</p>

    <table border="1" style="border-width:0; width:60%">
      <tr>
        <th>Event name</th>

        <th>Interface</th>

        <th>Fired when...</th>
      </tr>

      <tbody>
        <tr>
          <td><dfn id="event-datachannel"><code>datachannel</code></dfn>
          </td>

          <td><code><a>RTCDataChannelEvent</a></code>
          </td>

          <td>
            A new <code><a>RTCDataChannel</a></code>
            is dispatched to the script in response to the
            other peer creating a channel.
          </td>
        </tr>
      </tbody>
    </table>
  </section>

<section class="informative" id="webrtc-compat*">
  <h2>WebRTC 1.0 Compatibility</h2>

<p>It is a goal of the ORTC API to provide the functionality of the WebRTC 1.0 API [[WEBRTC10]], as well as to enable the 
WebRTC 1.0 API to be implemented on top of the ORTC API, utilizing a Javascript "shim" library.  This section
discusses WebRTC 1.0 compatibility issues that have been encountered by ORTC API implementers. 
</p>

<section id="voice-activity*">
  <h3>Voice Activity Detection</h3>

<p>[[WEBRTC10]] Section 4.2.4 defines the <code>RTCOfferOptions</code> dictionary, which includes the <var>voiceActivityDetection</var> attribute,
which determines whether Voice Activity Detection (VAD) is enabled within the Offer produced by <code>createOffer()</code>. 
The effect of setting <var>voiceActivityDetection</var> to <var>true</var> is to include the Comfort Noice (CN) codec defined in 
[[RFC3389]] within the Offer.</p>
<p> 
Within ORTC API, equivalent behavior can be obtained by configuring the Comfort Noise codec for use within the <code>RTCRtpParameters</code> object,
or configuring a codec with built-in support for Comfort Noise (such as Opus) to enable comfort noise. 
</p>
</section>
</section>
<section class="informative" id="examples*">
  <h2>Examples</h2>

  <section id="simple-peer-to-peer-example*">
    <h3>Simple Peer-to-peer Example</h3>

    <p>This example code provides a basic audio and video session between two browsers.</p>

<pre class="example"><code>
</code></pre>
  </section>
  <section id="js-library-example*">
    <h3>myCapsToSendParams Example</h3>

<pre class="example"<code>
RTCRtpParameters function myCapsToSendParams (RTCRtpCapabilities sendCaps, RTCRtpCapabilities remoteRecvCaps) {
// Function returning the sender RTCRtpParameters, based on the local sender and remote receiver capabilities.
// The goal is to enable a single stream audio and video call with minimum fuss. 
//
// Steps to be followed: 
// 1. Determine the RTP features that the receiver and sender have in common. 
// 2. Determine the codecs that the sender and receiver have in common.
// 3. Within each common codec, determine the common formats, header extensions and rtcpFeedback mechanisms.
// 4. Determine the payloadType to be used, based on the receiver preferredPayloadType. 
// 5. Set RTCRtcpParameters such as mux to their default values.  
// 6. Return RTCRtpParameters enablig the jointly supported features and codecs.
}

RTCRtpParameters function myCapsToRecvParams (RTCRtpCapabilities recvCaps, RTCRtpCapabilities remoteSendCaps) {
// Function returning the receiver RTCRtpParameters, based on the local receiver and remote sender capabilities.
return myCapsToSendParams(remoteSendCaps, recvCaps);
}
</code></pre>

  </section>
</section>

  <section class="appendix">

  <h2>Acknowledgements</h2>
  <p>The editor wishes to thank Erik Lagerway for his support.
  Substantial text in this specification was provided by many people including Peter Thatcher, Martin Thomson,
  Iñaki Baz Castillo, Jose Luis Millan, Christoph Dorn, Roman Shpount, Emil Ivov, Shijun Sun and Jason Ausborn.
  </p>
  </section>

  <section id="change-log*">
    <h2>Change Log</h2>

    <p>This section will be removed before publication.</p>
    <!-- Why do the first two headings automatically convert to <h2>? -->

  <section id="since-16-July-2014*">
    <h3>Changes since 16 July 2014</h3>

    <ol>
      <li> Clarification of the ICE restart issue, as noted in :
           <a href="https://github.com/openpeer/ortc/issues/93">Issue 93</a></li>
      <li> Clarified onerror usage in sender and receiver objects, as noted in:
           <a href="https://github.com/openpeer/ortc/issues/95">Issue 95</a></li>
      <li> Clarified SST-MS capability issue noted in:
           <a href="https://github.com/openpeer/ortc/issues/108">Issue 108</a></li>
      <li> Clarification of <code>send()</code> and <code>receive()</code> usage as noted in:
           <a href="https://github.com/openpeer/ortc/issues/119">Issue 119</a></li>
      <li> Changed ICE state diagram as noted in:
           <a href="https://github.com/openpeer/ortc/issues/122">Issue 122</a></li>
      <li> Removed getParameters methods and changed send() method as noted in:
           <a href="https://github.com/openpeer/ortc/issues/136">Issue 136</a></li>
      <li> Changed definition of framerateScale and resolutionScale as noted in:
           <a href="https://github.com/openpeer/ortc/issues/137">Issue 137</a></li>
      <li> Substituted "muxId" for the "receiverId" as noted in:
           <a href="https://github.com/openpeer/ortc/issues/138">Issue 138</a> and
           <a href="https://github.com/openpeer/ortc/issues/140">Issue 140</a> 
      </li>
      <li> Clarified the setting of <var>track.kind</var> as described in: 
           <a href="https://github.com/openpeer/ortc/issues/141">Issue 141</a></li>
      <li> Added SSRC conflict event to the <code>RTCRtpSender</code>, as described in: 
           <a href="https://github.com/openpeer/ortc/issues/143">Issue 143</a></li>
      <li> Addressed the "end of candidates" issues noted in: 
           <a href="https://github.com/openpeer/ortc/issues/142">Issue 142</a> and
           <a href="https://github.com/openpeer/ortc/issues/144">Issue 144</a>
      </li>
</ol>
   </section>

  <section id="since-16-June-2014*">
    <h3>Changes since 16 June 2014</h3>

    <ol>
      <li> Added section on WebRTC 1.0 compatibility issues, responding to
           <a href="https://github.com/openpeer/ortc/issues/66">Issue 66</a></li>
      <li> Added Identity support, as described in
           <a href="https://github.com/openpeer/ortc/issues/78">Issue 78</a></li>
      <li> Reworked getStats method, as described in
           <a href="https://github.com/openpeer/ortc/issues/85">Issue 85</a></li>
      <li> Removed ICE restart method described in
           <a href="https://github.com/openpeer/ortc/issues/93">Issue 93</a></li>
      <li> Addressed CNAME and synchronization context issues described in 
           <a href="https://github.com/openpeer/ortc/issues/94">Issue 94</a></li>
      <li> Fixed WebIDL issues noted in 
           <a href="https://github.com/openpeer/ortc/issues/97">Issue 97</a></li>
      <li> Addressed NITs described in
           <a href="https://github.com/openpeer/ortc/issues/99">Issue 99</a></li>
      <li> DTLS transport issues fixed as described in
           <a href="https://github.com/openpeer/ortc/issues/100">Issue 100</a></li>
      <li> ICE transport issues fixed as described in
           <a href="https://github.com/openpeer/ortc/issues/101">Issue 101</a></li>
      <li> ICE transport controller fixes made as described in
           <a href="https://github.com/openpeer/ortc/issues/102">Issue 102</a></li>
      <li> Sender and Receiver object fixes made as described in
           <a href="https://github.com/openpeer/ortc/issues/103">Issue 103</a></li>
      <li> Fixed RTCRtpEncodingParameter default issues described in
           <a href="https://github.com/openpeer/ortc/issues/104">Issue 104</a></li>
      <li> Fixed 'Big Picture' issues descibed in
           <a href="https://github.com/openpeer/ortc/issues/105">Issue 105</a></li>
      <li> Fixed RTCRtpParameter default issues described in
           <a href="https://github.com/openpeer/ortc/issues/106">Issue 106</a></li>
      <li> Added a multi-stream capability, as noted in 
           <a href="https://github.com/openpeer/ortc/issues/108">Issue 108</a></li>
      <li> Removed quality scalability capabilities and parameters, as described in 
           <a href="https://github.com/openpeer/ortc/issues/109">Issue 109</a></li>
      <li> Added scalability examples as requested in
           <a href="https://github.com/openpeer/ortc/issues/110">Issue 110</a></li>
      <li> Addressed WebRTC 1.0 Data Channel compatibility issue described in
           <a href="https://github.com/openpeer/ortc/issues/111">Issue 111</a></li>
      <li> Removed header extensions from <code><a>RTCRtpCodecParameters</a></code> as described in 
           <a href="https://github.com/openpeer/ortc/issues/113">Issue 113</a></li>
      <li> Addressed RTP/RTCP non-mux issues with IdP as described in 
           <a href="https://github.com/openpeer/ortc/issues/114">Issue 114</a></li>
      <li> Added getParameter methods to <code><a>RTCRtpSender</a></code> and <code><a>RTCRtpReceiver</a></code> objects, as described in
           <a href="https://github.com/openpeer/ortc/issues/116">Issue 116</a></li>
      <li> Added layering diagrams as requested in
           <a href="https://github.com/openpeer/ortc/issues/117">Issue 117</a></li>
      <li> Added a typedef for payload type, as described in
           <a href="https://github.com/openpeer/ortc/issues/118">Issue 118</a></li>
      <li> Moved <code>onerror</code> from the <code><a>RTCIceTransport</a></code> object to the <code><a>RTCIceListener</a></code> object as described in
           <a href="https://github.com/openpeer/ortc/issues/121">Issue 121</a></li>
      <li> Added explanation of Voice Activity Detection (VAD), responding to
           <a href="https://github.com/openpeer/ortc/issues/129">Issue 129</a></li>
      <li> Clarified the meaning of maxTemporalLayers and maxSpatialLayers, as noted in
           <a href="https://github.com/openpeer/ortc/issues/130">Issue 130</a></li>
      <li> Added RFC 6051 to the list of header extensions and removed RFC 5450, as noted in 
           <a href="https://github.com/openpeer/ortc/issues/131">Issue 131</a></li>
      <li> Addressed ICE terminology issues, as described in
           <a href="https://github.com/openpeer/ortc/issues/132">Issue 132</a></li>
      <li> Separated references into Normative and Informative, as noted in
           <a href="https://github.com/openpeer/ortc/issues/133">Issue 133</a></li>
    </ol>
   </section>

  <section id="since-14-May-2014*">
    <h3>Changes since 14 May 2014</h3>

    <ol>
      <li> Added support for non-multiplexed RTP/RTCP and ICE freezing, as described in 
           <a href="https://github.com/openpeer/ortc/issues/57">Issue 57</a></li>
      <li> Added support for getRemoteCertificates(), as described in
           <a href="https://github.com/openpeer/ortc/issues/67">Issue 67</a></li>
      <li> Removed filterParameters and createParameters functions, as described in
           <a href="https://github.com/openpeer/ortc/issues/80">Issue 80</a></li>
      <li> Partially addressed capabilities issues, as described in
           <a href="https://github.com/openpeer/ortc/issues/84">Issue 84</a></li>
      <li> Addressed WebIDL type issues described in
           <a href="https://github.com/openpeer/ortc/issues/88">Issue 88</a></li>
      <li> Addressed Overview section issues described in
           <a href="https://github.com/openpeer/ortc/issues/91">Issue 91</a></li>
      <li> Addressed readonly attribute issues described in
           <a href="https://github.com/openpeer/ortc/issues/92">Issue 92</a></li>
      <li> Added ICE restart method to address the issue described in 
           <a href="https://github.com/openpeer/ortc/issues/93">Issue 93</a></li>
      <li> Added onerror eventhandler to sender and receiver objects as described in
           <a href="https://github.com/openpeer/ortc/issues/95">Issue 95</a></li>
    </ol>
   </section>

  <section class="informative" id="since-29-April-2014*">
    <h3>Changes since 29 April 2014</h3>

    <ol>
      <li> ICE restart explanation added, as described in
           <a href="https://github.com/openpeer/ortc/issues/59">Issue 59</a></li>
      <li> Fixes for error handling, as described in
           <a href="https://github.com/openpeer/ortc/issues/75">Issue 75</a></li>
      <li> Fixes for miscellaneous NITs, as described in
           <a href="https://github.com/openpeer/ortc/issues/76">Issue 76</a></li>
      <li> Enable retrieval of the SSRC to be used by RTCP, as described in
           <a href="https://github.com/openpeer/ortc/issues/77">Issue 77</a></li>
      <li> Support for retrieval of audio and video capabilities, as described in
           <a href="https://github.com/openpeer/ortc/issues/81">Issue 81</a></li>
      <li> getStats interface updated, as described in
           <a href="https://github.com/openpeer/ortc/issues/82">Issue 82</a></li>
      <li> Partially addressed SVC issues described in
           <a href="https://github.com/openpeer/ortc/issues/83">Issue 83</a></li>
      <li> Partially addressed statistics update issues described in
           <a href="https://github.com/openpeer/ortc/issues/85">Issue 85</a></li>
    </ol>
   </section>

  <section id="since-12-April-2014*">
    <h3>Changes since 12 April 2014</h3>

    <ol>
      <li> Fixes for error handling, as described in
           <a href="https://github.com/openpeer/ortc/issues/26">Issue 26</a></li>
      <li> Support for contributing sources removed (re-classified as a 1.2 feature), as described in
           <a href="https://github.com/openpeer/ortc/issues/27">Issue 27</a></li>
      <li> Cleanup of DataChannel construction, as described in
           <a href="https://github.com/openpeer/ortc/issues/60">Issue 60</a></li>
      <li> Separate proposal on simulcast/layering, as described in
           <a href="https://github.com/openpeer/ortc/issues/61">Issue 61</a></li>
      <li> Separate proposal on quality, as described in
           <a href="https://github.com/openpeer/ortc/issues/62">Issue 62</a></li>
      <li> Fix for TCP candidate type, as described in
           <a href="https://github.com/openpeer/ortc/issues/63">Issue 63</a></li>
      <li> Fix to the fingerprint attribute, as described in
           <a href="https://github.com/openpeer/ortc/issues/64">Issue 64</a></li>
      <li> Fix to RTCRtpFeatures, as described in
           <a href="https://github.com/openpeer/ortc/issues/65">Issue 65</a></li>
      <li> Support for retrieval of remote certificates, as described in
           <a href="https://github.com/openpeer/ortc/issues/67">Issue 67</a></li>
      <li> Support for ICE error handling, described in
           <a href="https://github.com/openpeer/ortc/issues/68">Issue 68</a></li>
      <li> Support for Data Channel send rate control, as described in
           <a href="https://github.com/openpeer/ortc/issues/69">Issue 69</a></li>
      <li> Support for capabilities and settings, as described in
           <a href="https://github.com/openpeer/ortc/issues/70">Issue 70</a></li>
      <li> Removal of duplicate RTCIceListener functionality, as described in
           <a href="https://github.com/openpeer/ortc/issues/71">Issue 71</a></li>
      <li> ICE gathering state added, as described in
           <a href="https://github.com/openpeer/ortc/issues/72">Issue 72</a></li>
      <li> Removed ICE role from the ICE transport constructor, as described in
           <a href="https://github.com/openpeer/ortc/issues/73">Issue 73</a></li>
    </ol>
   </section>


  <section id="since-13-February-2014*">
    <h3>Changes since 13 February 2014</h3>

     <ol>
      <li> Support for contributing source information added, as described in
           <a href="https://github.com/openpeer/ortc/issues/27">Issue 27</a></li>
      <li> Support for control of quality, resolution, framerate and layering added, as described in
           <a href="https://github.com/openpeer/ortc/issues/31">Issue 31</a></li>
      <li> RTCRtpListener object added and figure in Section 1 updated, as described in
           <a href="https://github.com/openpeer/ortc/issues/32">Issue 32</a></li>
      <li> More complete support for RTP and Codec Parameters added, as described in
           <a href="https://github.com/openpeer/ortc/issues/33">Issue 33</a></li>
      <li> Data Channel transport problem fixed, as described in
           <a href="https://github.com/openpeer/ortc/issues/34">Issue 34</a></li>
      <li> Various NITs fixed, as described in
           <a href="https://github.com/openpeer/ortc/issues/37">Issue 37</a></li>
      <li> Section 2.2 and 2.3 issues fixed, as described in
           <a href="https://github.com/openpeer/ortc/issues/38">Issue 38</a></li>
      <li> Default values of some dictionary attributes added, to partially address the issue described in
           <a href="https://github.com/openpeer/ortc/issues/39">Issue 39</a></li>
      <li> Support for ICE TCP added, as described in
           <a href="https://github.com/openpeer/ortc/issues/41">Issue 41</a></li>
      <li> Fixed issue with sequences as attributes, as described in
           <a href="https://github.com/openpeer/ortc/issues/43">Issue 43</a></li>
      <li> Fix for issues with onlocalcandidate, as described in
           <a href="https://github.com/openpeer/ortc/issues/44">Issue 44</a></li>
      <li> Initial stab at a Stats API, as requested in 
           <a href="https://github.com/openpeer/ortc/issues/46">Issue 46</a></li>
      <li> Added support for ICE gather policy, as described in
           <a href="https://github.com/openpeer/ortc/issues/47">Issue 47</a></li>
     </ol>

</section>

  <section id="since-07-November-2013*">
    <h3>Changes since 07 November 2013</h3>

    <ol>

      <li> RTCTrack split into RTCRtpSender and RTCRtpReceiver objects, as proposed on 
           <a href="http://lists.w3.org/Archives/Public/public-orca/2014Jan/0000.html"> 06 January 2014.</a></li>
      <li> RTCConnection split into RTCIceTransport and RTCDtlsTransport objects, as proposed on 
           <a href="http://lists.w3.org/Archives/Public/public-orca/2014Jan/0005.html"> 09 January 2014. </a></li>
      <li> RTCSctpTransport object added, as described in 
           <a href="https://github.com/openpeer/ortc/issues/25">Issue 25</a></li>
      <li> RTCRtpHeaderExtensionParameters added, as described in 
           <a href="https://github.com/openpeer/ortc/issues/28">Issue 28</a></li>
      <li> RTCIceListener added, in order to support parallel forking, as described in
           <a href="https://github.com/openpeer/ortc/issues/29">Issue 29</a></li>
      <li> DTMF support added, as described in
           <a href="https://github.com/openpeer/ortc/issues/30">Issue 30</a></li>
    </ol>
   </section>
  </section>
</body>
</html>
